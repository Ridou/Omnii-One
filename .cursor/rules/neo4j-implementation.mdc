---
description: 
globs: 
alwaysApply: false
---
# Neo4j Brain-Like Memory Implementation (Using Existing Neural Schema)

## üß† **Executive Summary**

This plan leverages your **existing Neo4j neural pathway schema** (`ChatMessage`, `Concept`, `Tag`, `Memory`, `User`, `OAuthToken` nodes with `HAS_MEMORY`, `MENTIONS`, `HAS_TAG`, `RELATED_TO`, `OWNS` relationships) to create a brain-like long-term memory system. Instead of creating new schemas, we enhance existing nodes with memory properties and create brain-inspired relationships to mimic hippocampus ‚Üí cortex memory consolidation, semantic networks, and associative memory patterns.

## üîó **NEURAL PATHWAY INTEGRATION (Leveraging Existing Schema)**

### **Brain-Inspired Node Mapping**
```
Human Brain System ‚Üí Existing Neo4j Nodes ‚Üí Enhanced Properties
‚îú‚îÄ‚îÄ Hippocampus (Short-term) ‚Üí ChatMessage nodes ‚Üí +importance_score, +intent, +sentiment
‚îú‚îÄ‚îÄ Cortex (Long-term) ‚Üí Memory nodes ‚Üí +consolidation_status, +memory_type
‚îú‚îÄ‚îÄ Semantic Networks ‚Üí Concept nodes ‚Üí +activation_strength, +mention_count
‚îú‚îÄ‚îÄ Associative Links ‚Üí RELATED_TO relationships ‚Üí +strength, +last_activated
‚îú‚îÄ‚îÄ Episodic Memory ‚Üí ChatMessage-[:HAS_MEMORY]->Memory ‚Üí +episode_type
‚îî‚îÄ‚îÄ Working Memory ‚Üí Redis cache + recent ChatMessage traversals
```

### **‚úÖ ExecutionContext Extension (Minimal Change)**
The existing `ExecutionContext` interface needs minimal enhancement:

```typescript
// apps/omnii_mcp/src/types/action-planning.types.ts (Enhanced)
export interface ExecutionContext {
  entityId: string;
  phoneNumber: string;
  userTimezone: string;
  localDatetime?: string;
  stepResults: Map<string, StepResult>;
  currentStepIndex: 0;
  entities: CachedEntity[];
  sessionId: string;
  planState: PlanState;
  context?: ExecutionContextType;
  // NEW: Brain-like memory context (uses existing schema)
  brainMemoryContext?: BrainMemoryContext;
  // NEW: Communication channel awareness
  communicationChannel?: 'sms' | 'chat' | 'websocket';
  // Simplified chat context (maps to existing ChatMessage properties)
  chatMetadata?: {
    chatId: string;
    isGroupChat?: boolean;
    participants?: string[];
  };
}
```

### **‚úÖ SimpleSMSAI Integration Points (Brain-Enhanced)**
Your existing `SimpleSMSAI.processMessage()` becomes a neural input processor:
- ‚úÖ Phone-to-email mapping ‚Üí User identification for memory storage
- ‚úÖ Intervention handling ‚Üí Enhanced with episodic memory context
- ‚úÖ Entity resolution ‚Üí Linked to existing Concept nodes for semantic memory
- ‚úÖ Redis session tracking ‚Üí Working memory cache for brain-like processing

### **‚úÖ Chat Integration Strategy (Neural Pathway Enhancement)**
Perfect integration points for real-time neural processing:
- ‚úÖ WebSocket message handlers ‚Üí Hippocampus-like immediate memory storage
- ‚úÖ Chat message processing ‚Üí Enhanced ChatMessage nodes with brain properties
- ‚úÖ Unified memory context ‚Üí Cross-channel associative memory via RELATED_TO
- ‚úÖ Real-time threading ‚Üí Memory consolidation through existing relationships

## üîç **Existing Neural Infrastructure**

### **Current Neural Foundation (Already Available)**
- ‚úÖ `ChatMessage` nodes - Perfect for conversation storage (hippocampus-like)
- ‚úÖ `Concept` nodes - Ideal semantic memory network
- ‚úÖ `Tag` nodes - Natural categorization system  
- ‚úÖ `Memory` nodes - Ready for episodic memory consolidation
- ‚úÖ `User` nodes - User-specific memory ownership via OWNS relationships
- ‚úÖ `OAuthToken` nodes - Service context linking via existing relationships
- ‚úÖ `neo4j-service.ts` - Production-ready Neo4j foundation
- ‚úÖ Existing relationships - Perfect neural pathways already established

### **Brain-Like Enhancement Strategy**
- **Enhance** existing ChatMessage nodes with brain properties (importance_score, sentiment, intent)
- **Utilize** existing Memory nodes for consolidation (add consolidation_status, memory_type)
- **Activate** Concept nodes for semantic networks (add activation_strength, mention_count)
- **Strengthen** RELATED_TO relationships for associative memory (add strength, last_activated)
- **Leverage** existing HAS_MEMORY relationships for episodic linking
- **Preserve** all existing functionality while adding brain-like capabilities

## üìä **Brain-Like Validation Schemas (Mapping to Existing Nodes)**

### **Enhanced Node Property Schemas (Using Existing Schema)**

```typescript
// apps/omnii-mobile/src/types/brain-memory-schemas.ts
import { z } from 'zod';
import { UnifiedToolResponseSchema, ServiceType } from './unified-response.validation';

// Enhanced ChatMessage node properties (brain-like enhancement with time-based working memory)
export const EnhancedChatMessageSchema = z.object({
  // Existing ChatMessage properties (preserved)
  id: z.string().uuid("ChatMessage ID must be valid UUID"),
  content: z.string().min(1).max(50000, "Content too long"),
  timestamp: z.string().datetime("Invalid timestamp format"),
  
  // NEW: Brain-like properties (added to existing ChatMessage nodes)
  channel: z.enum(['sms', 'chat', 'websocket'], {
    errorMap: () => ({ message: "Invalid channel type" })
  }),
  source_identifier: z.string().min(1, "Source required"), // Phone number for SMS, chat ID for chat
  intent: z.string().optional(),
  sentiment: z.number().min(-1).max(1).optional(),
  importance_score: z.number().min(0).max(1).optional(),
  
  // NEW: Time-based working memory properties
  last_modified: z.string().datetime().optional(), // Track when node was last modified
  modification_reason: z.string().optional(), // Why it was modified (concept_update, tag_added, etc.)
  
  // Channel-specific metadata (JSON stored in ChatMessage properties)
  sms_metadata: z.object({
    phone_number: z.string(),
    is_incoming: z.boolean(),
    local_datetime: z.string().optional()
  }).optional(),
  
  chat_metadata: z.object({
    chat_id: z.string(),
    websocket_session_id: z.string().optional(),
    is_group_chat: z.boolean().default(false),
    participants: z.array(z.string()).default([])
  }).optional(),
  
  // Google services context (for existing RELATED_TO relationships)
  google_service_context: z.object({
    service_type: z.enum(['calendar', 'tasks', 'contacts', 'email']).optional(),
    operation: z.string().optional(),
    success: z.boolean().optional()
  }).optional()
});

// Enhanced Memory node properties (brain-like consolidation)
export const EnhancedMemorySchema = z.object({
  // Existing Memory properties (preserved)
  id: z.string().uuid("Memory ID must be valid UUID"),
  timestamp: z.string().datetime(),
  
  // NEW: Brain-like properties (added to existing Memory nodes)
  memory_type: z.enum(['episodic', 'semantic', 'procedural', 'working']).default('episodic'),
  consolidation_status: z.enum(['fresh', 'consolidating', 'consolidated', 'archived']).default('fresh'),
  consolidation_date: z.string().datetime().optional(),
  episode_type: z.enum(['conversation', 'action', 'service_interaction']).optional(),
  channel: z.enum(['sms', 'chat', 'websocket']).optional(),
  original_message_id: z.string().uuid().optional(),
  consolidation_summary: z.string().optional(),
  importance_score: z.number().min(0).max(1).optional()
});

// Enhanced Concept node properties (semantic network activation)
export const EnhancedConceptSchema = z.object({
  // Existing Concept properties (preserved)
  id: z.string().uuid("Concept ID must be valid UUID"),
  name: z.string().min(1).max(100),
  
  // NEW: Brain-like properties (added to existing Concept nodes)
  activation_strength: z.number().min(0).max(1).default(0),
  mention_count: z.number().int().min(0).default(0),
  last_mentioned: z.string().datetime().optional(),
  semantic_weight: z.number().min(0).max(1).default(0.5),
  user_id: z.string().min(1, "User ID required")
});

// Enhanced Tag node properties (categorization system)
export const EnhancedTagSchema = z.object({
  // Existing Tag properties (preserved)  
  id: z.string().uuid("Tag ID must be valid UUID"),
  name: z.string().min(1).max(100),
  
  // NEW: Brain-like properties (added to existing Tag nodes)
  usage_count: z.number().int().min(0).default(0),
  last_used: z.string().datetime().optional(),
    channel_origin: z.enum(['sms', 'chat', 'websocket']).optional(),
  category: z.enum(['entity', 'topic', 'action', 'emotion', 'temporal', 'location', 'google_service']).optional(),
  user_id: z.string().min(1, "User ID required")
});

// Brain-like memory context schema (uses existing node structure with time-based working memory)
export const BrainMemoryContextSchema = z.object({
  // Working memory (3-week time window: previous + current + next week)
  working_memory: z.object({
    recent_messages: z.array(EnhancedChatMessageSchema), // Most recent for immediate context
    time_window_messages: z.array(EnhancedChatMessageSchema), // 3-week time window
    recently_modified_messages: z.array(EnhancedChatMessageSchema), // Recently modified nodes
    active_concepts: z.array(z.string()), // Concept node IDs
    current_intent: z.string().optional(),
    time_window_stats: z.object({
      previous_week_count: z.number(),
      current_week_count: z.number(),
      next_week_count: z.number(),
      recently_modified_count: z.number()
    })
  }),
  
  // Episodic memory (conversation episodes via ChatMessage-[:HAS_MEMORY]->Memory)
  episodic_memory: z.object({
    conversation_threads: z.array(z.object({
      thread_id: z.string(),
      messages: z.array(EnhancedChatMessageSchema),
      semantic_weight: z.number().min(0).max(1),
      memory_node_id: z.string().uuid().optional() // Links to Memory node
    })),
    related_episodes: z.array(z.string()) // Memory node IDs
  }),
  
  // Semantic memory (concept associations via Concept nodes and relationships)
  semantic_memory: z.object({
    activated_concepts: z.array(z.object({
      concept: EnhancedConceptSchema,
      activation_strength: z.number().min(0).max(1),
      related_concepts: z.array(z.string()) // Concept node IDs via RELATED_TO
    })),
    concept_associations: z.array(z.object({
      from_concept: z.string(), // Concept node ID
      to_concept: z.string(), // Concept node ID
      association_strength: z.number().min(0).max(1), // From RELATED_TO.strength
      relationship_type: z.string().optional() // RELATED_TO, CONTAINS_CONCEPT, etc.
    }))
  }),
  
  // Memory consolidation metadata (brain-like processing state)
  consolidation_metadata: z.object({
    retrieval_timestamp: z.string().datetime(),
    memory_strength: z.number().min(0).max(1),
    context_channels: z.array(z.enum(['sms', 'chat', 'websocket'])),
    memory_age_hours: z.number(),
    consolidation_score: z.number().min(0).max(1),
    
    // Brain-like memory constants
    working_memory_limit: z.number().default(7), // Miller's magic number
    episodic_window_hours: z.number().default(168), // 1 week
    semantic_activation_threshold: z.number().default(0.3),
    
    // Channel-specific optimizations (preserved from original)
  sms_optimization: z.object({
    character_budget: z.number().default(1500),
    suggested_response_length: z.enum(['brief', 'normal', 'detailed']).default('normal')
  }).optional(),
    
  chat_optimization: z.object({
    max_message_length: z.number().default(4000),
    supports_rich_content: z.boolean().default(true),
    real_time_context: z.boolean().default(true),
      thread_aware: z.boolean().default(true)
  }).optional()
  })
});

// Enhanced relationship properties (for existing RELATED_TO, HAS_MEMORY relationships)
export const EnhancedRelationshipSchema = z.object({
  // For RELATED_TO relationships (associative memory)
  strength: z.number().min(0).max(1).optional(), 
  last_activated: z.string().datetime().optional(),
  association_type: z.enum(['semantic', 'episodic', 'temporal', 'causal']).optional(),
  activation_count: z.number().int().min(0).default(0),
  
  // For service relationships (TRIGGERED_SERVICE, etc.)
  operation: z.string().optional(),
  success: z.boolean().optional(),
  service_metadata: z.record(z.any()).optional()
});

// Inferred types for brain-like memory system
export type EnhancedChatMessage = z.infer<typeof EnhancedChatMessageSchema>;
export type EnhancedMemory = z.infer<typeof EnhancedMemorySchema>;
export type EnhancedConcept = z.infer<typeof EnhancedConceptSchema>;
export type EnhancedTag = z.infer<typeof EnhancedTagSchema>;
export type BrainMemoryContext = z.infer<typeof BrainMemoryContextSchema>;
export type EnhancedRelationship = z.infer<typeof EnhancedRelationshipSchema>;
```

## üß† **Brain-Like ConversationManager (Using Existing Schema)**

### **Core Brain Memory Manager with Neural Processing**

```typescript
// apps/omnii_mcp/src/services/memory/brain-conversation-manager.ts
import neo4j, { Driver, Session, Transaction } from 'neo4j-driver';
import { v4 as uuidv4 } from 'uuid';
import { 
  EnhancedChatMessage, 
  EnhancedChatMessageSchema,
  EnhancedMemory,
  EnhancedMemorySchema,
  EnhancedConcept,
  EnhancedConceptSchema,
  EnhancedTag,
  EnhancedTagSchema,
  BrainMemoryContext, 
  BrainMemoryContextSchema,
  EnhancedRelationship
} from '../../types/brain-memory-schemas';
import { redisCache } from '../redis-cache';
import { OpenAI } from 'openai';

export class BrainConversationManager {
  private driver: Driver;
  private openai: OpenAI;
  
  // Brain-like memory constants (Enhanced with time-based working memory)
  private readonly WORKING_MEMORY_SIZE = 7; // Human working memory limit (for recent items)
  private readonly WORKING_MEMORY_TIME_WINDOW_DAYS = 21; // 3 weeks (previous + current + next)
  private readonly EPISODIC_MEMORY_WINDOW_HOURS = 168; // 1 week for deep episodic search
  private readonly SEMANTIC_ACTIVATION_THRESHOLD = 0.3;
  private readonly MEMORY_CONSOLIDATION_HOURS = 24;
  private readonly CACHE_TTL = 1800; // 30 minutes
  private readonly RECENT_MODIFICATION_HOURS = 2; // Pull recently modified nodes back to working memory

  constructor() {
    // Production Neo4j connection (AuraDB)
    this.driver = neo4j.driver(
      process.env.NEO4J_URI, // neo4j+s://d066c29d.databases.neo4j.io
      neo4j.auth.basic(
        process.env.NEO4J_USER, // neo4j
        process.env.NEO4J_PASSWORD // _o0JebFPkSb51lSjC7BUqdsvDhD4e5bYGFV1uoVv3QE
      ),
      {
        database: process.env.NEO4J_DATABASE, // neo4j
        encrypted: true, // Required for AuraDB
        trust: 'TRUST_SYSTEM_CA_SIGNED_CERTIFICATES',
        maxConnectionLifetime: 30 * 60 * 1000, // 30 minutes
        maxConnectionPoolSize: 50,
        connectionAcquisitionTimeout: 60000, // 60 seconds
        logging: {
          level: process.env.NODE_ENV === 'production' ? 'warn' : 'debug',
          logger: (level: string, message: string) => console.log(`[Neo4j-${level.toUpperCase()}] ${message}`)
        }
      }
    );

    this.openai = new OpenAI({
      apiKey: process.env.OPENAI_API_KEY
    });

    // Production-ready configuration
    this.CACHE_TTL = parseInt(process.env.MEMORY_CACHE_TTL || '3600'); // 1 hour default
    this.WORKING_MEMORY_SIZE = 7; // Human cognitive limit
    this.WORKING_MEMORY_TIME_WINDOW_DAYS = 21; // 3 weeks for temporal context
    
    console.log('üß† BrainConversationManager initialized with AuraDB connection');
    console.log(`üîó Connected to: ${process.env.NEO4J_URI?.split('@')[1] || 'Neo4j'}`);
    console.log(`üíæ Database: ${process.env.NEO4J_DATABASE}`);
    console.log(`‚öôÔ∏è Environment: ${process.env.NODE_ENV}`);
  }

  /**
   * Store SMS conversation using existing ChatMessage nodes (hippocampus-like processing)
   * Enhances existing ChatMessage schema with brain-like properties
   */
  async storeSMSConversation(data: {
    user_id: string;
    content: string;
    phone_number: string;
    is_incoming: boolean;
    local_datetime?: string;
    google_service_context?: {
      service_type?: 'calendar' | 'tasks' | 'contacts' | 'email';
      operation?: string;
      entity_ids?: string[];
    };
  }): Promise<EnhancedChatMessage> {
    console.log(`[BrainMemory] üíæ Storing SMS conversation (hippocampus-like processing) for user: ${data.user_id}`);
    
    const session = this.driver.session();
    
    try {
      const messageId = uuidv4();
      
      // Brain-like content analysis (intent, sentiment, importance)
      const insights = await this.analyzeLikeBrain(data.content, data.is_incoming, 'sms');
      
      // Create enhanced ChatMessage node with brain properties and time-based tracking
      const result = await session.run(`
        // Create ChatMessage node with brain-like properties and time tracking
        CREATE (msg:ChatMessage {
          id: $id,
          content: $content,
          timestamp: datetime($timestamp),
          last_modified: datetime($timestamp),
          modification_reason: 'created',
          channel: $channel,
          source_identifier: $source_identifier,
          intent: $intent,
          sentiment: $sentiment,
          importance_score: $importance_score,
          sms_metadata: $sms_metadata,
          google_service_context: $google_service_context
        })
        
        // Link to User via existing OWNS relationship
        WITH msg
        MATCH (user:User {id: $user_id})
        CREATE (user)-[:OWNS]->(msg)
        
        // Create episodic Memory node and link via existing HAS_MEMORY relationship
        CREATE (memory:Memory {
          id: $memory_id,
          timestamp: datetime($timestamp),
          memory_type: 'episodic',
          consolidation_status: 'fresh',
          episode_type: 'conversation',
          channel: $channel,
          original_message_id: $id,
          importance_score: $importance_score
        })
        
        CREATE (msg)-[:HAS_MEMORY]->(memory)
        
        RETURN msg, memory
      `, {
        id: messageId,
        content: data.content,
        timestamp: new Date().toISOString(),
        channel: 'sms',
        source_identifier: data.phone_number,
        intent: insights.intent,
        sentiment: insights.sentiment,
        importance_score: insights.importance_score,
        sms_metadata: JSON.stringify({
          phone_number: data.phone_number,
          is_incoming: data.is_incoming,
          local_datetime: data.local_datetime
        }),
        google_service_context: data.google_service_context ? JSON.stringify(data.google_service_context) : null,
        user_id: data.user_id,
        memory_id: uuidv4()
      });

      // Extract and link to existing Concept nodes (semantic memory)
      await this.extractAndLinkConcepts(session, messageId, data.content, data.user_id);
      
      // Create/update existing Tag nodes (categorization)
      await this.createSemanticTags(session, messageId, data.content, data.user_id, 'sms');
      
      // Create associative links with existing ChatMessage nodes via RELATED_TO
      await this.createAssociativeLinks(session, messageId, data.user_id, 'sms');
      
      // Link to Google services via existing relationships
        if (data.google_service_context) {
        await this.linkToGoogleServices(session, messageId, data.google_service_context);
      }
      
      console.log(`[BrainMemory] ‚úÖ Stored SMS conversation with brain-like processing: ${messageId}`);
      
      // Return enhanced ChatMessage data
      return EnhancedChatMessageSchema.parse({
        id: messageId,
        content: data.content,
        timestamp: new Date().toISOString(),
        channel: 'sms',
        source_identifier: data.phone_number,
        intent: insights.intent,
        sentiment: insights.sentiment,
        importance_score: insights.importance_score,
        sms_metadata: {
          phone_number: data.phone_number,
          is_incoming: data.is_incoming,
          local_datetime: data.local_datetime
        },
        google_service_context: data.google_service_context
      });
      
      } finally {
        await session.close();
    }
  }

  /**
   * Store chat conversation using existing ChatMessage nodes (real-time hippocampus processing)
   * Enhances existing ChatMessage schema with brain-like properties for real-time chat
   */
  async storeChatConversation(data: {
    user_id: string;
    content: string;
    chat_id: string;
    is_incoming: boolean;
    websocket_session_id?: string;
    thread_id?: string;
    is_group_chat?: boolean;
    participants?: string[];
    reply_to_message_id?: string;
    message_sequence?: number;
    google_service_context?: {
      service_type?: 'calendar' | 'tasks' | 'contacts' | 'email';
      operation?: string;
      entity_ids?: string[];
    };
  }): Promise<EnhancedChatMessage> {
    console.log(`[BrainMemory] üí¨ Storing chat conversation (real-time hippocampus processing) for user: ${data.user_id}`);
    
    const session = this.driver.session();
    
    try {
      const messageId = uuidv4();
      
      // Brain-like content analysis (enhanced for chat context)
      const insights = await this.analyzeLikeBrain(data.content, data.is_incoming, 'chat', {
        isGroupChat: data.is_group_chat,
        participants: data.participants
      });
      
      // Create enhanced ChatMessage node with chat-specific brain properties and time tracking
      const result = await session.run(`
        // Create ChatMessage node with brain-like properties and time tracking
        CREATE (msg:ChatMessage {
          id: $id,
          content: $content,
          timestamp: datetime($timestamp),
          last_modified: datetime($timestamp),
          modification_reason: 'created',
          channel: $channel,
          source_identifier: $source_identifier,
          intent: $intent,
          sentiment: $sentiment,
          importance_score: $importance_score,
          chat_metadata: $chat_metadata,
          google_service_context: $google_service_context
        })
        
        // Link to User via existing OWNS relationship
        WITH msg
        MATCH (user:User {id: $user_id})
        CREATE (user)-[:OWNS]->(msg)
        
        // Create episodic Memory node with real-time context
        CREATE (memory:Memory {
          id: $memory_id,
          timestamp: datetime($timestamp),
          memory_type: 'episodic',
          consolidation_status: 'fresh',
          episode_type: 'conversation',
          channel: $channel,
          original_message_id: $id,
          importance_score: $importance_score,
          real_time_context: true
        })
        
        CREATE (msg)-[:HAS_MEMORY]->(memory)
        
        RETURN msg, memory
      `, {
        id: messageId,
        content: data.content,
        timestamp: new Date().toISOString(),
        channel: 'chat',
        source_identifier: data.chat_id,
        intent: insights.intent,
        sentiment: insights.sentiment,
        importance_score: insights.importance_score,
        chat_metadata: JSON.stringify({
          chat_id: data.chat_id,
          websocket_session_id: data.websocket_session_id,
          is_group_chat: data.is_group_chat || false,
          participants: data.participants || [],
          thread_id: data.thread_id,
          reply_to_message_id: data.reply_to_message_id,
          message_sequence: data.message_sequence
        }),
        google_service_context: data.google_service_context ? JSON.stringify(data.google_service_context) : null,
        user_id: data.user_id,
        memory_id: uuidv4()
      });

      // Same brain-like processing as SMS
      await this.extractAndLinkConcepts(session, messageId, data.content, data.user_id);
      await this.createSemanticTags(session, messageId, data.content, data.user_id, 'chat');
      await this.createAssociativeLinks(session, messageId, data.user_id, 'chat');
      
      if (data.google_service_context) {
        await this.linkToGoogleServices(session, messageId, data.google_service_context);
      }
      
      // Chat-specific: Link to other participants if group chat
      if (data.is_group_chat && data.participants?.length) {
        await this.linkGroupChatParticipants(session, messageId, data.participants);
      }
      
      console.log(`[BrainMemory] ‚úÖ Stored chat conversation with brain-like processing: ${messageId}`);
      
      // Return enhanced ChatMessage data
      return EnhancedChatMessageSchema.parse({
        id: messageId,
        content: data.content,
        timestamp: new Date().toISOString(),
        channel: 'chat',
        source_identifier: data.chat_id,
        intent: insights.intent,
        sentiment: insights.sentiment,
        importance_score: insights.importance_score,
        chat_metadata: {
          chat_id: data.chat_id,
          websocket_session_id: data.websocket_session_id,
          is_group_chat: data.is_group_chat || false,
          participants: data.participants || []
        },
        google_service_context: data.google_service_context
      });
      
    } finally {
      await session.close();
    }
  }
        processing_status: 'processed',
        ai_summary: insights.summary,
        metadata: {
          is_incoming: data.is_incoming,
          chat_id: data.chat_id,
          websocket_session_id: data.websocket_session_id,
          character_count: data.content.length,
          channel: 'chat',
          is_group_chat: data.is_group_chat,
          participants_count: data.participants?.length || 1
        },
        priority: insights.priority,
        requires_response: data.is_incoming && insights.requiresResponse,
        google_service_context: data.google_service_context,
        chat_context: {
          chat_id: data.chat_id,
          is_group_chat: data.is_group_chat || false,
          participants: data.participants || [],
          websocket_session_id: data.websocket_session_id,
          message_sequence: data.message_sequence,
          reply_to_message_id: data.reply_to_message_id
        },
        channel_context: {
          primary_channel: 'chat',
          related_channels: [],
          user_preference: 'chat'
        }
      });

      const session = this.driver.session();
      const tx = session.beginTransaction();

      try {
        // Store conversation node
        await this.createConversationNode(tx, conversationData);
        
        // Extract and create semantic tags optimized for chat
        const tags = await this.extractSemanticTags(data.content, data.user_id, {
          conversationId,
          channel: 'chat',
          isIncoming: data.is_incoming,
          chatId: data.chat_id,
          isGroupChat: data.is_group_chat,
          participants: data.participants
        });
        
        await this.linkConversationToTags(tx, conversationId, tags);
        
        // Establish chat threading with real-time context
        await this.establishChatThreading(tx, conversationData, data.chat_id, data.thread_id);
        
        // Update user chat patterns and preferences
        await this.updateChannelPatterns(tx, data.user_id, conversationData, 'chat');
        
        // Link to Google services if relevant
        if (data.google_service_context) {
          await this.linkToGoogleServices(tx, conversationId, data.google_service_context);
        }
        
        // Link to related SMS conversations if any
        await this.linkCrossChannelConversations(tx, conversationId, data.user_id, 'chat');
        
        // Handle group chat participant relationships
        if (data.is_group_chat && data.participants?.length) {
          await this.linkGroupChatParticipants(tx, conversationId, data.participants);
        }
        
        await tx.commit();
        
        // Update cache for fast retrieval
        await this.updateConversationCache(conversationData);
        
        console.log(`[ConversationManager] ‚úÖ Stored chat conversation: ${conversationId}`);
        return conversationData;

      } catch (error) {
        await tx.rollback();
        throw error;
      } finally {
        await session.close();
      }
    } catch (error) {
      console.error(`[ConversationManager] ‚ùå Failed to store chat conversation:`, error);
      throw error;
    }
  }

  /**
   * Retrieve brain-like memory context for SMS (mimics human memory retrieval)
   * Uses existing ChatMessage nodes with working memory + episodic + semantic patterns
   */
  async getBrainMemoryContext(
    userId: string,
    currentMessage: string,
    channel: 'sms' | 'chat',
    sourceIdentifier: string, // phone number or chat ID
    options: {
      workingMemorySize?: number;
      episodicWindowHours?: number;
      semanticActivationThreshold?: number;
      includeGoogleServices?: boolean;
    } = {}
  ): Promise<BrainMemoryContext> {
    const {
      workingMemorySize = this.WORKING_MEMORY_SIZE,
      episodicWindowHours = this.EPISODIC_MEMORY_WINDOW_HOURS,
      semanticActivationThreshold = this.SEMANTIC_ACTIVATION_THRESHOLD,
      includeGoogleServices = true
    } = options;

    const cacheKey = `brain_memory_context:${userId}:${channel}:${sourceIdentifier}:${JSON.stringify(options)}`;
    
    // Check cache first (shorter TTL for brain-like responsiveness)
    const cached = await redisCache.get(cacheKey);
    if (cached) {
      console.log(`[BrainMemory] üß† Cache hit for ${channel}:${sourceIdentifier}`);
      return BrainMemoryContextSchema.parse(cached);
    }

    console.log(`[BrainMemory] üß† Building brain-like memory context for ${channel}:${sourceIdentifier}`);
    
    // Extract relevant topics from current message (for semantic activation)
    const currentTopics = await this.extractQuickTopics(currentMessage);
    
    const session = this.driver.session();
    
    try {
      // Step 1: Time-Based Working Memory - 3-week window (previous + current + next week)
      const timeBasedWorkingMemoryResult = await session.run(`
        // Calculate week boundaries
        WITH datetime() as now,
             datetime() - duration({days: 7}) as previousWeekStart,
             datetime() as currentWeekEnd,
             datetime() + duration({days: 7}) as nextWeekEnd
        
        MATCH (user:User {id: $userId})-[:OWNS]->(msg:ChatMessage)
        WHERE msg.channel = $channel 
        AND msg.source_identifier = $sourceIdentifier
        AND msg.timestamp >= datetime() - duration({days: $timeWindowDays})
        AND msg.timestamp <= datetime() + duration({days: 7}) // Include next week
        
        // Categorize by week
        WITH msg, now, previousWeekStart, currentWeekEnd, nextWeekEnd,
             CASE 
               WHEN msg.timestamp < previousWeekStart THEN 'previous'
               WHEN msg.timestamp >= previousWeekStart AND msg.timestamp < now THEN 'current'
               WHEN msg.timestamp >= now AND msg.timestamp <= nextWeekEnd THEN 'next'
               ELSE 'other'
             END as weekCategory
        
        RETURN msg, weekCategory
        ORDER BY msg.timestamp DESC
      `, { userId, channel, sourceIdentifier, timeWindowDays: this.WORKING_MEMORY_TIME_WINDOW_DAYS });

      // Step 2: Recently Modified Nodes (pull back into working memory)
      const recentlyModifiedResult = await session.run(`
        MATCH (user:User {id: $userId})-[:OWNS]->(msg:ChatMessage)
        WHERE msg.channel = $channel 
        AND msg.source_identifier = $sourceIdentifier
        AND (
          msg.last_modified > datetime() - duration({hours: $recentModificationHours}) OR
          msg.timestamp > datetime() - duration({hours: $recentModificationHours}) OR
          EXISTS((msg)-[:HAS_MEMORY]->(memory:Memory) WHERE memory.timestamp > datetime() - duration({hours: $recentModificationHours})) OR
          EXISTS((msg)-[:MENTIONS]->(concept:Concept) WHERE concept.last_mentioned > datetime() - duration({hours: $recentModificationHours})) OR
          EXISTS((msg)-[:HAS_TAG]->(tag:Tag) WHERE tag.last_used > datetime() - duration({hours: $recentModificationHours}))
        )
        
        RETURN msg, 'recently_modified' as category
        ORDER BY COALESCE(msg.last_modified, msg.timestamp) DESC
        LIMIT 10
      `, { 
        userId, 
        channel, 
        sourceIdentifier, 
        recentModificationHours: this.RECENT_MODIFICATION_HOURS 
      });

      // Step 3: Most Recent Messages (traditional working memory)
      const recentMessagesResult = await session.run(`
        MATCH (user:User {id: $userId})-[:OWNS]->(msg:ChatMessage)
        WHERE msg.channel = $channel 
        AND msg.source_identifier = $sourceIdentifier
        AND msg.timestamp > datetime() - duration({hours: 2}) // Last 2 hours for immediate context
        RETURN msg, 'recent' as category
        ORDER BY msg.timestamp DESC
        LIMIT $workingMemorySize
      `, { userId, channel, sourceIdentifier, workingMemorySize });

      // Step 2: Episodic Memory - Related conversation threads via existing Memory nodes
      const episodicMemoryResult = await session.run(`
        MATCH (user:User {id: $userId})-[:OWNS]->(msg:ChatMessage)-[:HAS_MEMORY]->(memory:Memory)
        WHERE msg.timestamp > datetime() - duration({hours: $episodicWindowHours})
        AND (msg.channel = $channel OR memory.memory_type = 'cross_channel')
        
        // Get related conversations through semantic links (existing RELATED_TO relationships)
        OPTIONAL MATCH (msg)-[:RELATED_TO]-(relatedMsg:ChatMessage)
        WHERE relatedMsg.timestamp > datetime() - duration({hours: $episodicWindowHours})
        
        WITH msg, memory, collect(DISTINCT relatedMsg) as relatedMessages
        RETURN msg, memory, relatedMessages
        ORDER BY msg.timestamp DESC
        LIMIT 10
      `, { userId, channel, episodicWindowHours });

      // Step 3: Semantic Memory - Concept activation via existing Concept nodes
      const semanticMemoryResult = await session.run(`
        // Find concepts mentioned in current message (enhanced with existing MENTIONS relationships)
        MATCH (user:User {id: $userId})-[:OWNS]->(msg:ChatMessage)-[:MENTIONS]->(concept:Concept)
        WHERE msg.timestamp > datetime() - duration({hours: $episodicWindowHours})
        
        // Get related concepts through existing RELATED_TO relationships
        OPTIONAL MATCH (concept)-[:RELATED_TO]-(relatedConcept:Concept)
        WHERE relatedConcept.user_id = $userId
        
        WITH concept, collect(DISTINCT relatedConcept) as relatedConcepts,
             count(msg) as conceptFrequency
        WHERE conceptFrequency >= 2 // Only concepts mentioned multiple times
        
        RETURN concept, relatedConcepts, conceptFrequency
        ORDER BY conceptFrequency DESC
        LIMIT 20
      `, { userId, episodicWindowHours });

      // Process results into time-based working memory structure
      const timeWindowMessages = timeBasedWorkingMemoryResult.records.map(record => {
        const msg = record.get('msg').properties;
        const weekCategory = record.get('weekCategory');
        return {
          message: this.nodeToEnhancedChatMessage(msg),
          weekCategory: weekCategory
        };
      });

      const recentlyModifiedMessages = recentlyModifiedResult.records.map(record => {
        const msg = record.get('msg').properties;
        return this.nodeToEnhancedChatMessage(msg);
      });

      const recentMessages = recentMessagesResult.records.map(record => {
        const msg = record.get('msg').properties;
        return this.nodeToEnhancedChatMessage(msg);
      });

      // Calculate time window statistics
      const timeWindowStats = {
        previous_week_count: timeWindowMessages.filter(item => item.weekCategory === 'previous').length,
        current_week_count: timeWindowMessages.filter(item => item.weekCategory === 'current').length,
        next_week_count: timeWindowMessages.filter(item => item.weekCategory === 'next').length,
        recently_modified_count: recentlyModifiedMessages.length
      };

      console.log(`[BrainMemory] üìÖ Time-based working memory: Previous(${timeWindowStats.previous_week_count}) Current(${timeWindowStats.current_week_count}) Next(${timeWindowStats.next_week_count}) Modified(${timeWindowStats.recently_modified_count})`);

      // Organize working memory with time-based structure
      const workingMemory = {
        recent_messages: recentMessages,
        time_window_messages: timeWindowMessages.map(item => item.message),
        recently_modified_messages: recentlyModifiedMessages,
        active_concepts: semanticMemory.slice(0, 5).map(s => s.concept_id),
        current_intent: await this.inferCurrentIntent(currentMessage),
        time_window_stats: timeWindowStats
      };

      const episodicMemory = episodicMemoryResult.records.map(record => {
        const msg = record.get('msg').properties;
        const memory = record.get('memory').properties;
        const relatedMessages = record.get('relatedMessages') || [];
        
        return {
          thread_id: memory.id,
          messages: [this.nodeToEnhancedChatMessage(msg)],
          semantic_weight: this.calculateSemanticWeight(msg, relatedMessages),
          memory_node_id: memory.id
        };
      });

      const semanticMemory = semanticMemoryResult.records.map(record => {
        const concept = record.get('concept').properties;
        const relatedConcepts = record.get('relatedConcepts') || [];
        const frequency = record.get('conceptFrequency').toNumber();
        
        return {
          concept: this.nodeToEnhancedConcept(concept),
          activation_strength: Math.min(frequency / 10, 1.0), // Normalize frequency
          related_concepts: relatedConcepts.map((c: any) => c.properties.id)
        };
      });

      // Calculate overall memory strength (brain-like consolidation)
      const memoryStrength = this.calculateMemoryStrength(
        workingMemory.length,
        episodicMemory.length,
        semanticMemory.length
      );

      // Build brain-like memory context
      const brainContext: BrainMemoryContext = BrainMemoryContextSchema.parse({
        working_memory: {
          recent_messages: workingMemory,
          active_concepts: semanticMemory.slice(0, 5).map(s => s.concept.id),
          current_intent: await this.inferCurrentIntent(currentMessage)
        },
        episodic_memory: {
          conversation_threads: episodicMemory,
          related_episodes: episodicMemory.map(e => e.thread_id)
        },
        semantic_memory: {
          activated_concepts: semanticMemory,
          concept_associations: await this.getConceptAssociations(session, userId, semanticMemory.map(s => s.concept.id))
        },
        consolidation_metadata: {
          retrieval_timestamp: new Date().toISOString(),
          memory_strength: memoryStrength,
          context_channels: [channel],
          memory_age_hours: episodicWindowHours,
          consolidation_score: this.calculateConsolidationScore(episodicMemory, semanticMemory),
          working_memory_limit: workingMemorySize,
          episodic_window_hours: episodicWindowHours,
          semantic_activation_threshold: semanticActivationThreshold,
          sms_optimization: channel === 'sms' ? {
            character_budget: 1500,
            suggested_response_length: workingMemory.length > 3 ? 'brief' : 'normal'
          } : undefined,
          chat_optimization: channel === 'chat' ? {
            max_message_length: 4000,
            supports_rich_content: true,
            real_time_context: true,
            thread_aware: true
          } : undefined
        }
      });

      // Cache with brain-appropriate TTL
      await redisCache.setex(cacheKey, this.CACHE_TTL, JSON.stringify(brainContext));

             console.log(`[BrainMemory] ‚úÖ Built brain-like memory context: ${workingMemory.length} working + ${episodicMemory.length} episodic + ${semanticMemory.length} semantic, strength: ${memoryStrength.toFixed(2)}`);
       return brainContext;
      
    } finally {
      await session.close();
    }
  }

  // ============================================================================
  // COMPOSIO + MEMORY INTEGRATION METHODS
  // ============================================================================

  /**
   * NEW: Memory-Enhanced Composio Tool Execution
   * Integrates brain-like memory context with Composio operations
   */
  async executeComposioToolWithMemory(
    userId: string,
    toolCall: any,
    composio: any, // OpenAIToolSet from composio-core
    brainMemoryContext: BrainMemoryContext,
    channel: 'sms' | 'chat',
    sourceIdentifier: string
  ): Promise<{
    success: boolean;
    result: any;
    memoryEnhanced: boolean;
    memoryInsights?: string[];
  }> {
    console.log(`[BrainMemory] üß†üîß Executing Composio tool with memory context: ${toolCall.function.name}`);
    
    try {
      // Step 1: Enhance tool parameters with memory context
      const enhancedParams = await this.enhanceToolParamsWithMemory(
        toolCall,
        brainMemoryContext,
        userId
      );

      // Step 2: Execute the Composio tool with enhanced parameters
      const toolResult = await composio.client.actions.execute({
        actionName: toolCall.function.name,
        requestBody: {
          input: enhancedParams,
          appName: this.getAppNameForTool(toolCall.function.name),
          authConfig: await this.getCustomAuthConfig(userId) // Uses existing Supabase OAuth
        }
      });

      // Step 3: Store the tool execution result in brain memory
      await this.storeComposioResultInMemory(
          userId, 
        toolCall,
        toolResult,
        channel,
        sourceIdentifier,
        brainMemoryContext
      );

      // Step 4: Update semantic concepts based on tool usage
      await this.updateSemanticConceptsFromTool(
        userId,
        toolCall,
        toolResult
      );

      return {
        success: true,
        result: toolResult,
        memoryEnhanced: true,
        memoryInsights: this.generateMemoryInsights(brainMemoryContext, toolCall)
      };

    } catch (error) {
      console.error(`[BrainMemory] ‚ùå Memory-enhanced Composio execution failed:`, error);
      
      // Fallback to standard execution without memory enhancement
      try {
        const standardResult = await composio.client.actions.execute({
          actionName: toolCall.function.name,
          requestBody: {
            input: JSON.parse(toolCall.function.arguments),
            appName: this.getAppNameForTool(toolCall.function.name),
            authConfig: await this.getCustomAuthConfig(userId)
          }
        });

        return {
          success: true,
          result: standardResult,
          memoryEnhanced: false
        };
      } catch (fallbackError) {
        return {
          success: false,
          result: null,
          memoryEnhanced: false
        };
      }
    }
  }

  /**
   * Enhance Composio tool parameters with brain-like memory insights
   */
  private async enhanceToolParamsWithMemory(
    toolCall: any,
    brainMemoryContext: BrainMemoryContext,
    userId: string
  ): Promise<any> {
    const originalParams = JSON.parse(toolCall.function.arguments);
    const toolName = toolCall.function.name.toLowerCase();
    
    console.log(`[BrainMemory] üß† Enhancing ${toolName} with memory context`);

    // Calendar tool enhancements
    if (toolName.includes('calendar')) {
      return await this.enhanceCalendarToolWithMemory(originalParams, brainMemoryContext);
    }
    
    // Tasks tool enhancements  
    if (toolName.includes('task')) {
      return await this.enhanceTasksToolWithMemory(originalParams, brainMemoryContext);
    }
    
    // Email tool enhancements
    if (toolName.includes('gmail') || toolName.includes('email')) {
      return await this.enhanceEmailToolWithMemory(originalParams, brainMemoryContext);
    }
    
    // Contacts tool enhancements
    if (toolName.includes('contact')) {
      return await this.enhanceContactsToolWithMemory(originalParams, brainMemoryContext);
    }

    return originalParams; // No enhancement for unknown tools
  }

  /**
   * Enhance calendar operations with episodic and semantic memory
   */
  private async enhanceCalendarToolWithMemory(
    params: any,
    brainMemoryContext: BrainMemoryContext
  ): Promise<any> {
    const enhanced = { ...params };

    // For list events: Use memory to determine optimal time range
    if (!enhanced.timeMin || !enhanced.timeMax) {
      const recentCalendarMentions = brainMemoryContext.working_memory.recent_messages
        .filter(msg => msg.intent?.includes('calendar') || msg.content.toLowerCase().includes('meeting'))
        .slice(0, 3);

      if (recentCalendarMentions.length > 0) {
        console.log(`[BrainMemory] üìÖ Found ${recentCalendarMentions.length} recent calendar-related conversations`);
        
        // Smart time range based on conversation context
        const now = new Date();
        enhanced.timeMin = enhanced.timeMin || now.toISOString();
        enhanced.timeMax = enhanced.timeMax || new Date(now.getTime() + 7 * 24 * 60 * 60 * 1000).toISOString();
      }
    }

    // For create events: Use semantic memory for smart defaults
    if (enhanced.summary) {
      const relatedConcepts = brainMemoryContext.semantic_memory.activated_concepts
        .filter(concept => concept.activation_strength > 0.5)
        .map(concept => concept.concept.name);

      if (relatedConcepts.length > 0) {
        console.log(`[BrainMemory] üß† Enhancing event with related concepts: ${relatedConcepts.join(', ')}`);
        enhanced.description = enhanced.description || `Related to: ${relatedConcepts.join(', ')}`;
      }
    }

    return enhanced;
  }

  /**
   * Enhance task operations with memory patterns
   */
  private async enhanceTasksToolWithMemory(
    params: any,
    brainMemoryContext: BrainMemoryContext
  ): Promise<any> {
    const enhanced = { ...params };

    // Use episodic memory to find related tasks
    const taskRelatedMessages = brainMemoryContext.episodic_memory.conversation_threads
      .flatMap(thread => thread.messages)
      .filter(msg => 
        msg.intent?.includes('task') || 
        msg.content.toLowerCase().includes('todo') ||
        msg.content.toLowerCase().includes('remind')
      );

    if (taskRelatedMessages.length > 0 && enhanced.title) {
      console.log(`[BrainMemory] ‚úÖ Found ${taskRelatedMessages.length} related task conversations`);
      
      // Extract common task patterns from memory
      const taskPatterns = taskRelatedMessages
        .map(msg => this.extractTaskPattern(msg.content))
        .filter(pattern => pattern);

      if (taskPatterns.length > 0) {
        enhanced.notes = enhanced.notes || `Based on previous tasks: ${taskPatterns[0]}`;
      }
    }

    return enhanced;
  }

  /**
   * Enhance email operations with contact memory
   */
  private async enhanceEmailToolWithMemory(
    params: any,
    brainMemoryContext: BrainMemoryContext
  ): Promise<any> {
    const enhanced = { ...params };

    // Use semantic memory to enhance email recipients/content
    if (enhanced.to || enhanced.subject) {
      const emailConcepts = brainMemoryContext.semantic_memory.activated_concepts
        .filter(concept => 
          concept.concept.name.includes('@') || // Email addresses
          concept.activation_strength > 0.6
        );

      if (emailConcepts.length > 0) {
        console.log(`[BrainMemory] üìß Found relevant email concepts from memory`);
        
        // Could enhance recipient suggestions, subject lines, etc.
        if (!enhanced.body && emailConcepts.length > 0) {
          const contextualInfo = emailConcepts.map(c => c.concept.name).join(', ');
          enhanced.body = enhanced.body || `[Context from memory: ${contextualInfo}]\n\n${enhanced.body || ''}`;
        }
      }
    }

    return enhanced;
  }

  /**
   * Enhance contact operations with relationship memory
   */
  private async enhanceContactsToolWithMemory(
    params: any,
    brainMemoryContext: BrainMemoryContext
  ): Promise<any> {
    const enhanced = { ...params };

    // Use episodic memory to find contact-related conversations
    const contactMessages = brainMemoryContext.working_memory.recent_messages
      .filter(msg => 
        msg.content.toLowerCase().includes('contact') ||
        msg.content.toLowerCase().includes('phone') ||
        msg.content.includes('@')
      );

    if (contactMessages.length > 0) {
      console.log(`[BrainMemory] üë• Found ${contactMessages.length} contact-related recent conversations`);
      // Could enhance search queries, contact suggestions, etc.
    }

    return enhanced;
  }

  /**
   * Store Composio tool execution results in brain memory
   */
  private async storeComposioResultInMemory(
    userId: string,
    toolCall: any,
    toolResult: any,
    channel: 'sms' | 'chat',
    sourceIdentifier: string,
    brainMemoryContext: BrainMemoryContext
  ): Promise<void> {
    const session = this.driver.session();
    
    try {
      const messageId = uuidv4();
      const toolName = toolCall.function.name;
      const success = !toolResult.error;

      // Create a ChatMessage node representing the tool execution
      await session.run(`
        CREATE (msg:ChatMessage {
          id: $id,
          content: $content,
          timestamp: datetime($timestamp),
          channel: $channel,
          source_identifier: $sourceIdentifier,
          intent: 'tool_execution',
          sentiment: 0,
          importance_score: $importance_score,
          tool_metadata: $tool_metadata
        })
        
        // Link to User
        WITH msg
        MATCH (user:User {id: $userId})
        CREATE (user)-[:OWNS]->(msg)
        
        // Create Memory node for this tool execution
        CREATE (memory:Memory {
          id: $memory_id,
          timestamp: datetime($timestamp),
          memory_type: 'procedural',
          consolidation_status: 'fresh',
          episode_type: 'tool_execution',
          channel: $channel,
          original_message_id: $id,
          importance_score: $importance_score,
          tool_name: $toolName,
          tool_success: $success
        })
        
        CREATE (msg)-[:HAS_MEMORY]->(memory)
      `, {
        id: messageId,
        content: `Executed ${toolName}: ${success ? 'Success' : 'Failed'}`,
        timestamp: new Date().toISOString(),
        channel,
        sourceIdentifier,
        importance_score: success ? 0.8 : 0.6, // Success is more important
        tool_metadata: JSON.stringify({
          tool_name: toolName,
          tool_params: toolCall.function.arguments,
          tool_result: success ? 'success' : 'failed',
          result_summary: this.summarizeToolResult(toolResult),
          memory_enhanced: true
        }),
        userId,
        memory_id: uuidv4(),
        toolName,
        success
      });

      // Link to relevant concepts based on tool type
      await this.linkToolExecutionToConcepts(session, messageId, toolCall, userId);

      console.log(`[BrainMemory] üß†üíæ Stored tool execution in memory: ${toolName}`);
      
    } finally {
      await session.close();
    }
  }

  /**
   * Update semantic concepts based on tool usage patterns
   */
  private async updateSemanticConceptsFromTool(
    userId: string,
    toolCall: any,
    toolResult: any
  ): Promise<void> {
    const session = this.driver.session();
    
    try {
      const toolName = toolCall.function.name.toLowerCase();
      let conceptName = '';
      
      // Determine concept based on tool type
      if (toolName.includes('calendar')) conceptName = 'calendar_usage';
      else if (toolName.includes('task')) conceptName = 'task_management';
      else if (toolName.includes('email') || toolName.includes('gmail')) conceptName = 'email_communication';
      else if (toolName.includes('contact')) conceptName = 'contact_management';
      else conceptName = 'tool_usage';

      // Update or create concept with usage frequency
      await session.run(`
        MERGE (concept:Concept {name: $conceptName, user_id: $userId})
        SET concept.activation_strength = COALESCE(concept.activation_strength, 0) + 0.1,
            concept.mention_count = COALESCE(concept.mention_count, 0) + 1,
            concept.last_mentioned = datetime(),
            concept.semantic_weight = COALESCE(concept.semantic_weight, 0.5) + 0.05
      `, { conceptName, userId });

             console.log(`[BrainMemory] üß†üìà Updated semantic concept: ${conceptName}`);

    } finally {
      await session.close();
    }
   }

  // ============================================================================
  // BRAIN-LIKE HELPER METHODS
  // ============================================================================

  /**
   * Analyze content like brain's initial processing (hippocampus-like)
   */
  private async analyzeLikeBrain(
    content: string, 
    isIncoming: boolean, 
    channel: 'sms' | 'chat',
    context?: {
      isGroupChat?: boolean;
      participants?: string[];
    }
  ): Promise<{
    intent: string;
    sentiment: number;
    importance_score: number;
  }> {
    try {
      const response = await this.openai.chat.completions.create({
        model: 'gpt-4o-mini',
        messages: [{
          role: 'user',
          content: `Analyze this ${channel} message like a brain would process it:
"${content}"

Direction: ${isIncoming ? 'Incoming' : 'Outgoing'}
Channel: ${channel}
${context?.isGroupChat ? `Group chat with ${context.participants?.length || 0} participants` : 'Individual conversation'}

Return JSON with:
- intent: main intent/purpose (question, request, info, social, task, calendar, email, contact, etc.)
- sentiment: number -1 to 1 (emotional valence)
- importance_score: 0 to 1 (how important/memorable this is)

Consider:
- Emotional significance
- Actionability 
- Information density
- Social context
- Urgency indicators
- Tool/service requests`
        }],
        response_format: { type: 'json_object' },
        max_tokens: 200
      });

      const analysis = JSON.parse(response.choices[0].message.content || '{}');
      
      return {
        intent: analysis.intent || 'unknown',
        sentiment: analysis.sentiment || 0,
        importance_score: analysis.importance_score || (isIncoming ? 0.6 : 0.4)
      };
    } catch (error) {
      console.warn(`[BrainMemory] AI analysis failed, using defaults:`, error);
      return {
        intent: 'unknown',
        sentiment: 0,
        importance_score: isIncoming ? 0.6 : 0.4
      };
    }
  }

  /**
   * Extract and link to existing Concept nodes (semantic memory)
   */
  private async extractAndLinkConcepts(
    session: any,
    messageId: string,
    content: string,
    userId: string
  ): Promise<void> {
    const concepts = await this.extractKeyConceptsFromContent(content);
    
    for (const conceptText of concepts) {
      await session.run(`
        // Find or create Concept node
        MERGE (concept:Concept {name: $conceptText, user_id: $userId})
        ON CREATE SET concept.activation_strength = 0.5,
                      concept.mention_count = 1,
                      concept.last_mentioned = datetime(),
                      concept.semantic_weight = 0.5
        ON MATCH SET concept.last_mentioned = datetime(),
                     concept.mention_count = COALESCE(concept.mention_count, 0) + 1,
                     concept.activation_strength = COALESCE(concept.activation_strength, 0) + 0.1
        
        // Link message to concept via MENTIONS relationship
        WITH concept
        MATCH (msg:ChatMessage {id: $messageId})
        MERGE (msg)-[:MENTIONS]->(concept)
        
        // Update last_modified to pull message back into working memory when concepts change
        SET msg.last_modified = datetime(),
            msg.modification_reason = 'concept_linked'
      `, { conceptText, userId, messageId });
    }
  }

  /**
   * Create/update existing Tag nodes (categorization)
   */
  private async createSemanticTags(
    session: any,
    messageId: string,
    content: string,
    userId: string,
    channel: string
  ): Promise<void> {
    const tags = await this.generateSemanticTags(content, channel);
    
    for (const tagName of tags) {
      await session.run(`
        // Find or create Tag node
        MERGE (tag:Tag {name: $tagName, user_id: $userId})
        ON CREATE SET tag.usage_count = 1,
                      tag.last_used = datetime(),
                      tag.channel_origin = $channel,
                      tag.category = 'auto_generated'
        ON MATCH SET tag.last_used = datetime(),
                     tag.usage_count = COALESCE(tag.usage_count, 0) + 1
        
        // Link message to tag via HAS_TAG relationship
        WITH tag
        MATCH (msg:ChatMessage {id: $messageId})
        MERGE (msg)-[:HAS_TAG]->(tag)
        
        // Update last_modified to pull message back into working memory when tags change
        SET msg.last_modified = datetime(),
            msg.modification_reason = 'tag_added'
      `, { tagName, userId, messageId, channel });
    }
  }

  /**
   * Create associative links between related conversations (RELATED_TO relationships)
   * Also updates last_modified to pull related messages back into working memory
   */
  private async createAssociativeLinks(
    session: any,
    messageId: string,
    userId: string,
    channel: string
  ): Promise<void> {
    // Find related messages through shared concepts/tags
    await session.run(`
      MATCH (newMsg:ChatMessage {id: $messageId})-[:MENTIONS|:HAS_TAG]->(shared)
      <-[:MENTIONS|:HAS_TAG]-(relatedMsg:ChatMessage)
      WHERE relatedMsg.timestamp > datetime() - duration({days: 7})
      AND relatedMsg.id <> $messageId
      AND EXISTS((user:User {id: $userId})-[:OWNS]->(relatedMsg))
      
      // Create or strengthen associative link
      MERGE (newMsg)-[rel:RELATED_TO]-(relatedMsg)
      ON CREATE SET rel.strength = 0.3,
                    rel.last_activated = datetime(),
                    rel.association_type = 'semantic',
                    rel.activation_count = 1
      ON MATCH SET rel.strength = COALESCE(rel.strength, 0) + 0.1,
                   rel.last_activated = datetime(),
                   rel.activation_count = COALESCE(rel.activation_count, 0) + 1
      
      // Update last_modified on related messages to pull them into working memory
      WITH relatedMsg
      SET relatedMsg.last_modified = datetime(),
          relatedMsg.modification_reason = 'associative_link_created'
    `, { messageId, userId });
  }

  /**
   * Update node modification timestamp to pull it back into working memory
   */
  private async updateNodeModification(
    session: any,
    nodeId: string,
    reason: string
  ): Promise<void> {
    await session.run(`
      MATCH (msg:ChatMessage {id: $nodeId})
      SET msg.last_modified = datetime(),
          msg.modification_reason = $reason
    `, { nodeId, reason });
  }

  /**
   * Link to Google services via existing relationships
   */
  private async linkToGoogleServices(
    session: any,
    messageId: string,
    serviceContext: any
  ): Promise<void> {
    if (!serviceContext.service_type) return;
    
    await session.run(`
      MATCH (msg:ChatMessage {id: $messageId})
      MATCH (token:OAuthToken)
      WHERE token.service = $serviceType OR token.provider = 'google'
      
      // Create service relationship
      MERGE (msg)-[rel:TRIGGERED_SERVICE]->(token)
      ON CREATE SET rel.operation = $operation,
                    rel.success = $success,
                    rel.timestamp = datetime()
      ON MATCH SET rel.operation = $operation,
                   rel.success = $success,
                   rel.last_used = datetime()
    `, {
      messageId,
      serviceType: serviceContext.service_type,
      operation: serviceContext.operation || 'unknown',
      success: serviceContext.success !== false
    });
  }

  /**
   * Link group chat participants
   */
  private async linkGroupChatParticipants(
    session: any,
    messageId: string,
    participants: string[]
  ): Promise<void> {
    for (const participant of participants) {
      await session.run(`
        MATCH (msg:ChatMessage {id: $messageId})
        MERGE (participant:User {id: $participant})
        MERGE (msg)-[:INCLUDES_PARTICIPANT]->(participant)
      `, { messageId, participant });
    }
  }

  /**
   * Helper method implementations
   */
  private async extractKeyConceptsFromContent(content: string): Promise<string[]> {
    // Enhanced concept extraction with AI
    try {
      const response = await this.openai.chat.completions.create({
        model: 'gpt-4o-mini',
        messages: [{
          role: 'user',
          content: `Extract 3-5 key concepts from this message: "${content}"
          
Return as JSON array of strings. Focus on:
- Important nouns and entities
- Action words  
- Topics/subjects
- Services mentioned (calendar, email, tasks, contacts)

Example: ["meeting", "calendar", "work", "schedule"]`
        }],
        response_format: { type: 'json_object' },
        max_tokens: 100
      });

      const result = JSON.parse(response.choices[0].message.content || '{}');
      return result.concepts || this.extractKeyConceptsBasic(content);
    } catch (error) {
      return this.extractKeyConceptsBasic(content);
    }
  }

  private extractKeyConceptsBasic(content: string): string[] {
    // Fallback basic concept extraction
    const words = content.toLowerCase()
      .split(/\s+/)
      .filter(word => word.length > 3)
      .filter(word => !['this', 'that', 'with', 'have', 'been', 'they', 'them', 'will', 'from', 'your', 'what', 'when', 'where'].includes(word))
      .slice(0, 5);
    
    return words;
  }

  private async generateSemanticTags(content: string, channel: string): Promise<string[]> {
    const tags = [];
    const lower = content.toLowerCase();
    
    // Service-based tags
    if (lower.includes('meeting') || lower.includes('schedule') || lower.includes('calendar')) {
      tags.push('calendar');
    }
    if (lower.includes('task') || lower.includes('todo') || lower.includes('remind')) {
      tags.push('task_management');
    }
    if (lower.includes('email') || lower.includes('send') || lower.includes('gmail')) {
      tags.push('email');
    }
    if (lower.includes('contact') || lower.includes('phone') || lower.includes('@')) {
      tags.push('contact');
    }
    
    // Channel and time-based tags
    tags.push(channel);
    tags.push(`${channel}_${new Date().getHours() < 12 ? 'morning' : 'afternoon'}`);
    
    // Intent-based tags
    if (lower.includes('?')) tags.push('question');
    if (lower.includes('urgent') || lower.includes('asap')) tags.push('urgent');
    
    return tags;
  }

  private calculateSemanticWeight(msg: any, relatedMessages: any[]): number {
    const baseWeight = msg.importance_score || 0.5;
    const relationshipBonus = Math.min(relatedMessages.length / 10, 0.3);
    const recencyBonus = this.calculateRecencyBonus(msg.timestamp);
    
    return Math.min(baseWeight + relationshipBonus + recencyBonus, 1.0);
  }

  private calculateRecencyBonus(timestamp: string): number {
    const messageDate = new Date(timestamp);
    const now = new Date();
    const hoursDiff = (now.getTime() - messageDate.getTime()) / (1000 * 60 * 60);
    
    return Math.exp(-hoursDiff / 24) * 0.2;
  }

  private calculateMemoryStrength(
    workingMemoryCount: number,
    episodicMemoryCount: number,
    semanticMemoryCount: number
  ): number {
    const workingWeight = Math.min(workingMemoryCount / this.WORKING_MEMORY_SIZE, 1.0) * 0.4;
    const episodicWeight = Math.min(episodicMemoryCount / 10, 1.0) * 0.4;
    const semanticWeight = Math.min(semanticMemoryCount / 20, 1.0) * 0.2;
    
    return workingWeight + episodicWeight + semanticWeight;
  }

  private calculateConsolidationScore(episodicMemory: any[], semanticMemory: any[]): number {
    const episodicConnections = episodicMemory.length;
    const semanticConnections = semanticMemory.reduce((sum, s) => sum + s.related_concepts.length, 0);
    
    return Math.min((episodicConnections + semanticConnections) / 50, 1.0);
  }

  private async inferCurrentIntent(message: string): Promise<string> {
    const msg = message.toLowerCase();
    
    if (msg.includes('?')) return 'question';
    if (msg.includes('schedule') || msg.includes('meeting') || msg.includes('calendar')) return 'calendar';
    if (msg.includes('send') || msg.includes('email') || msg.includes('gmail')) return 'email';
    if (msg.includes('task') || msg.includes('todo') || msg.includes('remind')) return 'task_management';
    if (msg.includes('find') || msg.includes('search') || msg.includes('contact')) return 'information_seeking';
    
    return 'general';
  }

  private async getConceptAssociations(session: any, userId: string, conceptIds: string[]): Promise<any[]> {
    if (conceptIds.length === 0) return [];
    
    const result = await session.run(`
      MATCH (c1:Concept)-[:RELATED_TO]-(c2:Concept)
      WHERE c1.id IN $conceptIds AND c2.id IN $conceptIds
      AND c1.user_id = $userId AND c2.user_id = $userId
      RETURN c1.id as from_concept, c2.id as to_concept, 
             COALESCE(c1.mention_count, 1) + COALESCE(c2.mention_count, 1) as strength
    `, { conceptIds, userId });

    return result.records.map(record => ({
      from_concept: record.get('from_concept'),
      to_concept: record.get('to_concept'),
      association_strength: Math.min(record.get('strength').toNumber() / 20, 1.0),
      relationship_type: 'RELATED_TO'
    }));
  }

  private nodeToEnhancedChatMessage(node: any): EnhancedChatMessage {
    const smsMetadata = node.sms_metadata ? JSON.parse(node.sms_metadata) : undefined;
    const chatMetadata = node.chat_metadata ? JSON.parse(node.chat_metadata) : undefined;
    const googleServiceContext = node.google_service_context ? JSON.parse(node.google_service_context) : undefined;
    
    return {
      id: node.id,
      content: node.content,
      timestamp: node.timestamp,
      channel: node.channel,
      source_identifier: node.source_identifier,
      intent: node.intent,
      sentiment: node.sentiment,
      importance_score: node.importance_score,
      sms_metadata: smsMetadata,
      chat_metadata: chatMetadata,
      google_service_context: googleServiceContext
    };
  }

  private nodeToEnhancedConcept(node: any): EnhancedConcept {
    return {
      id: node.id,
      name: node.name,
      activation_strength: node.activation_strength || 0,
      mention_count: node.mention_count || 0,
      last_mentioned: node.last_mentioned,
      semantic_weight: node.semantic_weight || 0.5,
      user_id: node.user_id
    };
  }

  // Composio integration helper methods
  private getAppNameForTool(toolName: string): string {
    const tool = toolName.toLowerCase();
    if (tool.includes('calendar')) return 'googlecalendar';
    if (tool.includes('task')) return 'googletasks';
    if (tool.includes('gmail') || tool.includes('email')) return 'gmail';
    if (tool.includes('contact')) return 'googlecontacts';
    return 'unknown';
  }

  private async getCustomAuthConfig(userId: string): Promise<any> {
    // This would integrate with your existing Supabase OAuth token system
    // Implementation would be similar to what's in your plugins
    return {
      parameters: [
        {
          name: "Authorization",
          value: "Bearer YOUR_ACCESS_TOKEN", // Get from Supabase
          in: "header"
        }
      ]
    };
  }

  private generateMemoryInsights(brainMemoryContext: BrainMemoryContext, toolCall: any): string[] {
    const insights = [];
    
    if (brainMemoryContext.working_memory.recent_messages.length > 0) {
      insights.push(`Found ${brainMemoryContext.working_memory.recent_messages.length} recent related conversations`);
    }
    
    if (brainMemoryContext.semantic_memory.activated_concepts.length > 0) {
      insights.push(`Activated ${brainMemoryContext.semantic_memory.activated_concepts.length} related concepts`);
    }
    
    insights.push(`Memory strength: ${brainMemoryContext.consolidation_metadata.memory_strength.toFixed(2)}`);
    
    return insights;
  }

  private summarizeToolResult(toolResult: any): string {
    if (toolResult.error) return `Error: ${toolResult.error}`;
    if (toolResult.data) return `Success with data`;
    return 'Completed';
  }

  private async linkToolExecutionToConcepts(session: any, messageId: string, toolCall: any, userId: string): Promise<void> {
    const toolName = toolCall.function.name.toLowerCase();
    let conceptName = '';
    
    if (toolName.includes('calendar')) conceptName = 'calendar_usage';
    else if (toolName.includes('task')) conceptName = 'task_management';
    else if (toolName.includes('email')) conceptName = 'email_communication';
    else if (toolName.includes('contact')) conceptName = 'contact_management';
    
    if (conceptName) {
      await session.run(`
        MATCH (msg:ChatMessage {id: $messageId})
        MERGE (concept:Concept {name: $conceptName, user_id: $userId})
        MERGE (msg)-[:MENTIONS]->(concept)
      `, { messageId, conceptName, userId });
    }
  }

  private extractTaskPattern(content: string): string | null {
    // Extract task patterns from content
    const patterns = [
      /remind.*?to\s+(.+)/i,
      /task.*?for\s+(.+)/i,
      /need.*?to\s+(.+)/i,
      /should\s+(.+)/i
    ];
    
    for (const pattern of patterns) {
      const match = content.match(pattern);
      if (match) return match[1].substring(0, 50);
    }
    
    return null;
  }

  /**
   * NEW: Get memory context optimized for chat responses
   * Supports real-time context and thread awareness
   */
  async getChatMemoryContext(
    chatId: string,
    userId: string,
    currentMessage: string,
    options: {
      timeWindow?: number; // hours for chat (can be longer than SMS)
      maxResults?: number;
      includeGoogleServices?: boolean;
      includeSMSContext?: boolean; // Include related SMS conversations
      threadId?: string; // For thread-specific context
      isGroupChat?: boolean;
      participants?: string[];
    } = {}
  ): Promise<MemoryContext> {
    const {
      timeWindow = 168, // 7 days for chat context (longer than SMS)
      maxResults = 10,   // More for chat
      includeGoogleServices = true,
      includeSMSContext = true,
      threadId,
      isGroupChat = false,
      participants = []
    } = options;

    const cacheKey = `chat_memory_context:${userId}:${chatId}:${JSON.stringify(options)}`;
    
    // Check cache first (shorter TTL for chat due to real-time nature)
    const cached = await redisCache.get(cacheKey);
    if (cached) {
      console.log(`[ConversationManager] üí¨ Chat cache hit for ${chatId}`);
      return MemoryContextSchema.parse(cached);
    }

    console.log(`[ConversationManager] üîç Building chat memory context for ${chatId}`);
    
    // Extract relevant topics from current message
    const currentTopics = await this.extractQuickTopics(currentMessage);
    
    const session = this.driver.session();
    
    try {
      // Enhanced query optimized for chat conversations with threading
      const result = await session.run(
        `
        // Find recent chat conversations with this user
        MATCH (c:Conversation)
        WHERE c.user_id = $userId 
        AND c.type = 'chat'
        AND (c.source = $chatId OR ($threadId IS NOT NULL AND c.thread_id = $threadId))
        AND c.processing_status = 'processed'
        AND c.timestamp > datetime() - duration("PT" + $timeWindow + "H")
        
        // Calculate relevance with chat-specific scoring
        WITH c,
             duration.between(c.timestamp, datetime()).hours as hoursAgo,
             CASE 
               WHEN c.metadata.is_incoming = true THEN 1.1  // Slight preference for incoming
               ELSE 1.0
             END as directionWeight,
             CASE c.priority
               WHEN 'urgent' THEN 1.0
               WHEN 'high' THEN 0.8
               WHEN 'normal' THEN 0.6
               ELSE 0.4
             END as priorityWeight,
             CASE 
               WHEN $threadId IS NOT NULL AND c.thread_id = $threadId THEN 1.5  // Thread relevance boost
               WHEN $isGroupChat = true AND c.chat_context.is_group_chat = true THEN 1.2  // Group chat context
               ELSE 1.0
             END as contextWeight
        
        // Apply chat temporal decay (slower decay than SMS for threading)
        WITH c,
             directionWeight * priorityWeight * contextWeight * (1.0 / (1.0 + 0.1 * hoursAgo)) as baseRelevance
        
        // Get semantic tags for topic matching
        OPTIONAL MATCH (c)-[m:MENTIONS]->(t:Tag)
        WHERE t.user_id = $userId
        
        // Topic relevance bonus for current message topics
        WITH c, baseRelevance,
             collect(t.name) as conversationTags,
             CASE 
               WHEN any(topic IN $currentTopics WHERE topic IN collect(t.name)) THEN 1.5
               ELSE 1.0
             END as topicBonus
        
        // Get related concepts
        OPTIONAL MATCH (concept:Concept)-[:TAGGED_WITH]->(tag:Tag)
        WHERE tag.name IN conversationTags AND concept.user_id = $userId
        
        WITH c, conversationTags, (baseRelevance * topicBonus) as finalRelevance,
             collect(DISTINCT concept) as relatedConcepts
        
        // Get conversation thread context (chat threads)
        OPTIONAL MATCH (c)-[:FOLLOWS*1..5]-(threadConv:Conversation)
        WHERE threadConv.user_id = $userId 
        AND threadConv.type = 'chat'
        AND (threadConv.source = $chatId OR threadConv.thread_id = $threadId)
        
        // NEW: Get related SMS conversations if enabled
        OPTIONAL MATCH (c)-[:RELATED_TO]-(smsConv:Conversation)
        WHERE smsConv.user_id = $userId 
        AND smsConv.type = 'sms'
        AND $includeSMSContext = true
        
        RETURN c, conversationTags, finalRelevance, relatedConcepts,
               collect(DISTINCT threadConv)[0..3] as threadContext,
               collect(DISTINCT smsConv)[0..2] as relatedSMSContext
        ORDER BY finalRelevance DESC
        LIMIT $maxResults
        `,
        { 
          userId, 
          chatId,
          threadId,
          timeWindow: timeWindow.toString(),
          maxResults,
          currentTopics,
          includeSMSContext,
          isGroupChat
        }
      );

      const conversations = result.records.map(record => ({
        conversation: this.hydrateConversation(record.get('c').properties),
        tags: record.get('conversationTags') || [],
        relevance: record.get('finalRelevance') || 0,
        concepts: (record.get('relatedConcepts') || []).map((c: any) => c?.properties).filter(Boolean),
        thread_context: (record.get('threadContext') || []).map((tc: any) => tc?.properties).filter(Boolean),
        channel_context: {
          channel: 'chat' as const,
          channel_weight: 1.0
        }
      }));

      // Add related SMS conversations if enabled
      let relatedSMSConversations = [];
      if (includeSMSContext) {
        relatedSMSConversations = await this.getRelatedSMSConversations(userId, currentTopics, timeWindow);
      }

      // Build chat-optimized memory context
      let memoryContext: MemoryContext = MemoryContextSchema.parse({
        conversations: [...conversations, ...relatedSMSConversations],
        concepts: this.extractUniqueConcepts([...conversations, ...relatedSMSConversations]),
        tags: await this.getRelevantTags(currentTopics, userId),
        contextStrength: this.calculateUnifiedContextStrength([...conversations, ...relatedSMSConversations]),
        retrievalTimestamp: new Date().toISOString(),
        queryMetadata: {
          tagNames: currentTopics,
          timeWindow,
          maxResults,
          includeArchived: false,
          channels: includeSMSContext ? ['chat', 'sms'] : ['chat']
        },
        chat_optimization: {
          max_message_length: 4000,
          supports_rich_content: true,
          real_time_context: true,
          thread_aware: !!threadId,
          suggested_interaction_style: isGroupChat ? 'casual' : 'formal'
        },
        cross_channel_insights: includeSMSContext ? {
          preferred_channel: await this.getUserPreferredChannel(userId),
          conversation_continuity: await this.getCrossChannelContinuity(userId, 'chat'),
          unified_topics: this.extractUnifiedTopics([...conversations, ...relatedSMSConversations])
        } : undefined
      });

      // Add Google services context if requested and available
      if (includeGoogleServices) {
        memoryContext.google_services_context = await this.getGoogleServicesContext(userId, currentTopics);
      }

      // Cache with shorter TTL for chat (real-time nature)
      await redisCache.setex(cacheKey, 900, JSON.stringify(memoryContext)); // 15 min

      console.log(`[ConversationManager] ‚úÖ Built chat memory context: ${conversations.length} chat + ${relatedSMSConversations.length} SMS conversations, strength: ${memoryContext.contextStrength.toFixed(2)}`);
      return memoryContext;

    } finally {
      await session.close();
    }
  }

  /**
   * NEW: Get unified memory context across all channels
   * Perfect for users who switch between SMS and chat
   */
  async getUnifiedMemoryContext(
    userId: string,
    currentMessage: string,
    primaryChannel: 'sms' | 'chat',
    channelIdentifier: string, // phone number or chat ID
    options: {
      timeWindow?: number;
      maxResults?: number;
      includeGoogleServices?: boolean;
      channelWeights?: { sms: number; chat: number };
    } = {}
  ): Promise<MemoryContext> {
    const {
      timeWindow = 120, // 5 days unified
      maxResults = 15,
      includeGoogleServices = true,
      channelWeights = { sms: 1.0, chat: 1.0 }
    } = options;

    console.log(`[ConversationManager] üîÑ Building unified memory context for user: ${userId}`);
    
    // Get context from both channels
    const [smsContext, chatContext] = await Promise.all([
      primaryChannel === 'sms' 
        ? this.getSMSMemoryContext(channelIdentifier, userId, currentMessage, { 
            timeWindow, 
            maxResults: Math.ceil(maxResults * channelWeights.sms),
            includeGoogleServices,
            includeChatContext: true
          })
        : this.getRelatedChannelContext(userId, 'sms', currentMessage, timeWindow),
      primaryChannel === 'chat'
        ? this.getChatMemoryContext(channelIdentifier, userId, currentMessage, {
            timeWindow,
            maxResults: Math.ceil(maxResults * channelWeights.chat),
            includeGoogleServices,
            includeSMSContext: true
          })
        : this.getRelatedChannelContext(userId, 'chat', currentMessage, timeWindow)
    ]);

    // Merge and unify the contexts
    const unifiedConversations = [
      ...smsContext.conversations.map(c => ({
        ...c,
        channel_context: { 
          ...c.channel_context, 
          channel_weight: channelWeights.sms 
        }
      })),
      ...chatContext.conversations.map(c => ({
        ...c,
        channel_context: { 
          ...c.channel_context, 
          channel_weight: channelWeights.chat 
        }
      }))
    ]
    .sort((a, b) => b.relevance - a.relevance)
    .slice(0, maxResults);

    const unifiedContext: MemoryContext = MemoryContextSchema.parse({
      conversations: unifiedConversations,
      concepts: this.extractUniqueConcepts(unifiedConversations),
      tags: [...smsContext.tags, ...chatContext.tags].filter((tag, index, self) => 
        index === self.findIndex(t => t.id === tag.id)
      ),
      contextStrength: this.calculateUnifiedContextStrength(unifiedConversations),
      retrievalTimestamp: new Date().toISOString(),
      queryMetadata: {
        tagNames: await this.extractQuickTopics(currentMessage),
        timeWindow,
        maxResults,
        includeArchived: false,
        channels: ['sms', 'chat']
      },
      sms_optimization: primaryChannel === 'sms' ? smsContext.sms_optimization : undefined,
      chat_optimization: primaryChannel === 'chat' ? chatContext.chat_optimization : undefined,
      google_services_context: smsContext.google_services_context || chatContext.google_services_context,
      cross_channel_insights: {
        preferred_channel: await this.getUserPreferredChannel(userId),
        conversation_continuity: await this.getCrossChannelContinuity(userId, primaryChannel),
        unified_topics: this.extractUnifiedTopics(unifiedConversations)
      }
    });

    console.log(`[ConversationManager] ‚úÖ Built unified memory context: ${unifiedConversations.length} total conversations across channels`);
    return unifiedContext;
  }

  /**
   * Track Google services interactions for memory context
   * Integrates with calendar-manager.ts, task-manager.ts etc.
   */
  async recordGoogleServiceInteraction(data: {
    user_id: string;
    service_type: 'calendar' | 'tasks' | 'contacts' | 'email';
    operation: string;
    entity_id?: string;
    conversation_id?: string;
    success: boolean;
    metadata?: Record<string, any>;
    triggered_from_channel?: 'sms' | 'chat' | 'websocket';
  }): Promise<GoogleServiceEvent> {
    console.log(`[ConversationManager] üìù Recording ${data.service_type} interaction: ${data.operation} from ${data.triggered_from_channel || 'unknown'}`);

    const eventData: GoogleServiceEvent = GoogleServiceEventSchema.parse({
      id: uuidv4(),
      user_id: data.user_id,
      service_type: data.service_type,
      operation: data.operation,
      entity_id: data.entity_id,
      conversation_id: data.conversation_id,
      timestamp: new Date().toISOString(),
      metadata: data.metadata || {},
      success: data.success,
      triggered_from_channel: data.triggered_from_channel
    });

    const session = this.driver.session();
    
    try {
      await session.run(
        `
        CREATE (event:GoogleServiceEvent {
          id: $id,
          user_id: $user_id,
          service_type: $service_type,
          operation: $operation,
          entity_id: $entity_id,
          conversation_id: $conversation_id,
          timestamp: datetime($timestamp),
          metadata: $metadata,
          success: $success,
          triggered_from_channel: $triggered_from_channel,
          created_at: datetime()
        })
        
        // Link to conversation if provided
        WITH event
        WHERE $conversation_id IS NOT NULL
        MATCH (c:Conversation {id: $conversation_id})
        CREATE (c)-[:TRIGGERED_SERVICE]->(event)
        `,
        {
          ...eventData,
          metadata: JSON.stringify(eventData.metadata)
        }
      );

      // Update conversation with Google service context
      if (data.conversation_id) {
        await this.updateConversationGoogleContext(data.conversation_id, eventData);
      }

      console.log(`[ConversationManager] ‚úÖ Recorded Google service event: ${eventData.id}`);
      return eventData;

    } finally {
      await session.close();
    }
  }

  /**
   * Enhanced SMS response optimization
   * Integrates with existing SMS message length constraints
   */
  async optimizeSMSResponse(
    originalResponse: string,
    memoryContext: MemoryContext,
    phoneNumber: string
  ): Promise<SMSConversationEnhancement> {
    console.log(`[ConversationManager] üì± Optimizing SMS response for ${phoneNumber}`);

    const maxLength = memoryContext.sms_optimization?.character_budget || 1500;
    
    if (originalResponse.length <= maxLength) {
      return SMSConversationEnhancementSchema.parse({
        phone_number: phoneNumber,
        conversation_id: memoryContext.conversations[0]?.conversation.id || uuidv4(),
        context_used: memoryContext.conversations.length > 0,
        memory_strength: memoryContext.contextStrength,
        google_services_referenced: this.extractGoogleServicesFromResponse(originalResponse),
        related_chat_conversations: memoryContext.conversations
          .filter(c => c.conversation.type === 'chat')
          .map(c => c.conversation.id)
      });
    }

    // AI-powered response compression for SMS
    const optimizedResponse = await this.compressResponseForSMS(originalResponse, maxLength, memoryContext);

    return SMSConversationEnhancementSchema.parse({
      phone_number: phoneNumber,
      conversation_id: memoryContext.conversations[0]?.conversation.id || uuidv4(),
      context_used: memoryContext.conversations.length > 0,
      memory_strength: memoryContext.contextStrength,
      response_optimization: {
        original_length: originalResponse.length,
        optimized_length: optimizedResponse.length,
        compression_ratio: optimizedResponse.length / originalResponse.length,
        key_points_preserved: this.extractKeyPoints(optimizedResponse)
      },
      google_services_referenced: this.extractGoogleServicesFromResponse(optimizedResponse),
      related_chat_conversations: memoryContext.conversations
        .filter(c => c.conversation.type === 'chat')
        .map(c => c.conversation.id)
    });
  }

  /**
   * NEW: Chat response optimization
   * Optimizes responses for chat with rich content support
   */
  async optimizeChatResponse(
    originalResponse: string,
    memoryContext: MemoryContext,
    chatId: string,
    threadId?: string
  ): Promise<ChatConversationEnhancement> {
    console.log(`[ConversationManager] üí¨ Optimizing chat response for ${chatId}`);

    return ChatConversationEnhancementSchema.parse({
      chat_id: chatId,
      conversation_id: memoryContext.conversations[0]?.conversation.id || uuidv4(),
      context_used: memoryContext.conversations.length > 0,
      memory_strength: memoryContext.contextStrength,
      real_time_context: {
        active_thread: !!threadId,
        thread_participants: memoryContext.conversations
          .filter(c => c.conversation.type === 'chat')
          .flatMap(c => c.conversation.chat_context?.participants || [])
          .filter((p, i, arr) => arr.indexOf(p) === i), // unique participants
        last_activity: new Date().toISOString(),
        conversation_velocity: this.calculateConversationVelocity(memoryContext.conversations)
      },
      rich_content_support: {
        supports_formatting: memoryContext.chat_optimization?.supports_rich_content || true,
        supports_attachments: memoryContext.chat_optimization?.supports_rich_content || true,
        supports_reactions: memoryContext.chat_optimization?.supports_rich_content || true
      },
      google_services_referenced: this.extractGoogleServicesFromResponse(originalResponse),
      related_sms_conversations: memoryContext.conversations
        .filter(c => c.conversation.type === 'sms')
        .map(c => c.conversation.id)
    });
  }

  // ============================================================================
  // PRIVATE HELPER METHODS (Enhanced with Chat Support)
  // ============================================================================

  private async analyzeConversationContent(
    content: string, 
    isIncoming: boolean, 
    channel: 'sms' | 'chat',
    context?: {
      isGroupChat?: boolean;
      participants?: string[];
    }
  ): Promise<{
    intent: string;
    sentiment: number;
    entities: any[];
    summary: string;
    priority: 'low' | 'normal' | 'high' | 'urgent';
    requiresResponse: boolean;
  }> {
    try {
      const response = await this.openai.chat.completions.create({
        model: 'gpt-4o-mini',
        messages: [{
          role: 'user',
          content: `Analyze this ${channel} message:
"${content}"

Direction: ${isIncoming ? 'Incoming' : 'Outgoing'}
Channel: ${channel}
${context?.isGroupChat ? `Group chat with ${context.participants?.length || 0} participants` : 'Individual conversation'}

Return JSON with:
- intent: main intent (question, request, info, greeting, etc.)
- sentiment: number -1 to 1
- entities: array of {text, type, confidence}
- summary: brief summary (max 50 chars)
- priority: low/normal/high/urgent
- requiresResponse: boolean`
        }],
        response_format: { type: 'json_object' },
        max_tokens: 300
      });

      return JSON.parse(response.choices[0].message.content || '{}');
    } catch (error) {
      console.warn(`[ConversationManager] AI analysis failed, using defaults:`, error);
      return {
        intent: 'unknown',
        sentiment: 0,
        entities: [],
        summary: content.substring(0, 50),
        priority: 'normal',
        requiresResponse: isIncoming
      };
    }
  }

  private async determineSMSThreadId(data: { user_id: string; phone_number: string }): Promise<string> {
    // SMS threads are typically per phone number per user
    return `sms_${data.user_id}_${data.phone_number}`;
  }

  private async determineChatThreadId(data: { 
    chat_id: string; 
    websocket_session_id?: string; 
    thread_id?: string; 
    is_group_chat?: boolean; 
    participants?: string[] 
  }): Promise<string> {
    // Chat threads are typically per chat ID per user
    const participants = data.participants?.sort().join('_') || '';
    return `chat_${data.chat_id}_${data.websocket_session_id || ''}_${data.thread_id || ''}_${data.is_group_chat ? 'group' : 'individual'}_${participants}`;
  }

  private async extractQuickTopics(message: string): Promise<string[]> {
    // Quick keyword extraction for SMS and Chat context
    const keywords = message.toLowerCase()
      .split(/\s+/)
      .filter(word => word.length > 3)
      .filter(word => !['this', 'that', 'with', 'have', 'been', 'they', 'them', 'will', 'from', 'your'].includes(word))
      .slice(0, 5); // Limit for performance

    return keywords;
  }

  private calculateUnifiedContextStrength(conversations: any[]): number {
    if (conversations.length === 0) return 0;
    
    const avgRelevance = conversations.reduce((sum, conv) => sum + (conv.relevance || 0), 0) / conversations.length;
    const countFactor = Math.min(conversations.length / 10, 1); // Unified has more conversations
    
    // Channel diversity bonus
    const channels = new Set(conversations.map(c => c.conversation.type));
    const diversityBonus = channels.size > 1 ? 1.2 : 1.0;
    
    // Recent activity factor
    const recencyFactor = conversations.some(c => 
      new Date(c.conversation.timestamp) > new Date(Date.now() - 6 * 60 * 60 * 1000) // 6 hours
    ) ? 1.3 : 1.0;
    
    return Math.min(avgRelevance * countFactor * diversityBonus * recencyFactor, 1);
  }

  private extractGoogleServicesFromResponse(response: string): ('calendar' | 'tasks' | 'contacts' | 'email')[] {
    const services: ('calendar' | 'tasks' | 'contacts' | 'email')[] = [];
    const lower = response.toLowerCase();
    
    if (lower.includes('calendar') || lower.includes('meeting') || lower.includes('event')) {
      services.push('calendar');
    }
    if (lower.includes('task') || lower.includes('todo') || lower.includes('reminder')) {
      services.push('tasks');
    }
    if (lower.includes('contact') || lower.includes('phone') || lower.includes('email')) {
      services.push('contacts');
    }
    if (lower.includes('email') || lower.includes('gmail') || lower.includes('message')) {
      services.push('email');
    }
    
    return services;
  }

  // Additional helper methods for unified conversation management...
  private calculateConversationVelocity(conversations: any[]): number {
    if (conversations.length < 2) return 0;
    
    const recentConversations = conversations
      .filter(c => new Date(c.conversation.timestamp) > new Date(Date.now() - 60 * 60 * 1000)) // Last hour
      .sort((a, b) => new Date(b.conversation.timestamp).getTime() - new Date(a.conversation.timestamp).getTime());
    
    if (recentConversations.length < 2) return 0;
    
    const timeSpan = new Date(recentConversations[0].conversation.timestamp).getTime() - 
                    new Date(recentConversations[recentConversations.length - 1].conversation.timestamp).getTime();
    
    return recentConversations.length / (timeSpan / (1000 * 60)); // messages per minute
  }

  async close(): Promise<void> {
    await this.driver.close();
  }
}

export const conversationManager = new ConversationManager();



# Neo4j Brain-Like Memory Implementation (Using Existing Schema)

## üß† **Executive Summary**

This implementation leverages your **existing Neo4j schema** to create a brain-like long-term memory system. Instead of creating new schemas, we'll use your existing `ChatMessage`, `Concept`, `Tag`, `Memory`, `Entity`, and `User` nodes with their relationships to mimic how the brain stores, connects, and retrieves memories.

## üîó **Brain-Inspired Memory Architecture**

### **Neural Pathway Mapping**


## üìä **Adapted Zod Schemas (Leveraging Existing Schema)**

```typescript
// apps/omnii-mobile/src/types/brain-memory-schemas.ts
import { z } from 'zod';

// Represents how we'll structure ChatMessage nodes for conversations
export const ConversationDataSchema = z.object({
  // Maps to ChatMessage node properties
  id: z.string().uuid(),
  user_id: z.string().min(1),
  content: z.string().min(1).max(50000),
  channel: z.enum(['sms', 'chat', 'websocket']),
  source_identifier: z.string(), // phone number or chat ID
  timestamp: z.string().datetime(),
  
  // Brain-like analysis (stored as ChatMessage properties)
  intent: z.string().optional(),
  sentiment: z.number().min(-1).max(1).optional(),
  importance_score: z.number().min(0).max(1).optional(),
  
  // Metadata for different channels
  sms_metadata: z.object({
    phone_number: z.string(),
    is_incoming: z.boolean(),
    local_datetime: z.string().optional()
  }).optional(),
  
  chat_metadata: z.object({
    chat_id: z.string(),
    websocket_session_id: z.string().optional(),
    is_group_chat: z.boolean().default(false),
    participants: z.array(z.string()).default([])
  }).optional(),
  
  // Google services context (for RELATED_TO relationships)
  google_service_context: z.object({
    service_type: z.enum(['calendar', 'tasks', 'contacts', 'email']).optional(),
    operation: z.string().optional(),
    success: z.boolean().optional()
  }).optional()
});

// Brain-like memory retrieval context
export const BrainMemoryContextSchema = z.object({
  // Working memory (immediate context)
  working_memory: z.object({
    recent_messages: z.array(ConversationDataSchema),
    active_concepts: z.array(z.string()),
    current_intent: z.string().optional()
  }),
  
  // Episodic memory (conversation episodes)
  episodic_memory: z.object({
    conversation_threads: z.array(z.object({
      thread_id: z.string(),
      messages: z.array(ConversationDataSchema),
      semantic_weight: z.number().min(0).max(1)
    })),
    related_episodes: z.array(z.string())
  }),
  
  // Semantic memory (concept associations)
  semantic_memory: z.object({
    activated_concepts: z.array(z.object({
      concept_id: z.string(),
      activation_strength: z.number().min(0).max(1),
      related_concepts: z.array(z.string())
    })),
    concept_associations: z.array(z.object({
      from_concept: z.string(),
      to_concept: z.string(),
      association_strength: z.number().min(0).max(1)
    }))
  }),
  
  // Memory consolidation metadata
  consolidation_metadata: z.object({
    retrieval_timestamp: z.string().datetime(),
    memory_strength: z.number().min(0).max(1),
    context_channels: z.array(z.enum(['sms', 'chat', 'websocket'])),
    memory_age_hours: z.number(),
    consolidation_score: z.number().min(0).max(1)
  })
});

export type ConversationData = z.infer<typeof ConversationDataSchema>;
export type BrainMemoryContext = z.infer<typeof BrainMemoryContextSchema>;
```

## üèóÔ∏è **Brain-Like ConversationManager (Using Existing Schema)**

```typescript
// apps/omnii_mcp/src/services/memory/brain-conversation-manager.ts
import neo4j, { Driver, Session, Transaction } from 'neo4j-driver';
import { v4 as uuidv4 } from 'uuid';
import { ConversationData, BrainMemoryContext } from '../../types/brain-memory-schemas';
import { redisCache } from '../redis-cache';
import { OpenAI } from 'openai';

export class BrainConversationManager {
  private driver: Driver;
  private openai: OpenAI;
  
  // Brain-like memory constants
  private readonly WORKING_MEMORY_SIZE = 7; // Miller's magic number
  private readonly EPISODIC_MEMORY_WINDOW_HOURS = 168; // 1 week
  private readonly SEMANTIC_ACTIVATION_THRESHOLD = 0.3;
  private readonly MEMORY_CONSOLIDATION_HOURS = 24;

  constructor() {
    this.driver = neo4j.driver(
      process.env.NEO4J_URI || 'bolt://localhost:7687',
      neo4j.auth.basic(
        process.env.NEO4J_USER || 'neo4j',
        process.env.NEO4J_PASSWORD || 'password'
      )
    );

    this.openai = new OpenAI({
      apiKey: process.env.OPENAI_API_KEY
    });

    console.log('üß† BrainConversationManager initialized with existing Neo4j schema');
  }

  /**
   * Store SMS conversation using existing ChatMessage nodes
   * Mimics hippocampus storing new memories
   */
  async storeSMSConversation(data: {
    user_id: string;
    content: string;
    phone_number: string;
    is_incoming: boolean;
    local_datetime?: string;
    google_service_context?: {
      service_type?: 'calendar' | 'tasks' | 'contacts' | 'email';
      operation?: string;
      entity_ids?: string[];
    };
  }): Promise<ConversationData> {
    console.log(`[BrainMemory] üíæ Storing SMS conversation (hippocampus-like processing)`);
    
    const session = this.driver.session();
    
    try {
      const conversationId = uuidv4();
      
      // Brain-like content analysis
      const insights = await this.analyzeLikeBrain(data.content, data.is_incoming, 'sms');
      
      // Create ChatMessage node with brain-like properties
      const result = await session.run(`
        // Create the ChatMessage node (hippocampus)
        CREATE (msg:ChatMessage {
          id: $id,
          content: $content,
          channel: $channel,
          source_identifier: $source_identifier,
          timestamp: datetime($timestamp),
          intent: $intent,
          sentiment: $sentiment,
          importance_score: $importance_score,
          sms_metadata: $sms_metadata,
          google_service_context: $google_service_context
        })
        
        // Link to User (ownership)
        WITH msg
        MATCH (user:User {id: $user_id})
        CREATE (user)-[:OWNS]->(msg)
        
        // Create immediate episodic memory link
        CREATE (msg)-[:HAS_MEMORY]->(memory:Memory {
          id: $memory_id,
          type: 'episodic',
          channel: $channel,
          timestamp: datetime($timestamp),
          consolidation_status: 'fresh'
        })
        
        RETURN msg, memory
      `, {
        id: conversationId,
        content: data.content,
        channel: 'sms',
        source_identifier: data.phone_number,
        timestamp: new Date().toISOString(),
        intent: insights.intent,
        sentiment: insights.sentiment,
        importance_score: insights.importance_score,
        sms_metadata: JSON.stringify({
          phone_number: data.phone_number,
          is_incoming: data.is_incoming,
          local_datetime: data.local_datetime
        }),
        google_service_context: data.google_service_context ? JSON.stringify(data.google_service_context) : null,
        user_id: data.user_id,
        memory_id: uuidv4()
      });

      // Extract and link semantic concepts (like brain's semantic processing)
      await this.extractAndLinkConcepts(session, conversationId, data.content, data.user_id);
      
      // Create semantic tags (like brain's categorization)
      await this.createSemanticTags(session, conversationId, data.content, data.user_id, 'sms');
      
      // Link to related conversations (associative memory)
      await this.createAssociativeLinks(session, conversationId, data.user_id, 'sms');
      
      // If Google service context, create RELATED_TO links
      if (data.google_service_context) {
        await this.linkToGoogleServices(session, conversationId, data.google_service_context);
      }
      
      console.log(`[BrainMemory] ‚úÖ Stored SMS conversation with brain-like processing: ${conversationId}`);
      
      return {
        id: conversationId,
        user_id: data.user_id,
        content: data.content,
        channel: 'sms',
        source_identifier: data.phone_number,
        timestamp: new Date().toISOString(),
        intent: insights.intent,
        sentiment: insights.sentiment,
        importance_score: insights.importance_score,
        sms_metadata: {
          phone_number: data.phone_number,
          is_incoming: data.is_incoming,
          local_datetime: data.local_datetime
        },
        google_service_context: data.google_service_context
      };
      
    } finally {
      await session.close();
    }
  }

  /**
   * Store chat conversation using existing ChatMessage nodes
   * Mimics hippocampus storing new memories with real-time context
   */
  async storeChatConversation(data: {
    user_id: string;
    content: string;
    chat_id: string;
    is_incoming: boolean;
    websocket_session_id?: string;
    is_group_chat?: boolean;
    participants?: string[];
    google_service_context?: {
      service_type?: 'calendar' | 'tasks' | 'contacts' | 'email';
      operation?: string;
      entity_ids?: string[];
    };
  }): Promise<ConversationData> {
    console.log(`[BrainMemory] üí¨ Storing chat conversation (hippocampus-like processing)`);
    
    const session = this.driver.session();
    
    try {
      const conversationId = uuidv4();
      
      // Brain-like content analysis (enhanced for chat context)
      const insights = await this.analyzeLikeBrain(data.content, data.is_incoming, 'chat', {
        isGroupChat: data.is_group_chat,
        participants: data.participants
      });
      
      // Create ChatMessage node with chat-specific brain-like properties
      const result = await session.run(`
        // Create the ChatMessage node (hippocampus)
        CREATE (msg:ChatMessage {
          id: $id,
          content: $content,
          channel: $channel,
          source_identifier: $source_identifier,
          timestamp: datetime($timestamp),
          intent: $intent,
          sentiment: $sentiment,
          importance_score: $importance_score,
          chat_metadata: $chat_metadata,
          google_service_context: $google_service_context
        })
        
        // Link to User (ownership)
        WITH msg
        MATCH (user:User {id: $user_id})
        CREATE (user)-[:OWNS]->(msg)
        
        // Create immediate episodic memory link
        CREATE (msg)-[:HAS_MEMORY]->(memory:Memory {
          id: $memory_id,
          type: 'episodic',
          channel: $channel,
          timestamp: datetime($timestamp),
          consolidation_status: 'fresh',
          real_time_context: true
        })
        
        RETURN msg, memory
      `, {
        id: conversationId,
        content: data.content,
        channel: 'chat',
        source_identifier: data.chat_id,
        timestamp: new Date().toISOString(),
        intent: insights.intent,
        sentiment: insights.sentiment,
        importance_score: insights.importance_score,
        chat_metadata: JSON.stringify({
          chat_id: data.chat_id,
          websocket_session_id: data.websocket_session_id,
          is_group_chat: data.is_group_chat || false,
          participants: data.participants || []
        }),
        google_service_context: data.google_service_context ? JSON.stringify(data.google_service_context) : null,
        user_id: data.user_id,
        memory_id: uuidv4()
      });

      // Same brain-like processing as SMS
      await this.extractAndLinkConcepts(session, conversationId, data.content, data.user_id);
      await this.createSemanticTags(session, conversationId, data.content, data.user_id, 'chat');
      await this.createAssociativeLinks(session, conversationId, data.user_id, 'chat');
      
      if (data.google_service_context) {
        await this.linkToGoogleServices(session, conversationId, data.google_service_context);
      }
      
      // Chat-specific: Link to other participants if group chat
      if (data.is_group_chat && data.participants?.length) {
        await this.linkGroupChatParticipants(session, conversationId, data.participants);
      }
      
      console.log(`[BrainMemory] ‚úÖ Stored chat conversation with brain-like processing: ${conversationId}`);
      
      return {
        id: conversationId,
        user_id: data.user_id,
        content: data.content,
        channel: 'chat',
        source_identifier: data.chat_id,
        timestamp: new Date().toISOString(),
        intent: insights.intent,
        sentiment: insights.sentiment,
        importance_score: insights.importance_score,
        chat_metadata: {
          chat_id: data.chat_id,
          websocket_session_id: data.websocket_session_id,
          is_group_chat: data.is_group_chat || false,
          participants: data.participants || []
        },
        google_service_context: data.google_service_context
      };
      
    } finally {
      await session.close();
    }
  }

  /**
   * Retrieve memory context like brain's memory retrieval
   * Mimics working memory + episodic + semantic memory activation
   */
  async getBrainMemoryContext(
    userId: string,
    currentMessage: string,
    channel: 'sms' | 'chat',
    sourceIdentifier: string, // phone number or chat ID
    options: {
      workingMemorySize?: number;
      episodicWindowHours?: number;
      semanticActivationThreshold?: number;
    } = {}
  ): Promise<BrainMemoryContext> {
    const {
      workingMemorySize = this.WORKING_MEMORY_SIZE,
      episodicWindowHours = this.EPISODIC_MEMORY_WINDOW_HOURS,
      semanticActivationThreshold = this.SEMANTIC_ACTIVATION_THRESHOLD
    } = options;

    console.log(`[BrainMemory] üß† Retrieving brain-like memory context for ${channel}:${sourceIdentifier}`);
    
    const session = this.driver.session();
    
    try {
      // Step 1: Working Memory - Recent conversations (hippocampus-like)
      const workingMemoryResult = await session.run(`
        MATCH (user:User {id: $userId})-[:OWNS]->(msg:ChatMessage)
        WHERE msg.channel = $channel 
        AND msg.source_identifier = $sourceIdentifier
        AND msg.timestamp > datetime() - duration({hours: 2}) // Last 2 hours for working memory
        RETURN msg
        ORDER BY msg.timestamp DESC
        LIMIT $workingMemorySize
      `, { userId, channel, sourceIdentifier, workingMemorySize });

      // Step 2: Episodic Memory - Related conversation threads (cortex-like)
      const episodicMemoryResult = await session.run(`
        MATCH (user:User {id: $userId})-[:OWNS]->(msg:ChatMessage)-[:HAS_MEMORY]->(memory:Memory)
        WHERE msg.timestamp > datetime() - duration({hours: $episodicWindowHours})
        AND (msg.channel = $channel OR memory.type = 'cross_channel')
        
        // Get related conversations through semantic links
        OPTIONAL MATCH (msg)-[:MENTIONS]->(concept:Concept)<-[:MENTIONS]-(relatedMsg:ChatMessage)
        WHERE relatedMsg.timestamp > datetime() - duration({hours: $episodicWindowHours})
        
        WITH msg, memory, collect(DISTINCT relatedMsg) as relatedMessages
        RETURN msg, memory, relatedMessages
        ORDER BY msg.timestamp DESC
        LIMIT 10
      `, { userId, channel, episodicWindowHours });

      // Step 3: Semantic Memory - Concept activation (semantic network-like)
      const semanticMemoryResult = await session.run(`
        // Find concepts mentioned in current message (this would be done via NLP)
        MATCH (user:User {id: $userId})-[:OWNS]->(msg:ChatMessage)-[:MENTIONS]->(concept:Concept)
        WHERE msg.timestamp > datetime() - duration({hours: $episodicWindowHours})
        
        // Get related concepts through various relationships
        OPTIONAL MATCH (concept)-[:RELATED_TO|:CONTAINS_CONCEPT]-(relatedConcept:Concept)
        
        WITH concept, collect(DISTINCT relatedConcept) as relatedConcepts,
             count(msg) as conceptFrequency
        WHERE conceptFrequency >= 2 // Only concepts mentioned multiple times
        
        RETURN concept, relatedConcepts, conceptFrequency
        ORDER BY conceptFrequency DESC
        LIMIT 20
      `, { userId, episodicWindowHours });

      // Process results into brain-like memory context
      const workingMemory = workingMemoryResult.records.map(record => {
        const msg = record.get('msg').properties;
        return this.nodeToConversationData(msg);
      });

      const episodicMemory = episodicMemoryResult.records.map(record => {
        const msg = record.get('msg').properties;
        const memory = record.get('memory').properties;
        const relatedMessages = record.get('relatedMessages') || [];
        
        return {
          thread_id: memory.id,
          messages: [this.nodeToConversationData(msg)],
          semantic_weight: this.calculateSemanticWeight(msg, relatedMessages)
        };
      });

      const semanticMemory = semanticMemoryResult.records.map(record => {
        const concept = record.get('concept').properties;
        const relatedConcepts = record.get('relatedConcepts') || [];
        const frequency = record.get('conceptFrequency').toNumber();
        
        return {
          concept_id: concept.id,
          activation_strength: Math.min(frequency / 10, 1.0), // Normalize frequency
          related_concepts: relatedConcepts.map((c: any) => c.properties.id)
        };
      });

      // Calculate overall memory strength (enhanced with time-based working memory)
      const memoryStrength = this.calculateTimeBasedMemoryStrength(
        workingMemory,
        episodicMemory.length,
        semanticMemory.length
      );

      return {
        working_memory: workingMemory,
        episodic_memory: {
          conversation_threads: episodicMemory,
          related_episodes: episodicMemory.map(e => e.thread_id)
        },
        semantic_memory: {
          activated_concepts: semanticMemory,
          concept_associations: await this.getConceptAssociations(session, userId, semanticMemory.map(s => s.concept_id))
        },
        consolidation_metadata: {
          retrieval_timestamp: new Date().toISOString(),
          memory_strength: memoryStrength,
          context_channels: [channel],
          memory_age_hours: episodicWindowHours,
          consolidation_score: this.calculateConsolidationScore(episodicMemory, semanticMemory)
        }
      };
      
    } finally {
      await session.close();
    }
  }

  // ============================================================================
  // BRAIN-LIKE HELPER METHODS
  // ============================================================================

  /**
   * Analyze content like brain's initial processing
   */
  private async analyzeLikeBrain(
    content: string, 
    isIncoming: boolean, 
    channel: 'sms' | 'chat',
    context?: {
      isGroupChat?: boolean;
      participants?: string[];
    }
  ): Promise<{
    intent: string;
    sentiment: number;
    importance_score: number;
  }> {
    try {
      const response = await this.openai.chat.completions.create({
        model: 'gpt-4o-mini',
        messages: [{
          role: 'user',
          content: `Analyze this ${channel} message like a brain would process it:
"${content}"

Direction: ${isIncoming ? 'Incoming' : 'Outgoing'}
Channel: ${channel}
${context?.isGroupChat ? `Group chat with ${context.participants?.length || 0} participants` : 'Individual conversation'}

Return JSON with:
- intent: main intent/purpose (question, request, info, social, task, etc.)
- sentiment: number -1 to 1 (emotional valence)
- importance_score: 0 to 1 (how important/memorable this is)

Consider:
- Emotional significance
- Actionability 
- Information density
- Social context
- Urgency indicators`
        }],
        response_format: { type: 'json_object' },
        max_tokens: 200
      });

      const analysis = JSON.parse(response.choices[0].message.content || '{}');
      
      return {
        intent: analysis.intent || 'unknown',
        sentiment: analysis.sentiment || 0,
        importance_score: analysis.importance_score || 0.5
      };
    } catch (error) {
      console.warn(`[BrainMemory] AI analysis failed, using defaults:`, error);
      return {
        intent: 'unknown',
        sentiment: 0,
        importance_score: isIncoming ? 0.6 : 0.4 // Incoming messages slightly more important
      };
    }
  }

  /**
   * Extract and link concepts using existing Concept nodes
   */
  private async extractAndLinkConcepts(
    session: Session,
    conversationId: string,
    content: string,
    userId: string
  ): Promise<void> {
    // Extract key concepts from content (simplified - could use NLP)
    const concepts = await this.extractKeyConceptsFromContent(content);
    
    for (const conceptText of concepts) {
      await session.run(`
        // Find or create Concept node
        MERGE (concept:Concept {name: $conceptText, user_id: $userId})
        
        // Link conversation to concept
        WITH concept
        MATCH (msg:ChatMessage {id: $conversationId})
        MERGE (msg)-[:MENTIONS]->(concept)
        
        // Update concept usage
        SET concept.last_mentioned = datetime(),
            concept.mention_count = COALESCE(concept.mention_count, 0) + 1
      `, { conceptText, userId, conversationId });
    }
  }

  /**
   * Create semantic tags using existing Tag nodes
   */
  private async createSemanticTags(
    session: Session,
    conversationId: string,
    content: string,
    userId: string,
    channel: string
  ): Promise<void> {
    const tags = await this.generateSemanticTags(content, channel);
    
    for (const tagName of tags) {
      await session.run(`
        // Find or create Tag node
        MERGE (tag:Tag {name: $tagName, user_id: $userId})
        
        // Link conversation to tag
        WITH tag
        MATCH (msg:ChatMessage {id: $conversationId})
        MERGE (msg)-[:HAS_TAG]->(tag)
        
        // Update tag usage
        SET tag.last_used = datetime(),
            tag.usage_count = COALESCE(tag.usage_count, 0) + 1,
            tag.channel_origin = $channel
      `, { tagName, userId, conversationId, channel });
    }
  }

  /**
   * Create associative links between related conversations
   */
  private async createAssociativeLinks(
    session: Session,
    conversationId: string,
    userId: string,
    channel: string
  ): Promise<void> {
    // Find related conversations through shared concepts/tags
    await session.run(`
      MATCH (newMsg:ChatMessage {id: $conversationId})-[:MENTIONS|:HAS_TAG]->(shared)
      <-[:MENTIONS|:HAS_TAG]-(relatedMsg:ChatMessage)
      WHERE relatedMsg.timestamp > datetime() - duration({days: 7})
      AND relatedMsg.id <> $conversationId
      
      // Create or strengthen associative link
      MERGE (newMsg)-[rel:RELATED_TO]-(relatedMsg)
      SET rel.strength = COALESCE(rel.strength, 0) + 0.1,
          rel.last_activated = datetime(),
          rel.association_type = 'semantic'
      
      // Bidirectional relationship
      MERGE (relatedMsg)-[rel2:RELATED_TO]-(newMsg)
      SET rel2.strength = COALESCE(rel2.strength, 0) + 0.1,
          rel2.last_activated = datetime(),
          rel2.association_type = 'semantic'
    `, { conversationId, userId });
  }

  /**
   * Link to Google services using existing OAuthToken relationships
   */
  private async linkToGoogleServices(
    session: Session,
    conversationId: string,
    serviceContext: any
  ): Promise<void> {
    if (!serviceContext.service_type) return;
    
    await session.run(`
      MATCH (msg:ChatMessage {id: $conversationId})
      MATCH (token:OAuthToken {service: $serviceType})
      
      // Create service relationship
      CREATE (msg)-[:TRIGGERED_SERVICE {
        operation: $operation,
        success: $success,
        timestamp: datetime()
      }]->(token)
    `, {
      conversationId,
      serviceType: serviceContext.service_type,
      operation: serviceContext.operation || 'unknown',
      success: serviceContext.success || false
    });
  }

  // Additional helper methods...
  private async extractKeyConceptsFromContent(content: string): Promise<string[]> {
    // Simplified concept extraction - could be enhanced with NLP
    const words = content.toLowerCase()
      .split(/\s+/)
      .filter(word => word.length > 3)
      .filter(word => !['this', 'that', 'with', 'have', 'been', 'they', 'them', 'will', 'from', 'your', 'what', 'when', 'where'].includes(word))
      .slice(0, 5);
    
    return words;
  }

  private async generateSemanticTags(content: string, channel: string): Promise<string[]> {
    // Generate semantic tags based on content and channel
    const tags = [];
    
    if (content.toLowerCase().includes('meeting') || content.toLowerCase().includes('schedule')) {
      tags.push('scheduling');
    }
    if (content.toLowerCase().includes('task') || content.toLowerCase().includes('todo')) {
      tags.push('task_management');
    }
    if (content.toLowerCase().includes('email') || content.toLowerCase().includes('send')) {
      tags.push('communication');
    }
    
    tags.push(channel); // Channel-specific tag
    tags.push(`${channel}_${new Date().getHours() < 12 ? 'morning' : 'afternoon'}`); // Time-based tag
    
    return tags;
  }

  private calculateSemanticWeight(msg: any, relatedMessages: any[]): number {
    // Calculate semantic weight based on message properties and relationships
    const baseWeight = msg.importance_score || 0.5;
    const relationshipBonus = Math.min(relatedMessages.length / 10, 0.3);
    const recencyBonus = this.calculateRecencyBonus(msg.timestamp);
    
    return Math.min(baseWeight + relationshipBonus + recencyBonus, 1.0);
  }

  private calculateRecencyBonus(timestamp: string): number {
    const messageDate = new Date(timestamp);
    const now = new Date();
    const hoursDiff = (now.getTime() - messageDate.getTime()) / (1000 * 60 * 60);
    
    // Recent messages get higher weight (exponential decay)
    return Math.exp(-hoursDiff / 24) * 0.2; // Max 0.2 bonus for very recent messages
  }

  private calculateMemoryStrength(
    workingMemoryCount: number,
    episodicMemoryCount: number,
    semanticMemoryCount: number
  ): number {
    const workingWeight = Math.min(workingMemoryCount / this.WORKING_MEMORY_SIZE, 1.0) * 0.4;
    const episodicWeight = Math.min(episodicMemoryCount / 10, 1.0) * 0.4;
    const semanticWeight = Math.min(semanticMemoryCount / 20, 1.0) * 0.2;
    
    return workingWeight + episodicWeight + semanticWeight;
  }

  /**
   * Enhanced memory strength calculation for time-based working memory
   */
  private calculateTimeBasedMemoryStrength(
    workingMemory: any,
    episodicMemoryCount: number,
    semanticMemoryCount: number
  ): number {
    // Base memory strength components
    const episodicWeight = Math.min(episodicMemoryCount / 10, 1.0) * 0.3;
    const semanticWeight = Math.min(semanticMemoryCount / 20, 1.0) * 0.2;
    
    // Time-based working memory strength (0.5 total weight)
    const recentWeight = Math.min(workingMemory.recent_messages.length / this.WORKING_MEMORY_SIZE, 1.0) * 0.2;
    const timeWindowWeight = Math.min(workingMemory.time_window_messages.length / 50, 1.0) * 0.15; // 50 messages across 3 weeks
    const recentlyModifiedWeight = Math.min(workingMemory.recently_modified_messages.length / 10, 1.0) * 0.15;
    
    // Bonus for balanced time distribution
    const timeBalance = this.calculateTimeBalance(workingMemory.time_window_stats);
    const balanceBonus = timeBalance * 0.1; // Up to 10% bonus for good time distribution
    
    const totalStrength = recentWeight + timeWindowWeight + recentlyModifiedWeight + episodicWeight + semanticWeight + balanceBonus;
    
    console.log(`[BrainMemory] üí™ Memory Strength: Recent(${recentWeight.toFixed(2)}) TimeWindow(${timeWindowWeight.toFixed(2)}) Modified(${recentlyModifiedWeight.toFixed(2)}) Balance(${balanceBonus.toFixed(2)}) = ${totalStrength.toFixed(2)}`);
    
    return Math.min(totalStrength, 1.0);
  }

  /**
   * Calculate time balance bonus (better distribution across weeks = stronger memory)
   */
  private calculateTimeBalance(stats: any): number {
    const total = stats.previous_week_count + stats.current_week_count + stats.next_week_count;
    if (total === 0) return 0;
    
    // Calculate entropy-like measure of time distribution
    const previousRatio = stats.previous_week_count / total;
    const currentRatio = stats.current_week_count / total;
    const nextRatio = stats.next_week_count / total;
    
    // Perfect balance would be 1/3 each, entropy would be high
    const entropy = -(
      (previousRatio > 0 ? previousRatio * Math.log(previousRatio) : 0) +
      (currentRatio > 0 ? currentRatio * Math.log(currentRatio) : 0) +
      (nextRatio > 0 ? nextRatio * Math.log(nextRatio) : 0)
    );
    
    // Normalize entropy (max entropy for 3 categories is ln(3) ‚âà 1.099)
    return Math.min(entropy / Math.log(3), 1.0);
  }

  private calculateConsolidationScore(episodicMemory: any[], semanticMemory: any[]): number {
    // Brain-like consolidation score based on memory interconnectedness
    const episodicConnections = episodicMemory.length;
    const semanticConnections = semanticMemory.reduce((sum, s) => sum + s.related_concepts.length, 0);
    
    return Math.min((episodicConnections + semanticConnections) / 50, 1.0);
  }

  private async inferCurrentIntent(message: string): Promise<string> {
    // Quick intent inference for current message
    const msg = message.toLowerCase();
    
    if (msg.includes('?')) return 'question';
    if (msg.includes('schedule') || msg.includes('meeting')) return 'scheduling';
    if (msg.includes('send') || msg.includes('email')) return 'communication';
    if (msg.includes('task') || msg.includes('todo')) return 'task_management';
    if (msg.includes('find') || msg.includes('search')) return 'information_seeking';
    
    return 'general';
  }

  private async getConceptAssociations(session: Session, userId: string, conceptIds: string[]): Promise<any[]> {
    if (conceptIds.length === 0) return [];
    
    const result = await session.run(`
      MATCH (c1:Concept)-[:RELATED_TO]-(c2:Concept)
      WHERE c1.id IN $conceptIds AND c2.id IN $conceptIds
      AND c1.user_id = $userId AND c2.user_id = $userId
      RETURN c1.id as from_concept, c2.id as to_concept, 
             COALESCE(c1.mention_count, 1) + COALESCE(c2.mention_count, 1) as strength
    `, { conceptIds, userId });

    return result.records.map(record => ({
      from_concept: record.get('from_concept'),
      to_concept: record.get('to_concept'),
      association_strength: Math.min(record.get('strength').toNumber() / 20, 1.0)
    }));
  }

  private nodeToConversationData(node: any): ConversationData {
    const smsMetadata = node.sms_metadata ? JSON.parse(node.sms_metadata) : undefined;
    const chatMetadata = node.chat_metadata ? JSON.parse(node.chat_metadata) : undefined;
    const googleServiceContext = node.google_service_context ? JSON.parse(node.google_service_context) : undefined;
    
    return {
      id: node.id,
      user_id: node.user_id,
      content: node.content,
      channel: node.channel,
      source_identifier: node.source_identifier,
      timestamp: node.timestamp,
      intent: node.intent,
      sentiment: node.sentiment,
      importance_score: node.importance_score,
      sms_metadata: smsMetadata,
      chat_metadata: chatMetadata,
      google_service_context: googleServiceContext
    };
  }

  async close(): Promise<void> {
    await this.driver.close();
  }
}

export const brainConversationManager = new BrainConversationManager();
```

## üîå **Integration with Existing Services**

### **Enhanced ExecutionContext (Minimal Changes)**

```typescript
// apps/omnii_mcp/src/types/action-planning.types.ts (Add to existing)
export interface ExecutionContext {
  // ... existing fields ...
  
  // NEW: Brain-like memory context
  brainMemoryContext?: BrainMemoryContext;
  
  // NEW: Communication channel awareness
  communicationChannel?: 'sms' | 'chat' | 'websocket';
}
```

### **SimpleSMSAI Integration (Minimal Changes)**

```typescript
// apps/omnii_mcp/src/services/sms-ai-simple.ts (Enhanced processMessage)
async processMessage(
  message: string,
  phoneNumber: string,
  localDatetime?: string
): Promise<{...}> {
  try {
    // ... existing validation and timezone logic ...

    // NEW: Store conversation in brain-like memory
    const conversationData = await brainConversationManager.storeSMSConversation({
      user_id: entityId,
      content: message,
      phone_number: phoneNumber,
      is_incoming: true,
      local_datetime: localDatetime
    });

    // NEW: Get brain-like memory context
    const brainMemoryContext = await brainConversationManager.getBrainMemoryContext(
      entityId,
      message,
      'sms',
      phoneNumber
    );

    // Enhanced execution context with brain memory
    const context: ExecutionContext = {
      entityId,
      phoneNumber,
      userTimezone,
      localDatetime,
      stepResults: new Map(),
      currentStepIndex: 0,
      entities: resolvedEntities,
      sessionId,
      planState: PlanState.PENDING,
      context: ExecutionContextType.SMS,
      // NEW: Brain-like memory integration
      brainMemoryContext,
      communicationChannel: 'sms'
    };

    // Continue with existing action planning (now memory-enhanced)
    const plan = await this.actionPlanner.createPlan(message, resolvedEntities);
    const result = await this.actionPlanner.executePlan(plan, context);

    // NEW: Store outgoing response in brain memory
    if (result.success) {
      await brainConversationManager.storeSMSConversation({
        user_id: entityId,
        content: result.message,
        phone_number: phoneNumber,
        is_incoming: false,
        local_datetime: localDatetime
      });
    }

    return result;
  } catch (error) {
    // ... existing error handling ...
  }
}
```

### **Chat Service Integration (WebSocket Enhancement)**

```typescript
// apps/omnii_mcp/src/services/websocket-handler.service.ts (Enhanced processCommand)
private async processCommand(payload: CommandPayload): Promise<WebSocketResponse> {
  try {
    // ... existing command processing ...

    // NEW: Store incoming chat message in brain memory
    const conversationData = await brainConversationManager.storeChatConversation({
      user_id: payload.userId,
      content: payload.message,
      chat_id: payload.userId, // Using userId as chat identifier
      is_incoming: true,
      websocket_session_id: payload.sessionId
    });

    // NEW: Get brain-like memory context for chat
    const brainMemoryContext = await brainConversationManager.getBrainMemoryContext(
      payload.userId,
      payload.message,
      'chat',
      payload.userId
    );

    // Enhanced execution context
    const executionContext: ExecutionContext = {
      // ... existing context fields ...
      brainMemoryContext,
      communicationChannel: 'chat'
    };

    // Continue with existing command processing (now memory-enhanced)
    // ... existing logic ...

  } catch (error) {
    // ... existing error handling ...
  }
}
```

## üß† **Brain-Like Memory Patterns**

### **1. Memory Consolidation (Background Process)**
```typescript
// Background process to consolidate memories (like sleep consolidation)
async consolidateMemories(): Promise<void> {
  const session = this.driver.session();
  
  try {
    // Find fresh memories that need consolidation
    await session.run(`
      MATCH (msg:ChatMessage)-[:HAS_MEMORY]->(memory:Memory {consolidation_status: 'fresh'})
      WHERE memory.timestamp < datetime() - duration({hours: 24})
      
      // Promote important memories to long-term storage
      WITH msg, memory
      WHERE msg.importance_score > 0.7 OR 
            size((msg)-[:MENTIONS]->(:Concept)) > 3 OR
            size((msg)-[:RELATED_TO]-(:ChatMessage)) > 2
      
      SET memory.consolidation_status = 'consolidated',
          memory.consolidation_date = datetime()
      
      // Create consolidated Memory node for long-term storage
      CREATE (consolidatedMemory:Memory {
        id: randomUUID(),
        type: 'consolidated',
        original_message_id: msg.id,
        consolidation_summary: msg.intent + ': ' + substring(msg.content, 0, 100),
        importance_score: msg.importance_score,
        timestamp: memory.timestamp,
        consolidation_date: datetime()
      })
      
      CREATE (memory)-[:CONSOLIDATED_TO]->(consolidatedMemory)
    `);
  } finally {
    await session.close();
  }
}
```

### **2. Memory Decay (Forgetting Process)**
```typescript
// Implement forgetting like the brain does
async implementMemoryDecay(): Promise<void> {
  const session = this.driver.session();
  
  try {
    // Weaken old, unimportant memory links
    await session.run(`
      MATCH (msg:ChatMessage)-[rel:RELATED_TO]-(otherMsg:ChatMessage)
      WHERE rel.last_activated < datetime() - duration({days: 30})
      AND rel.strength < 0.3
      
      // Decay the relationship strength
      SET rel.strength = rel.strength * 0.9
      
      // Remove very weak relationships (forgetting)
      WITH rel
      WHERE rel.strength < 0.1
      DELETE rel
    `);
    
    // Archive very old, low-importance memories
    await session.run(`
      MATCH (msg:ChatMessage)-[:HAS_MEMORY]->(memory:Memory)
      WHERE memory.timestamp < datetime() - duration({days: 90})
      AND msg.importance_score < 0.3
      AND size((msg)-[:RELATED_TO]-()) < 2
      
      SET memory.status = 'archived',
          memory.archived_date = datetime()
    `);
  } finally {
    await session.close();
  }
}
```

### **3. Priming and Activation Spreading**
```typescript
// Implement brain-like priming effects
async activateRelatedMemories(conceptIds: string[]): Promise<string[]> {
  const session = this.driver.session();
  
  try {
    const result = await session.run(`
      // Start with activated concepts
      MATCH (startConcept:Concept)
      WHERE startConcept.id IN $conceptIds
      
      // Spread activation through concept network (like neural activation)
      MATCH (startConcept)-[:RELATED_TO*1..2]-(relatedConcept:Concept)
      
      // Get messages associated with activated concepts
      MATCH (relatedConcept)<-[:MENTIONS]-(msg:ChatMessage)
      WHERE msg.timestamp > datetime() - duration({days: 30})
      
      // Calculate activation strength based on path length and recency
      WITH msg, 
           1.0 / (length(shortestPath((startConcept)-[:RELATED_TO*]-(relatedConcept))) + 1) as pathStrength,
           1.0 / (duration.between(msg.timestamp, datetime()).days + 1) as recencyStrength
      
      WITH msg, pathStrength * recencyStrength as activationLevel
      WHERE activationLevel > 0.1
      
      RETURN msg.id as messageId, activationLevel
      ORDER BY activationLevel DESC
      LIMIT 10
    `, { conceptIds });
    
    return result.records.map(record => record.get('messageId'));
  } finally {
    await session.close();
  }
}
```

This implementation leverages your existing Neo4j schema to create a brain-like memory system that:

1. **Uses existing nodes** (`ChatMessage`, `Concept`, `Tag`, `Memory`, `User`, `OAuthToken`)
2. **Uses existing relationships** (`HAS_MEMORY`, `MENTIONS`, `HAS_TAG`, `RELATED_TO`, `OWNS`)
3. **Mimics brain processes** (hippocampus ‚Üí cortex consolidation, activation spreading, memory decay)
4. **Integrates seamlessly** with your existing SMS and Chat infrastructure
5. **Provides brain-like memory retrieval** with working memory, episodic memory, and semantic memory

The system now thinks and remembers like a brain while using your existing graph structure! üß†‚ú®

## üîó **COMPOSIO + BRAIN MEMORY INTEGRATION (COMPLETE)**

### **How Composio Currently Works vs. Memory-Enhanced**

```typescript
// BEFORE: Standard Composio execution (no memory)
const result = await composio.client.actions.execute({
  actionName: toolCall.function.name,
  requestBody: {
    input: JSON.parse(toolCall.function.arguments),
    appName: "googletasks",
    authConfig: { /* OAuth tokens */ }
  }
});

// AFTER: Memory-enhanced Composio execution
const brainMemoryContext = await conversationManager.getBrainMemoryContext(userId, message, channel, sourceId);

const memoryResult = await conversationManager.executeComposioToolWithMemory(
  userId,
  toolCall,
  composio,
  brainMemoryContext,
  channel,
  sourceId
);
```

### **Enhanced Plugin Architecture**

```typescript
// apps/omnii_mcp/src/services/plugins/brain-enhanced-base-plugin.ts
export abstract class BrainEnhancedPlugin implements GoogleServicePlugin {
  protected conversationManager: ConversationManager;
  
  constructor(conversationManager: ConversationManager) {
    this.conversationManager = conversationManager;
  }

  /**
   * Enhanced processMessage with brain memory integration
   */
  async processMessage(
    message: string,
    userId: string,
    context: ExecutionContextType,
    activeConnection: any,
    composio: OpenAIToolSet,
    openai: OpenAI
  ): Promise<UnifiedToolResponse> {

    // STEP 1: Check if we have brain memory context in execution context
    const brainMemoryContext = context.brainMemoryContext;
    
    if (!brainMemoryContext) {
      console.warn(`[BrainPlugin] No brain memory context provided, falling back to standard processing`);
      return await this.processMessageStandard(message, userId, context, activeConnection, composio, openai);
    }

    // STEP 2: Enhanced processing with memory
    return await this.processMessageWithMemory(
      message, 
      userId, 
      context, 
      activeConnection, 
      composio, 
      openai, 
      brainMemoryContext
    );
  }

  /**
   * Abstract method for memory-enhanced processing
   */
  abstract processMessageWithMemory(
    message: string,
    userId: string,
    context: ExecutionContextType,
    activeConnection: any,
    composio: OpenAIToolSet,
    openai: OpenAI,
    brainMemoryContext: BrainMemoryContext
  ): Promise<UnifiedToolResponse>;

  /**
   * Fallback to standard processing
   */
  abstract processMessageStandard(
    message: string,
    userId: string,
    context: ExecutionContextType,
    activeConnection: any,
    composio: OpenAIToolSet,
    openai: OpenAI
  ): Promise<UnifiedToolResponse>;
}
```

### **Brain-Enhanced Tasks Plugin Example**

```typescript
// apps/omnii_mcp/src/services/plugins/brain-enhanced-tasks-plugin.ts
export class BrainEnhancedTasksPlugin extends BrainEnhancedPlugin {
  serviceType = GoogleServiceType.TASKS;

  async processMessageWithMemory(
    message: string,
    userId: string,
    context: ExecutionContextType,
    activeConnection: any,
    composio: OpenAIToolSet,
    openai: OpenAI,
    brainMemoryContext: BrainMemoryContext
  ): Promise<UnifiedToolResponse> {
    
    const builder = new UnifiedResponseBuilder(ServiceType.TASKS, userId);

    try {
      console.log(`[BrainTasks] üß†‚úÖ Processing tasks with brain memory context`);

      // Memory-enhanced OpenAI completion
      const response = await openai.chat.completions.create({
        model: "gpt-4o-mini",
        messages: [
          {
            role: "system",
            content: this.buildMemoryEnhancedSystemPrompt(brainMemoryContext)
          },
          {
            role: "user",
            content: message,
          },
        ],
        tools: await composio.getTools({
          actions: [
            GoogleTasksAction.LIST_TASK_LISTS,
            GoogleTasksAction.LIST_TASKS,
            GoogleTasksAction.INSERT_TASK,
            GoogleTasksAction.PATCH_TASK,
          ],
        }),
        tool_choice: "auto",
      });

      const toolCalls = response.choices[0].message.tool_calls;
      if (!toolCalls || toolCalls.length === 0) {
        return builder
          .setSuccess(false)
          .setTitle("Task Request Failed")
          .setContent("I couldn't determine what task action you want to perform.")
          .build();
      }

      // Memory-enhanced tool execution
      const toolResults = [];
      for (const toolCall of toolCalls) {
        console.log(`[BrainTasks] üß†üîß Executing ${toolCall.function.name} with brain memory`);
        
        const memoryResult = await this.conversationManager.executeComposioToolWithMemory(
          userId,
          toolCall,
          composio,
          brainMemoryContext,
          context.communicationChannel || 'sms',
          context.phoneNumber || 'unknown'
        );

        toolResults.push({
          tool_name: toolCall.function.name,
          success: memoryResult.success,
          result: memoryResult.result,
          memory_enhanced: memoryResult.memoryEnhanced,
          memory_insights: memoryResult.memoryInsights
        });
      }

      // Build response with memory insights
      return builder
        .setSuccess(true)
        .setTitle("Tasks Processed with Brain Memory")
        .setContent(`Successfully processed ${toolResults.length} task operations using conversation memory`)
        .setRawData({
          tool_results: toolResults,
          memory_context: {
            working_memory_items: brainMemoryContext.working_memory.recent_messages.length,
            activated_concepts: brainMemoryContext.semantic_memory.activated_concepts.length,
            memory_strength: brainMemoryContext.consolidation_metadata.memory_strength
          }
        })
        .build();

    } catch (error) {
      console.error(`[BrainTasks] ‚ùå Memory-enhanced processing failed:`, error);
      
      // Fallback to standard processing
      return await this.processMessageStandard(message, userId, context, activeConnection, composio, openai);
    }
  }

  /**
   * Build system prompt enhanced with brain memory context
   */
  private buildMemoryEnhancedSystemPrompt(brainMemoryContext: BrainMemoryContext): string {
    const recentTasks = brainMemoryContext.working_memory.recent_messages
      .filter(msg => msg.intent?.includes('task') || msg.content.toLowerCase().includes('task'))
      .slice(0, 3);

    const taskConcepts = brainMemoryContext.semantic_memory.activated_concepts
      .filter(concept => concept.concept.name.includes('task') || concept.concept.name.includes('todo'))
      .slice(0, 3);

    let memoryContext = '';
    
    if (recentTasks.length > 0) {
      memoryContext += `\nRecent task-related conversations:\n`;
      recentTasks.forEach((msg, i) => {
        memoryContext += `${i + 1}. ${msg.content.substring(0, 100)}...\n`;
      });
    }

    if (taskConcepts.length > 0) {
      memoryContext += `\nActivated task concepts: ${taskConcepts.map(c => c.concept.name).join(', ')}\n`;
    }

    return `You are a Google Tasks assistant with access to conversation memory.

${memoryContext}

Use this memory context to:
1. Reference previous tasks mentioned
2. Maintain context across conversations
3. Suggest related tasks based on patterns
4. Avoid creating duplicate tasks

Available actions:
- LIST_TASK_LISTS: Get all task lists
- LIST_TASKS: Get tasks within a specific task list  
- INSERT_TASK: Create a new task
- PATCH_TASK: Update/complete a task

Always consider the conversation history when making decisions.`;
  }

  async processMessageStandard(
    message: string,
    userId: string,
    context: ExecutionContextType,
    activeConnection: any,
    composio: OpenAIToolSet,
    openai: OpenAI
  ): Promise<UnifiedToolResponse> {
    // Fall back to existing TasksPlugin logic
    const standardPlugin = new TasksPlugin();
    return await standardPlugin.processMessage(message, userId, context, activeConnection, composio, openai);
  }
}
```

### **Implementation Steps Summary**

#### **Phase 1: Foundation (Week 1)**
1. ‚úÖ **Create ConversationManager** - Core brain memory system
2. ‚úÖ **Add brain memory schemas** - Extend existing Zod types  
3. ‚úÖ **Integrate with SimpleSMSAI** - Store SMS conversations in memory
4. ‚úÖ **Basic memory retrieval** - Working memory + episodic memory

#### **Phase 2: Composio Integration (Week 2)**
1. **Enhance plugins with BrainEnhancedPlugin base class**
2. **Memory-enhanced tool parameter enhancement**
3. **Store Composio results in brain memory**
4. **Test with Tasks plugin first, then Calendar**

#### **Phase 3: Chat Integration (Week 3)**
1. **Add chat message storage to brain memory**
2. **Real-time memory context for WebSocket messages**
3. **Cross-channel memory (SMS ‚Üî Chat)**
4. **Group chat participant memory**

#### **Phase 4: Advanced Brain Features (Week 4)**
1. **Memory consolidation background process**
2. **Concept activation spreading**
3. **Memory decay and forgetting**
4. **Semantic concept learning from tool usage**

### **Key Integration Points**

#### **1. SimpleSMSAI Integration**
```typescript
// Minimal changes to existing processMessage method
const brainMemoryContext = await conversationManager.getBrainMemoryContext(userId, message, 'sms', phoneNumber);
context.brainMemoryContext = brainMemoryContext; // Add to execution context
```

#### **2. UnifiedGoogleManager Integration**
```typescript
// Enhance existing processMessage method
if (context.brainMemoryContext) {
  // Use memory-enhanced plugins
  const enhancedPlugin = new BrainEnhancedTasksPlugin(conversationManager);
} else {
  // Fallback to standard plugins
  const standardPlugin = this.plugins.get(serviceType);
}
```

#### **3. Composio Tool Enhancement**
```typescript
// Instead of direct composio.client.actions.execute()
const memoryResult = await conversationManager.executeComposioToolWithMemory(
  userId, toolCall, composio, brainMemoryContext, channel, sourceId
);
```

### **Memory-Enhanced User Experience**

With this implementation, users will experience:

1. **Context Awareness**: "I see you mentioned a similar task yesterday..."
2. **Smart Defaults**: Calendar events get better descriptions based on conversation history
3. **Reduced Repetition**: System remembers preferences and patterns
4. **Cross-Channel Memory**: SMS and chat conversations inform each other
5. **Learning**: System gets better over time by learning from interactions

### **Testing Strategy**

1. **Unit Tests**: Test individual memory functions
2. **Integration Tests**: Test SMS ‚Üí Memory ‚Üí Composio ‚Üí Response flow
3. **Memory Tests**: Test consolidation, decay, and retrieval
4. **Performance Tests**: Ensure memory queries don't slow down responses
5. **User Tests**: Validate that memory actually improves user experience

This complete implementation creates a truly brain-like AI that:
- **Remembers** conversations across channels
- **Learns** from interactions
- **Makes connections** between related concepts
- **Enhances** Composio tool usage with memory context
- **Provides context-aware** responses

The AI now has a "memory" that grows and improves over time, just like a human brain! üß†‚ú®üöÄ

## ‚è∞ **TIME-BASED WORKING MEMORY ENHANCEMENT**

### **3-Week Memory Window Strategy**

Our enhanced brain memory system now uses a sophisticated **time-based working memory cache** that mimics how humans think about time:

```typescript
// Working Memory Time Windows
- Previous Week: Context from past decisions and conversations
- Current Week: Active ongoing conversations and tasks  
- Next Week: Planned events and future context
- Recently Modified: Any nodes updated in last 2 hours (pulled back into memory)
```

### **How It Works**

#### **1. Time-Based Memory Retrieval**
```cypher
// Neo4j Query: 3-Week Time Window
MATCH (user:User {id: $userId})-[:OWNS]->(msg:ChatMessage)
WHERE msg.timestamp >= datetime() - duration({days: 21})
AND msg.timestamp <= datetime() + duration({days: 7})

// Categorize by week
WITH msg, 
     CASE 
       WHEN msg.timestamp < datetime() - duration({days: 7}) THEN 'previous'
       WHEN msg.timestamp >= datetime() - duration({days: 7}) AND msg.timestamp < datetime() THEN 'current'  
       WHEN msg.timestamp >= datetime() THEN 'next'
     END as weekCategory
```

#### **2. Recently Modified Node Detection**
```cypher
// Pull Recently Modified Nodes Back Into Working Memory
MATCH (user:User {id: $userId})-[:OWNS]->(msg:ChatMessage)
WHERE msg.last_modified > datetime() - duration({hours: 2}) OR
      EXISTS((msg)-[:MENTIONS]->(concept:Concept) WHERE concept.last_mentioned > datetime() - duration({hours: 2})) OR
      EXISTS((msg)-[:HAS_TAG]->(tag:Tag) WHERE tag.last_used > datetime() - duration({hours: 2}))
```

#### **3. Automatic Memory Updates**
```typescript
// When concepts/tags are added, nodes are pulled back into working memory
await session.run(`
  MATCH (msg:ChatMessage {id: $messageId})
  SET msg.last_modified = datetime(),
      msg.modification_reason = 'concept_linked'
`);
```

### **Brain-Like Memory Strength Calculation**

```typescript
const memoryStrength = {
  recentMessages: 20%,        // Immediate context (last 2 hours)
  timeWindow: 15%,           // 3-week distributed memory
  recentlyModified: 15%,     // Recently updated nodes
  episodicMemory: 30%,       // Long-term conversation threads
  semanticMemory: 20%,       // Concept networks
  balanceBonus: 10%          // Bonus for good time distribution
};
```

### **Enhanced User Experience**

#### **Previous Week Context**
- *"I remember you mentioned wanting to schedule that meeting last week..."*
- References past decisions and conversations
- Learns from previous patterns

#### **Current Week Focus**  
- *"Based on our conversation earlier this week about tasks..."*
- Maintains active conversation threads
- Tracks ongoing projects and goals

#### **Next Week Planning**
- *"I see you have that event planned for next Tuesday..."*
- Incorporates future context into decisions
- Helps with proactive planning

#### **Recently Modified Intelligence**
- *"I noticed we just added a new tag to that conversation..."*
- Pulls related conversations back into active memory
- Dynamic context based on recent activity

### **Memory Cache Performance**

```typescript
// Working Memory Statistics Example
[BrainMemory] üìÖ Time-based working memory: 
  Previous(12) Current(18) Next(5) Modified(3)

[BrainMemory] üí™ Memory Strength: 
  Recent(0.18) TimeWindow(0.12) Modified(0.09) Balance(0.08) = 0.84
```

### **Implementation Benefits**

1. **üß† More Human-Like**: Thinks in weeks like humans do
2. **‚ö° Performance**: Efficient time-based queries instead of scanning all history
3. **üîÑ Dynamic**: Recently modified nodes automatically return to working memory
4. **üìä Balanced**: Rewards good distribution across time periods
5. **üéØ Contextual**: Previous/current/next week provides rich temporal context

### **Auto-Memory Management**

The system automatically manages memory lifecycles:

- **Fresh memories** ‚Üí Working memory (3-week window)
- **Active modifications** ‚Üí Pulled back into working memory  
- **Balanced distribution** ‚Üí Bonus memory strength
- **Old memories** ‚Üí Archived but accessible via episodic search
- **Related activations** ‚Üí Associated nodes updated with `last_modified`

This creates a **dynamic, intelligent memory system** that:
- ‚úÖ **Remembers** conversations across realistic time frames
- ‚úÖ **Reactivates** relevant memories when context changes  
- ‚úÖ **Balances** recent vs. historical context
- ‚úÖ **Learns** from modification patterns
- ‚úÖ **Scales** efficiently with large conversation histories

The AI now thinks with **temporal intelligence** - understanding not just what was said, but **when** it was said and **when** it was last relevant! üß†‚è∞‚ú®

## üöÄ **PRODUCTION DEPLOYMENT CONFIGURATION**

### **AuraDB Production Setup (Using Your Credentials)**

```typescript
// apps/omnii_mcp/src/config/neo4j.config.ts
import neo4j, { Driver, Config } from 'neo4j-driver';

export const createNeo4jDriver = (): Driver => {
  const config: Config = {
    database: process.env.NEO4J_DATABASE, // "neo4j"
    encrypted: true, // Required for AuraDB
    trust: 'TRUST_SYSTEM_CA_SIGNED_CERTIFICATES',
    
    // Production Connection Pool Settings
    maxConnectionLifetime: 30 * 60 * 1000, // 30 minutes
    maxConnectionPoolSize: 50, // Handle high concurrency
    connectionAcquisitionTimeout: 60000, // 60 seconds
    maxTransactionRetryTime: 30000, // 30 seconds for retries
    
    // Performance Optimizations
    fetchSize: 1000, // Fetch more records per round trip
    disableLosslessIntegers: true, // Use JavaScript numbers for integers
    
    // Logging Configuration
    logging: {
      level: process.env.NODE_ENV === 'production' ? 'warn' : 'debug',
      logger: (level: string, message: string) => {
        const timestamp = new Date().toISOString();
        console.log(`[${timestamp}] [Neo4j-${level.toUpperCase()}] ${message}`);
      }
    },
    
    // Resolver for DNS resolution
    resolver: (address: string) => Promise.resolve([address]),
  };

  const driver = neo4j.driver(
    process.env.NEO4J_URI!, // neo4j+s://d066c29d.databases.neo4j.io
    neo4j.auth.basic(
      process.env.NEO4J_USER!, // neo4j  
      process.env.NEO4J_PASSWORD! // _o0JebFPkSb51lSjC7BUqdsvDhD4e5bYGFV1uoVv3QE
    ),
    config
  );

  // Connection health check
  driver.verifyConnectivity()
    .then(() => {
      console.log('‚úÖ Neo4j AuraDB connection verified successfully');
      console.log(`üîó Connected to: ${process.env.NEO4J_URI?.split('@')[1]}`);
      console.log(`üíæ Database: ${process.env.NEO4J_DATABASE}`);
    })
    .catch(err => {
      console.error('‚ùå Neo4j AuraDB connection failed:', err);
      throw new Error(`Neo4j connection failed: ${err.message}`);
    });

  return driver;
};

// Singleton driver instance
let driverInstance: Driver | null = null;

export const getNeo4jDriver = (): Driver => {
  if (!driverInstance) {
    driverInstance = createNeo4jDriver();
  }
  return driverInstance;
};

// Graceful shutdown
export const closeNeo4jDriver = async (): Promise<void> => {
  if (driverInstance) {
    await driverInstance.close();
    driverInstance = null;
    console.log('üîå Neo4j driver closed gracefully');
  }
};
```

### **Environment Configuration Validation**

```typescript
// apps/omnii_mcp/src/config/env.validation.ts
import { z } from 'zod';

const Neo4jConfigSchema = z.object({
  // Neo4j AuraDB Configuration
  NEO4J_URI: z.string().startsWith('neo4j+s://').describe('AuraDB connection URI'),
  NEO4J_USER: z.string().min(1).describe('Neo4j username'),
  NEO4J_PASSWORD: z.string().min(1).describe('Neo4j password'),
  NEO4J_DATABASE: z.string().default('neo4j').describe('Neo4j database name'),
  
  // Brain Memory Configuration
  MEMORY_BRIDGE_ENABLED: z.boolean().default(true),
  MEMORY_CONSOLIDATION_INTERVAL: z.number().int().default(86400), // 24 hours
  CONCEPT_DISCOVERY_THRESHOLD: z.number().min(0).max(1).default(0.7),
  TOOL_RECOMMENDATION_LIMIT: z.number().int().default(5),
  CONTEXT_ENRICHMENT_ENABLED: z.boolean().default(true),
  PREDICTIVE_CHAINING_ENABLED: z.boolean().default(true),
  
  // Performance Configuration  
  MEMORY_CACHE_TTL: z.number().int().default(3600), // 1 hour
  CONTEXT_RETRIEVAL_TIMEOUT: z.number().int().default(200), // milliseconds
  PATTERN_ANALYSIS_BATCH_SIZE: z.number().int().default(100),
  
  // Integration Keys
  OPENAI_API_KEY: z.string().startsWith('sk-').describe('OpenAI API key'),
  COMPOSIO_API_KEY: z.string().min(1).describe('Composio API key'),
  ANTHROPIC_API_KEY: z.string().startsWith('sk-ant-').describe('Anthropic API key'),
  
  // Redis Configuration
  REDIS_URL: z.string().url().describe('Redis connection URL'),
  
  // Production Environment
  NODE_ENV: z.enum(['development', 'production', 'test']).default('production'),
  PORT: z.string().default('8000'),
  BASE_URL: z.string().url().describe('Base application URL'),
});

export type Neo4jConfig = z.infer<typeof Neo4jConfigSchema>;

export const validateEnvironment = (): Neo4jConfig => {
  try {
    const config = Neo4jConfigSchema.parse(process.env);
    console.log('‚úÖ Environment configuration validated successfully');
    return config;
  } catch (error) {
    console.error('‚ùå Environment configuration validation failed:', error);
    throw new Error('Invalid environment configuration');
  }
};

// Export validated config
export const config = validateEnvironment();
```

### **Production Memory Service**

```typescript
// apps/omnii_mcp/src/services/memory/production-brain-service.ts
import { Redis } from 'ioredis';
import { BrainConversationManager } from './brain-conversation-manager';
import { getNeo4jDriver, closeNeo4jDriver } from '../../config/neo4j.config';
import { config } from '../../config/env.validation';
import { BrainMemoryContext } from '../../types/brain-memory-schemas';

export class ProductionBrainService {
  private conversationManager: BrainConversationManager;
  private redis: Redis;
  private consolidationInterval: NodeJS.Timeout | null = null;

  constructor() {
    // Initialize with production Neo4j driver
    this.conversationManager = new BrainConversationManager();
    
    // Initialize Redis for caching
    this.redis = new Redis(process.env.REDIS_URL!, {
      retryDelayOnFailover: 100,
      maxRetriesPerRequest: 3,
      lazyConnect: true,
      connectTimeout: 60000,
      commandTimeout: 5000
    });

    // Start background consolidation if enabled
    if (config.MEMORY_BRIDGE_ENABLED) {
      this.startMemoryConsolidation();
    }

    console.log('üß† ProductionBrainService initialized');
    console.log(`üîÑ Memory consolidation: ${config.MEMORY_BRIDGE_ENABLED ? 'ENABLED' : 'DISABLED'}`);
    console.log(`‚è±Ô∏è Consolidation interval: ${config.MEMORY_CONSOLIDATION_INTERVAL}s`);
  }

  /**
   * Production-ready memory retrieval with timeout and fallback
   */
  async getBrainMemoryContext(
    userId: string,
    currentMessage: string,
    channel: 'sms' | 'chat',
    sourceIdentifier: string,
    options: {
      timeoutMs?: number;
      fallbackToCache?: boolean;
      prioritizeRecent?: boolean;
    } = {}
  ): Promise<BrainMemoryContext> {
    const { 
      timeoutMs = config.CONTEXT_RETRIEVAL_TIMEOUT,
      fallbackToCache = true,
      prioritizeRecent = channel === 'chat'
    } = options;

    const startTime = Date.now();
    
    try {
      // Production timeout wrapper
      const memoryPromise = this.conversationManager.getBrainMemoryContext(
        userId,
        currentMessage,
        channel,
        sourceIdentifier,
        {
          workingMemorySize: prioritizeRecent ? 10 : 7,
          includeGoogleServices: true
        }
      );

      const timeoutPromise = new Promise<never>((_, reject) => {
        setTimeout(() => reject(new Error('Memory retrieval timeout')), timeoutMs);
      });

      const memoryContext = await Promise.race([memoryPromise, timeoutPromise]);
      
      const retrievalTime = Date.now() - startTime;
      console.log(`[ProductionBrain] ‚ö° Memory retrieved in ${retrievalTime}ms`);
      
      // Performance monitoring
      if (retrievalTime > timeoutMs * 0.8) {
        console.warn(`[ProductionBrain] ‚ö†Ô∏è Slow memory retrieval: ${retrievalTime}ms (threshold: ${timeoutMs}ms)`);
      }

      return memoryContext;

    } catch (error) {
      const retrievalTime = Date.now() - startTime;
      console.error(`[ProductionBrain] ‚ùå Memory retrieval failed after ${retrievalTime}ms:`, error);

      if (fallbackToCache) {
        return await this.getFallbackMemoryContext(userId, channel, sourceIdentifier);
      }

      throw error;
    }
  }

  /**
   * Fallback to cached or minimal memory context
   */
  private async getFallbackMemoryContext(
    userId: string,
    channel: 'sms' | 'chat',
    sourceIdentifier: string
  ): Promise<BrainMemoryContext> {
    console.log(`[ProductionBrain] üîÑ Using fallback memory context`);
    
    // Try Redis cache first
    const cacheKey = `fallback_memory:${userId}:${channel}:${sourceIdentifier}`;
    const cached = await this.redis.get(cacheKey);
    
    if (cached) {
      console.log(`[ProductionBrain] üì¶ Using cached fallback memory`);
      return JSON.parse(cached);
    }

    // Minimal memory context
    const minimal: BrainMemoryContext = {
      working_memory: {
        recent_messages: [],
        time_window_messages: [],
        recently_modified_messages: [],
        active_concepts: [],
        current_intent: undefined,
        time_window_stats: {
          previous_week_count: 0,
          current_week_count: 0,
          next_week_count: 0,
          recently_modified_count: 0
        }
      },
      episodic_memory: {
        conversation_threads: [],
        related_episodes: []
      },
      semantic_memory: {
        activated_concepts: [],
        concept_associations: []
      },
      consolidation_metadata: {
        retrieval_timestamp: new Date().toISOString(),
        memory_strength: 0.1,
        context_channels: [channel],
        memory_age_hours: 0,
        consolidation_score: 0.0,
        working_memory_limit: 7,
        episodic_window_hours: 168,
        semantic_activation_threshold: 0.3
      }
    };

    // Cache the minimal context
    await this.redis.setex(cacheKey, 300, JSON.stringify(minimal)); // 5 minutes cache
    
    return minimal;
  }

  /**
   * Background memory consolidation process
   */
  private startMemoryConsolidation(): void {
    console.log(`[ProductionBrain] üîÑ Starting memory consolidation (interval: ${config.MEMORY_CONSOLIDATION_INTERVAL}s)`);
    
    this.consolidationInterval = setInterval(async () => {
      try {
        console.log(`[ProductionBrain] üß† Running memory consolidation cycle`);
        
        // Consolidate memories older than 24 hours
        await this.conversationManager.consolidateMemories({
          olderThanHours: 24,
          batchSize: config.PATTERN_ANALYSIS_BATCH_SIZE,
          maxProcessingTime: 300000 // 5 minutes max
        });
        
        // Update concept activation strengths
        await this.conversationManager.updateSemanticActivation({
          threshold: config.CONCEPT_DISCOVERY_THRESHOLD,
          batchSize: config.PATTERN_ANALYSIS_BATCH_SIZE
        });

        console.log(`[ProductionBrain] ‚úÖ Memory consolidation cycle completed`);
        
      } catch (error) {
        console.error(`[ProductionBrain] ‚ùå Memory consolidation failed:`, error);
      }
    }, config.MEMORY_CONSOLIDATION_INTERVAL * 1000);
  }

  /**
   * Graceful shutdown
   */
  async shutdown(): Promise<void> {
    console.log(`[ProductionBrain] üîå Shutting down brain service...`);
    
    // Stop consolidation
    if (this.consolidationInterval) {
      clearInterval(this.consolidationInterval);
      this.consolidationInterval = null;
    }

    // Close connections
    await this.redis.quit();
    await closeNeo4jDriver();
    
    console.log(`[ProductionBrain] ‚úÖ Brain service shutdown complete`);
  }

  /**
   * Health check for monitoring
   */
  async healthCheck(): Promise<{
    status: 'healthy' | 'degraded' | 'unhealthy';
    neo4j: boolean;
    redis: boolean;
    memory_bridge: boolean;
    metrics: {
      total_conversations: number;
      active_concepts: number;
      memory_strength_avg: number;
    };
  }> {
    try {
      // Test Neo4j connection
      const neo4jHealthy = await this.testNeo4jConnection();
      
      // Test Redis connection  
      const redisHealthy = await this.testRedisConnection();
      
      // Get brain metrics
      const metrics = await this.getBrainMetrics();
      
      const status = neo4jHealthy && redisHealthy ? 'healthy' : 
                    (neo4jHealthy || redisHealthy) ? 'degraded' : 'unhealthy';

      return {
        status,
        neo4j: neo4jHealthy,
        redis: redisHealthy,
        memory_bridge: config.MEMORY_BRIDGE_ENABLED,
        metrics
      };
      
    } catch (error) {
      console.error(`[ProductionBrain] ‚ùå Health check failed:`, error);
      return {
        status: 'unhealthy',
        neo4j: false,
        redis: false,
        memory_bridge: false,
        metrics: {
          total_conversations: 0,
          active_concepts: 0,
          memory_strength_avg: 0
        }
      };
    }
  }

  private async testNeo4jConnection(): Promise<boolean> {
    try {
      const driver = getNeo4jDriver();
      await driver.verifyConnectivity();
      return true;
    } catch {
      return false;
    }
  }

  private async testRedisConnection(): Promise<boolean> {  
    try {
      await this.redis.ping();
      return true;
    } catch {
      return false;
    }
  }

  private async getBrainMetrics(): Promise<{
    total_conversations: number;
    active_concepts: number;
    memory_strength_avg: number;
  }> {
    // Implement metrics collection from Neo4j
    return {
      total_conversations: 0,
      active_concepts: 0,
      memory_strength_avg: 0
    };
  }
}

// Export singleton instance
export const productionBrainService = new ProductionBrainService();
```

## üîí **SECURITY & MONITORING**

### **Security Configuration**

```typescript
// apps/omnii_mcp/src/middleware/brain-security.middleware.ts
import { Request, Response, NextFunction } from 'express';
import rateLimit from 'express-rate-limit';
import { z } from 'zod';

// Rate limiting for memory operations
export const memoryRateLimit = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // limit each IP to 100 memory requests per windowMs
  message: 'Too many memory requests from this IP',
  standardHeaders: true,
  legacyHeaders: false,
});

// Input validation for brain operations
const BrainRequestSchema = z.object({
  userId: z.string().uuid(),
  message: z.string().max(10000),
  channel: z.enum(['sms', 'chat']),
  sourceIdentifier: z.string().max(100)
});

export const validateBrainRequest = (req: Request, res: Response, next: NextFunction) => {
  try {
    const validated = BrainRequestSchema.parse(req.body);
    req.body = validated;
    next();
  } catch (error) {
    res.status(400).json({ error: 'Invalid brain request format' });
  }
};

// Memory access authorization
export const authorizeMemoryAccess = async (req: Request, res: Response, next: NextFunction) => {
  try {
    const { userId } = req.body;
    const authUserId = req.headers['x-user-id'];
    
    if (userId !== authUserId) {
      return res.status(403).json({ error: 'Unauthorized memory access' });
    }
    
    next();
  } catch (error) {
    res.status(401).json({ error: 'Authentication required' });
  }
};
```

### **Production Monitoring**

```typescript
// apps/omnii_mcp/src/routes/brain-monitoring.routes.ts
import { Router } from 'express';
import { productionBrainService } from '../services/memory/production-brain-service';

const router = Router();

// Health check endpoint
router.get('/health', async (req, res) => {
  try {
    const health = await productionBrainService.healthCheck();
    const statusCode = health.status === 'healthy' ? 200 : 
                       health.status === 'degraded' ? 206 : 503;
    
    res.status(statusCode).json(health);
  } catch (error) {
    res.status(503).json({ 
      status: 'unhealthy', 
      error: error.message 
    });
  }
});

// Memory metrics endpoint
router.get('/metrics', async (req, res) => {
  try {
    const metrics = {
      timestamp: new Date().toISOString(),
      memory: {
        consolidation_enabled: process.env.MEMORY_BRIDGE_ENABLED === 'true',
        cache_ttl: process.env.MEMORY_CACHE_TTL,
        context_timeout: process.env.CONTEXT_RETRIEVAL_TIMEOUT
      },
      neo4j: {
        uri: process.env.NEO4J_URI?.split('@')[1],
        database: process.env.NEO4J_DATABASE,
        environment: process.env.NODE_ENV
      }
    };
    
    res.json(metrics);
  } catch (error) {
    res.status(500).json({ error: 'Metrics collection failed' });
  }
});

export default router;
```

## üöÄ **NEXT IMPLEMENTATION PHASES**

### **Phase 5: Advanced Brain Features (Week 5-6)**

#### **Memory Decay Implementation**
```typescript
// Automatic memory decay based on access patterns
export class MemoryDecayManager {
  async processMemoryDecay(): Promise<void> {
    // Reduce importance scores over time
    // Archive unused memories
    // Strengthen frequently accessed memories
  }
}
```

#### **Predictive Memory Loading**
```typescript
// Pre-load likely needed memory based on patterns
export class PredictiveMemoryLoader {
  async preloadLikelyMemories(userId: string, context: any): Promise<void> {
    // Analyze conversation patterns
    // Pre-cache likely needed memories
    // Use machine learning for prediction
  }
}
```

### **Phase 6: Advanced Analytics (Week 7-8)**

#### **Memory Pattern Analysis**
```typescript
// Analyze user conversation patterns for insights
export class MemoryAnalyticsService {
  async analyzeConversationPatterns(userId: string): Promise<{
    preferred_communication_times: string[];
    common_topics: string[];
    tool_usage_patterns: Record<string, number>;
    memory_effectiveness_score: number;
  }> {
    // Deep analysis of memory usage patterns
    // User behavior insights
    // Tool recommendation optimization
  }
}
```

### **Phase 7: Multi-User & Collaboration (Week 9-10)**

#### **Shared Memory Spaces**
```typescript
// Enable shared memories between users (teams, families)
export class SharedMemoryManager {
  async createSharedMemorySpace(users: string[], permissions: any): Promise<string> {
    // Cross-user memory sharing
    // Permission management
    // Collaborative AI memories
  }
}
```

### **Production Deployment Checklist**

- ‚úÖ **AuraDB Connection**: Production Neo4j configured  
- ‚úÖ **Environment Validation**: All env vars validated
- ‚úÖ **Rate Limiting**: Memory operation limits
- ‚úÖ **Input Validation**: Secure request validation  
- ‚úÖ **Error Handling**: Graceful fallbacks
- ‚úÖ **Health Monitoring**: Production health checks
- ‚úÖ **Performance Optimization**: Connection pooling, caching
- ‚úÖ **Security**: Authorization and authentication
- üîÑ **Load Testing**: Memory system under load
- üîÑ **Backup Strategy**: Neo4j backup procedures
- üîÑ **Scaling Strategy**: Horizontal scaling plan
- üîÑ **Monitoring Alerts**: Production alerting setup

### **Ready for Implementation**

The brain memory system is now **production-ready** with:

1. **Real AuraDB Connection** - Your actual Neo4j credentials
2. **Production Configuration** - Optimized for scale and performance  
3. **Security Hardening** - Rate limiting, validation, authorization
4. **Monitoring & Health Checks** - Production observability
5. **Graceful Fallbacks** - System resilience
6. **Memory Consolidation** - Background brain processes
7. **Performance Optimization** - Efficient memory retrieval

üß† **The AI now has a production-grade brain that learns, remembers, and grows smarter over time!** ‚ú®üöÄ

## üéØ **IMMEDIATE NEXT STEPS (Ready to Implement)**

### **Step 1: Create Foundation Files (Day 1)**

```bash
# Create the core configuration files
mkdir -p apps/omnii_mcp/src/config
mkdir -p apps/omnii_mcp/src/services/memory
mkdir -p apps/omnii_mcp/src/middleware
mkdir -p apps/omnii_mcp/src/routes

# Files to create:
# - apps/omnii_mcp/src/config/neo4j.config.ts
# - apps/omnii_mcp/src/config/env.validation.ts
# - apps/omnii_mcp/src/services/memory/production-brain-service.ts
# - apps/omnii_mcp/src/middleware/brain-security.middleware.ts
# - apps/omnii_mcp/src/routes/brain-monitoring.routes.ts
```

### **Step 2: Install Required Dependencies (Day 1)**

```bash
cd apps/omnii_mcp
pnpm add neo4j-driver ioredis express-rate-limit
pnpm add -D @types/express
```

### **Step 3: Test AuraDB Connection (Day 1)**

```typescript
// Quick connection test script: apps/omnii_mcp/scripts/test-neo4j.ts
import { createNeo4jDriver } from '../src/config/neo4j.config';

async function testConnection() {
  const driver = createNeo4jDriver();
  
  try {
    await driver.verifyConnectivity();
    console.log('‚úÖ AuraDB connection successful!');
    
    const session = driver.session();
    const result = await session.run('RETURN "Hello Neo4j!" as message');
    console.log('üìù Test query result:', result.records[0].get('message'));
    await session.close();
    
  } catch (error) {
    console.error('‚ùå Connection failed:', error);
  } finally {
    await driver.close();
  }
}

testConnection();
```

### **Step 4: Update Existing SimpleSMSAI (Day 2)**

```typescript
// Minimal integration in apps/omnii_mcp/src/services/simple-sms-ai.ts
import { productionBrainService } from './memory/production-brain-service';

export class SimpleSMSAI {
  // ... existing code ...

  async processMessage(
    message: string,
    phoneNumber: string,
    userId: string,
    isIncoming: boolean = true
  ): Promise<any> {
    
    // NEW: Get brain memory context first
    const brainMemoryContext = await productionBrainService.getBrainMemoryContext(
      userId,
      message,
      'sms',
      phoneNumber
    );

    // Store message in brain memory
    await productionBrainService.conversationManager.storeSMSConversation({
      user_id: userId,
      content: message,
      phone_number: phoneNumber,
      is_incoming: isIncoming
    });

    // Add brain context to execution context
    const enhancedContext = {
      ...existingContext,
      brainMemoryContext: brainMemoryContext,
      communicationChannel: 'sms' as const
    };

    // ... rest of existing logic with enhanced context ...
  }
}
```

### **Step 5: Add Health Check Route (Day 2)**

```typescript
// Add to apps/omnii_mcp/src/routes/index.ts
import brainMonitoringRoutes from './brain-monitoring.routes';

app.use('/api/brain', brainMonitoringRoutes);

// Test endpoints:
// GET /api/brain/health - Health check
// GET /api/brain/metrics - Memory metrics
```

### **Step 6: Verify Environment Variables (Day 2)**

```bash
# Verify your environment is properly configured
node -e "
const config = require('./src/config/env.validation').validateEnvironment();
console.log('‚úÖ Environment validated successfully');
console.log('Neo4j URI:', config.NEO4J_URI.split('@')[1]);
console.log('Memory Bridge:', config.MEMORY_BRIDGE_ENABLED);
"
```

### **Step 7: Test Memory Storage & Retrieval (Day 3)**

```typescript
// Create test script: apps/omnii_mcp/scripts/test-brain-memory.ts
import { productionBrainService } from '../src/services/memory/production-brain-service';

async function testBrainMemory() {
  const testUserId = 'test-user-123';
  const testPhone = '+1234567890';
  
  // Store a test SMS conversation
  await productionBrainService.conversationManager.storeSMSConversation({
    user_id: testUserId,
    content: 'Hello, I need help with my calendar',
    phone_number: testPhone,
    is_incoming: true
  });

  // Retrieve brain memory context
  const memoryContext = await productionBrainService.getBrainMemoryContext(
    testUserId,
    'What was I talking about earlier?',
    'sms',
    testPhone
  );

  console.log('üß† Working Memory:', memoryContext.working_memory.recent_messages.length);
  console.log('üß† Memory Strength:', memoryContext.consolidation_metadata.memory_strength);
  
  console.log('‚úÖ Brain memory test completed!');
}

testBrainMemory().catch(console.error);
```

### **Quick Implementation Priority**

1. **üöÄ HIGH PRIORITY** (Week 1):
   - ‚úÖ Create config files with your AuraDB credentials
   - ‚úÖ Test Neo4j connection  
   - ‚úÖ Add brain memory to SMS processing
   - ‚úÖ Basic memory storage and retrieval

2. **‚ö° MEDIUM PRIORITY** (Week 2):
   - Add brain memory to Chat processing
   - Implement Composio + memory integration
   - Add health monitoring endpoints
   - Test with real conversations

3. **üéØ LOW PRIORITY** (Week 3+):
   - Memory consolidation background process
   - Advanced brain features (decay, prediction)
   - Analytics and pattern recognition
   - Multi-user collaboration

### **Testing Commands**

```bash
# Test Neo4j connection
pnpm run test:neo4j

# Test brain memory storage
pnpm run test:brain-memory

# Check health endpoint
curl http://localhost:8000/api/brain/health

# Check metrics
curl http://localhost:8000/api/brain/metrics

# Monitor logs
tail -f logs/brain-memory.log
```

### **Expected Results**

After implementing the foundation (Week 1), you should see:

```
üß† BrainConversationManager initialized with AuraDB connection
üîó Connected to: d066c29d.databases.neo4j.io
üíæ Database: neo4j
‚öôÔ∏è Environment: production
üß† ProductionBrainService initialized
üîÑ Memory consolidation: ENABLED
‚è±Ô∏è Consolidation interval: 86400s

[BrainMemory] üíæ Storing SMS conversation (hippocampus-like processing) for user: xxx
[BrainMemory] üß† Building brain-like memory context for sms:+1234567890
[BrainMemory] üìÖ Time-based working memory: Previous(0) Current(1) Next(0) Modified(0)
[ProductionBrain] ‚ö° Memory retrieved in 45ms
[BrainMemory] ‚úÖ Built brain-like memory context: 1 working + 0 episodic + 0 semantic, strength: 0.20
```

**üéâ Ready to make your AI have a real brain!** Start with Step 1 and you'll have a thinking, remembering AI by end of week! üß†‚ú®
