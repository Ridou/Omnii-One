---
description: Agent Swarm webhook integration implementation guide for application developers
globs:
  - "*.ts"
  - "*.tsx"
  - "*.js"
  - "*.jsx"
alwaysApply: false
---

# ü§ñ n8n Agent Swarm Integration - Omnii Implementation Plan

## üìã Executive Summary

This document provides a comprehensive implementation plan for integrating the deployed n8n Agent Swarm into the omnii WebSocket chat system. The integration leverages the existing sophisticated action planning architecture while adding powerful AI automation capabilities.

**Integration Strategy**: Hybrid routing that intelligently determines when to use n8n agents for complex automation vs. the current system for simple operations.

**Live n8n Endpoint**: `https://omnii-agent-swarm-production.up.railway.app/webhook/agent-input`
**Test User ID**: `cd9bdc60-35af-4bb6-b87e-1932e96fb354`

## üèóÔ∏è Current Omnii Architecture Analysis

### Existing Message Flow
```
Mobile App ‚Üí WebSocket ‚Üí EnhancedWebSocketHandler ‚Üí ActionPlanner ‚Üí StepExecutorFactory ‚Üí Specific Executors
                                                                                        ‚îú‚îÄ‚îÄ EmailStepExecutor
                                                                                        ‚îú‚îÄ‚îÄ CalendarStepExecutor  
                                                                                        ‚îú‚îÄ‚îÄ TaskStepExecutor
                                                                                        ‚îú‚îÄ‚îÄ ContactStepExecutor
                                                                                        ‚îú‚îÄ‚îÄ AnalysisStepExecutor
                                                                                        ‚îî‚îÄ‚îÄ SystemStepExecutor
```

### Current Decision Logic
1. **EnhancedWebSocketHandler** receives user message via WebSocket
2. **RDF Service** analyzes message for semantic understanding  
3. **ActionPlanner** creates step-by-step execution plan using OpenAI GPT-4o-mini
4. **StepExecutorFactory** routes steps to appropriate executors based on ActionType
5. **Individual Executors** call UnifiedGoogleManager or other integrated services
6. **Response** flows back through WebSocket to mobile app with rich UI components

### Key Architecture Strengths
- ‚úÖ **Sophisticated Action Planning**: OpenAI-powered step decomposition
- ‚úÖ **RDF Semantic Analysis**: Intent and entity recognition
- ‚úÖ **Modular Step Execution**: Clean separation of concerns
- ‚úÖ **Rich Response Handling**: UnifiedToolResponse with mobile UI components
- ‚úÖ **Context Awareness**: Brain memory integration and cached data
- ‚úÖ **Fallback Mechanisms**: Graceful degradation patterns

## üéØ n8n Integration Strategy

### Hybrid Routing Approach
Instead of replacing the current system, we'll add **intelligent routing** that determines when to use:

**n8n Agents** for:
- Complex multi-step automation requiring AI reasoning
- Web research and information gathering
- YouTube content discovery
- Cross-service workflow coordination
- Smart email composition with context awareness
- Intelligent scheduling coordination

**Current System** for:  
- Simple, direct Google API operations
- Single-step actions (list emails, create task, etc.)
- Real-time operations requiring <2s response
- Fallback when n8n is unavailable

## üìù Detailed Implementation Plan

### Phase 1: Core Integration Infrastructure

#### 1.1 **Add n8n Service Configuration**
**File**: `apps/omnii_mcp/src/config/n8n-agent.config.ts` (NEW)
```typescript
export interface N8nAgentConfig {
  baseUrl: string;
  timeout: number;
  retryAttempts: number;
  fallbackEnabled: boolean;
  enabledAgents: string[];
}

export const n8nAgentConfig: N8nAgentConfig = {
  baseUrl: process.env.N8N_AGENT_SWARM_URL || 'https://omnii-agent-swarm-production.up.railway.app',
  timeout: 600000, // 10 minutes (matches n8n timeout)
  retryAttempts: 3,
  fallbackEnabled: true,
  enabledAgents: ['email', 'calendar', 'contact', 'web', 'youtube'],
};

export class N8nConfigManager {
  static validateConfig(): boolean
  static getWebhookUrl(): string
  static isAgentEnabled(agentType: string): boolean
  static getTimeoutForOperation(operationType: string): number
}
```

#### 1.2 **Update Environment Validation**
**File**: `apps/omnii_mcp/src/config/env.validation.ts`
```typescript
// Add to Neo4jConfigSchema:
N8N_AGENT_SWARM_URL: z.string().url().default('https://omnii-agent-swarm-production.up.railway.app'),
N8N_AGENT_ENABLED: z.coerce.boolean().default(true),
N8N_AGENT_TIMEOUT: z.coerce.number().int().default(600000),
N8N_FALLBACK_ENABLED: z.coerce.boolean().default(true),
N8N_ENABLED_AGENTS: z.string().default('email,calendar,contact,web,youtube'),
```

#### 1.3 **Extend Action Planning Types**
**File**: `apps/omnii_mcp/src/types/action-planning.types.ts`
```typescript
// Add to ActionType union (line ~120):
| "n8n_agent"
| N8nAgentActionType

// New enum to add:
export enum N8nAgentActionType {
  // Email automation (enhanced beyond current EmailActionType)
  SMART_EMAIL_COMPOSE = "smart_email_compose",
  EMAIL_THREAD_ANALYSIS = "email_thread_analysis", 
  EMAIL_BULK_OPERATIONS = "email_bulk_operations",
  EMAIL_CONTEXT_SEARCH = "email_context_search",
  
  // Calendar intelligence (enhanced beyond current CalendarActionType)
  SMART_SCHEDULING = "smart_scheduling",
  MEETING_COORDINATION = "meeting_coordination",
  CALENDAR_OPTIMIZATION = "calendar_optimization",
  MULTI_PERSON_SCHEDULING = "multi_person_scheduling",
  
  // Contact intelligence (enhanced beyond current ContactActionType)
  CONTACT_ENRICHMENT = "contact_enrichment",
  RELATIONSHIP_MAPPING = "relationship_mapping",
  CONTACT_DEDUPLICATION = "contact_deduplication",
  
  // Cross-service automation (new capabilities)
  WORKFLOW_AUTOMATION = "workflow_automation",
  MULTI_SERVICE_COORDINATION = "multi_service_coordination",
  TASK_EMAIL_INTEGRATION = "task_email_integration",
  
  // Web and research (new capabilities)
  WEB_RESEARCH = "web_research",
  INFORMATION_GATHERING = "information_gathering",
  COMPETITIVE_ANALYSIS = "competitive_analysis",
  
  // YouTube content (new capabilities)  
  YOUTUBE_CONTENT_SEARCH = "youtube_content_search",
  LEARNING_PATH_CREATION = "learning_path_creation",
  VIDEO_SUMMARY_GENERATION = "video_summary_generation",
}

// Add to ResponseCategory enum (line ~10):
N8N_AGENT_RESPONSE = "n8n_agent_response",
AGENT_AUTOMATION = "agent_automation", 
WEB_RESEARCH = "web_research",
YOUTUBE_SEARCH = "youtube_search",
WORKFLOW_COORDINATION = "workflow_coordination",
```

### Phase 2: n8n Agent Client Service

#### 2.1 **Create n8n Agent Client**
**File**: `apps/omnii_mcp/src/services/integrations/n8n-agent-client.ts` (NEW)
```typescript
import { n8nAgentConfig } from '../../config/n8n-agent.config';
import { ExecutionContext } from '../../types/action-planning.types';

export interface N8nAgentRequest {
  message: string;
  user_id: string;
  agent_type?: 'email' | 'calendar' | 'contact' | 'web' | 'youtube' | 'auto';
  context?: {
    userTimezone?: string;
    localDatetime?: string;
    entities?: any[];
    rdfInsights?: any;
    executionContext?: ExecutionContext;
  };
  metadata?: {
    requestId?: string;
    priority?: 'low' | 'normal' | 'high';
    timeout?: number;
  };
}

export interface N8nAgentResponse {
  success: boolean;
  agent: string;
  action: string;
  result: any;
  execution_time: string;
  error?: string;
  metadata?: {
    operationId?: string;
    tokensUsed?: number;
    confidence?: number;
  };
}

export class N8nAgentClient {
  private baseUrl: string;
  private timeout: number;
  private retryAttempts: number;

  constructor() {
    this.baseUrl = n8nAgentConfig.baseUrl;
    this.timeout = n8nAgentConfig.timeout;
    this.retryAttempts = n8nAgentConfig.retryAttempts;
  }

  async sendToAgentSwarm(request: N8nAgentRequest): Promise<N8nAgentResponse> {
    console.log(`[N8nAgentClient] ü§ñ Sending request to Agent Swarm: ${request.message.substring(0, 50)}...`);
    
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), this.timeout);
    
    try {
      const response = await fetch(`${this.baseUrl}/webhook/agent-input`, {
        method: 'POST',
        headers: { 
          'Content-Type': 'application/json',
          'User-Agent': 'omnii-mcp/1.0.0',
        },
        body: JSON.stringify(request),
        signal: controller.signal
      });
      
      clearTimeout(timeoutId);
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      
      const result = await response.json();
      console.log(`[N8nAgentClient] ‚úÖ Agent Swarm response received from ${result.agent}`);
      
      return this.parseAgentResponse(result);
    } catch (error) {
      clearTimeout(timeoutId);
      console.error(`[N8nAgentClient] ‚ùå Agent Swarm request failed:`, error);
      
      if (error.name === 'AbortError') {
        throw new Error('n8n Agent request timeout after 10 minutes');
      }
      
      throw error;
    }
  }

  async executeWithRetry(request: N8nAgentRequest): Promise<N8nAgentResponse> {
    let lastError;
    
    for (let i = 0; i < this.retryAttempts; i++) {
      try {
        return await this.sendToAgentSwarm(request);
      } catch (error) {
        lastError = error;
        
        // Don't retry on auth errors
        if (error.message.includes('401') || error.message.includes('403')) {
          throw error;
        }
        
        // Don't retry on user input errors
        if (error.message.includes('400')) {
          throw error;
        }
        
        // Exponential backoff for retryable errors
        if (i < this.retryAttempts - 1) {
          const delay = Math.pow(2, i) * 1000; // 1s, 2s, 4s
          console.log(`[N8nAgentClient] ‚è≥ Retrying in ${delay}ms (attempt ${i + 1}/${this.retryAttempts})`);
          await new Promise(r => setTimeout(r, delay));
        }
      }
    }
    
    throw lastError;
  }

  private parseAgentResponse(response: any): N8nAgentResponse {
    // Ensure response matches expected n8n agent format
    return {
      success: response.success || false,
      agent: response.agent || 'Unknown Agent',
      action: response.action || 'Unknown Action', 
      result: response.result || {},
      execution_time: response.execution_time || '0s',
      error: response.error,
      metadata: response.metadata || {}
    };
  }

  isHealthy(): Promise<boolean> {
    // Health check method for monitoring
  }
}

// Singleton instance
export const n8nAgentClient = new N8nAgentClient();
```

#### 2.2 **Create n8n Agent Step Executor**
**File**: `apps/omnii_mcp/src/services/action-planner/step-executors/n8n-agent-executor.ts` (NEW)
```typescript
import { BaseStepExecutor } from "./base-step-executor";
import {
  ActionStep,
  StepResult,
  ExecutionContext,
  N8nAgentActionType,
  ResponseCategory,
} from "../../../types/action-planning.types";
import { n8nAgentClient, N8nAgentRequest, N8nAgentResponse } from "../../integrations/n8n-agent-client";
import { EmailStepExecutor } from "./email-step-executor";
import { CalendarStepExecutor } from "./calendar-step-executor";
import { ContactStepExecutor } from "./contact-step-executor";

export class N8nAgentStepExecutor extends BaseStepExecutor {
  private fallbackExecutors: Map<string, BaseStepExecutor>;

  constructor() {
    super();
    
    // Initialize fallback executors for graceful degradation
    this.fallbackExecutors = new Map([
      ['email', new EmailStepExecutor()],
      ['calendar', new CalendarStepExecutor()], 
      ['contact', new ContactStepExecutor()],
    ]);
  }

  async executeStep(step: ActionStep, context: ExecutionContext): Promise<StepResult> {
    try {
      console.log(`[N8nAgentExecutor] ü§ñ Executing n8n agent step: ${step.action}`);
      
      // Build n8n request with full context
      const n8nRequest = this.buildN8nRequest(step, context);
      
      // Execute with retry logic
      const n8nResponse = await n8nAgentClient.executeWithRetry(n8nRequest);
      
      // Parse response into StepResult format
      const stepResult = this.parseN8nResponse(n8nResponse, step);
      
      console.log(`[N8nAgentExecutor] ‚úÖ n8n agent execution completed: ${n8nResponse.agent}`);
      return stepResult;
      
    } catch (error) {
      console.error(`[N8nAgentExecutor] ‚ùå n8n agent execution failed:`, error);
      
      // Attempt fallback to local system if applicable
      if (this.shouldFallbackToLocal(error) && this.canFallbackToLocal(step)) {
        console.log(`[N8nAgentExecutor] üîÑ Attempting fallback to local execution`);
        return await this.executeLocalFallback(step, context);
      }
      
      // Return error result if no fallback possible
      return this.createStepResult(
        step,
        false,
        undefined,
        undefined,
        `n8n Agent execution failed: ${error.message}`,
        undefined,
        false,
        null
      );
    }
  }

  private buildN8nRequest(step: ActionStep, context: ExecutionContext): N8nAgentRequest {
    // Determine agent type from action
    const agentType = this.mapActionToAgentType(step.action);
    
    // Build natural language message from step
    const message = this.buildNaturalMessage(step);
    
      return {
      message,
      user_id: context.userUUID || context.entityId,
      agent_type: agentType,
      context: {
        userTimezone: context.userTimezone,
        localDatetime: context.localDatetime,
        entities: context.entities,
        rdfInsights: context.rdfInsights,
        executionContext: context,
      },
      metadata: {
        requestId: step.id,
        priority: this.determinePriority(step, context),
        timeout: this.getTimeoutForAction(step.action),
      }
    };
  }

  private parseN8nResponse(response: N8nAgentResponse, step: ActionStep): StepResult {
    // Parse n8n agent response into omnii StepResult format
    const category = this.mapAgentToResponseCategory(response.agent);
    
    return this.createStepResult(
      step,
      response.success,
      response.result,
      response.success ? `${response.agent} completed: ${response.action}` : undefined,
      response.error,
      undefined,
      false, // n8n handles auth internally
      null,
      category,
      response.result, // structuredData
      {
        title: `${response.agent} Result`,
        subtitle: response.action,
        content: response.success ? 'Operation completed successfully' : response.error,
        icon: this.getAgentIcon(response.agent),
        metadata: {
          executionTime: response.execution_time,
          agent: response.agent,
          action: response.action,
        }
      }
    );
  }

  private shouldFallbackToLocal(error: any): boolean {
    const errorStr = error.message?.toLowerCase() || '';
    
    // Fallback conditions
    return (
      errorStr.includes('timeout') ||
      errorStr.includes('503') ||
      errorStr.includes('502') ||
      errorStr.includes('connection') ||
      errorStr.includes('network') ||
      errorStr.includes('unavailable')
    );
  }

  private canFallbackToLocal(step: ActionStep): boolean {
    // Only fallback for actions that have local equivalents
    const fallbackableActions = [
      'send_email', 'fetch_emails', 'create_draft',
      'list_events', 'create_event', 
      'search_contacts', 'get_all_contacts',
    ];
    
    return fallbackableActions.includes(step.action);
  }

  private async executeLocalFallback(step: ActionStep, context: ExecutionContext): Promise<StepResult> {
    // Determine which local executor to use
    const localExecutorType = this.mapToLocalExecutorType(step.action);
    const executor = this.fallbackExecutors.get(localExecutorType);
    
    if (!executor) {
      throw new Error(`No local fallback available for action: ${step.action}`);
    }
    
    console.log(`[N8nAgentExecutor] üîÑ Executing local fallback with ${localExecutorType} executor`);
    
    // Convert n8n action to local action format
    const localStep = this.convertToLocalAction(step);
    
    return await executor.executeStep(localStep, context);
  }

  // Helper methods
  private mapActionToAgentType(action: string): string
  private buildNaturalMessage(step: ActionStep): string  
  private mapAgentToResponseCategory(agent: string): ResponseCategory
  private getAgentIcon(agent: string): string
  private determinePriority(step: ActionStep, context: ExecutionContext): string
  private getTimeoutForAction(action: string): number
  private mapToLocalExecutorType(action: string): string
  private convertToLocalAction(step: ActionStep): ActionStep
}
```

### Phase 3: Smart Routing Logic Integration

#### 3.1 **Enhance ActionPlanner with n8n Routing**
**File**: `apps/omnii_mcp/src/services/core/action-planner.ts`

**Integration Point**: Update the `createPlanWithLLM` system prompt (around line 953):
```typescript
// Enhance the existing system prompt:
content: `You are an action planner. Analyze user messages and break them down into sequential steps.

IMPORTANT: For any PERSON entity used as an email recipient, use a placeholder in the form {{ENTITY:<slugified-name>}} for recipient_email.

Available action types:
- calendar: list_events, create_event, find_free_time
- task: list_tasks, create_task, update_task, complete_task  
- contact: search_contacts, get_all_contacts, create_contact
- analysis: find_free_time, suggest_times, check_conflicts
- email: send_email, create_draft, fetch_emails, add_label, create_label, [all existing actions]
- n8n_agent: smart_email_compose, smart_scheduling, contact_enrichment, web_research, youtube_content_search, workflow_automation

ROUTING DECISION RULES:
Use n8n_agent when the request involves:
1. Complex multi-step automation across multiple services
2. Web research, information gathering, or external data needs
3. YouTube content discovery and video search
4. Smart email composition requiring AI context awareness
5. Intelligent scheduling coordination with multiple people
6. Cross-service workflow automation
7. Contact enrichment with external data sources
8. Any request that would benefit from AI reasoning beyond simple API calls

Use local executors (email, calendar, task, contact) for:
1. Simple, direct Google API operations
2. Single-step actions (list emails, create task, show calendar)
3. Real-time operations requiring <2 second response
4. Basic CRUD operations without complex logic

Examples of n8n_agent usage:
- "Research the latest AI trends and email a summary to my team" ‚Üí n8n_agent: workflow_automation
- "Find YouTube videos about React hooks and create learning tasks" ‚Üí n8n_agent: multi_service_coordination  
- "Compose a professional email to John about the project delay with context from recent emails" ‚Üí n8n_agent: smart_email_compose
- "Search for information about quantum computing and schedule a meeting to discuss" ‚Üí n8n_agent: workflow_automation

Examples of local executor usage:
- "List my emails from today" ‚Üí email: fetch_emails
- "Create a task: Buy groceries" ‚Üí task: create_task
- "What's on my calendar tomorrow?" ‚Üí calendar: list_events
- "Find contact John Smith" ‚Üí contact: search_contacts`
```

**Add new method after line 1066**:
```typescript
/**
 * Determine if message should use n8n agents based on complexity and intent
 */
private shouldUseN8nAgent(
  message: string, 
  rdfInsights: any,
  entities: CachedEntity[]
): boolean {
  // Factors for n8n routing:
  
  // 1. Message complexity (multiple verbs, cross-service coordination)
  const wordCount = message.split(' ').length;
  const hasMultipleVerbs = (message.match(/\b(send|create|find|search|schedule|update|analyze|research)\b/gi) || []).length > 1;
  
  // 2. RDF-detected intent analysis
  const primaryIntent = rdfInsights?.ai_reasoning?.intent_analysis?.primary_intent;
  const complexIntents = ['workflow_automation', 'research_task', 'multi_service_coordination'];
  const isComplexIntent = complexIntents.includes(primaryIntent);
  
  // 3. Web/research component detection
  const hasWebComponent = /\b(research|search|find information|look up|what is|how to)\b/i.test(message);
  const hasYouTubeComponent = /\b(youtube|video|tutorial|watch|learn)\b/i.test(message);
  
  // 4. Cross-service coordination indicators
  const hasCrossService = this.detectCrossServiceNeed(message);
  
  // 5. AI reasoning requirement indicators
  const needsAIReasoning = /\b(smart|intelligent|analyze|summarize|recommend|suggest|optimize)\b/i.test(message);
  
  // Decision logic
  const complexityScore = (
    (wordCount > 10 ? 1 : 0) +
    (hasMultipleVerbs ? 1 : 0) +
    (isComplexIntent ? 2 : 0) +
    (hasWebComponent ? 1 : 0) +
    (hasYouTubeComponent ? 1 : 0) +
    (hasCrossService ? 2 : 0) +
    (needsAIReasoning ? 1 : 0)
  );
  
  const shouldUseN8n = complexityScore >= 2;
  
  console.log(`[ActionPlanner] ü§î n8n routing analysis: complexity=${complexityScore}, shouldUse=${shouldUseN8n}`);
  console.log(`[ActionPlanner] üìä Factors: words=${wordCount}, multiVerb=${hasMultipleVerbs}, intent=${primaryIntent}, web=${hasWebComponent}, youtube=${hasYouTubeComponent}, cross=${hasCrossService}, ai=${needsAIReasoning}`);
  
  return shouldUseN8n;
}

private detectCrossServiceNeed(message: string): boolean {
  // Detect patterns that require multiple service coordination
  const crossServicePatterns = [
    /email.*calendar/i,
    /calendar.*email/i, 
    /task.*email/i,
    /email.*task/i,
    /schedule.*email/i,
    /contact.*email/i,
    /research.*email/i,
    /find.*create/i,
    /search.*send/i,
  ];
  
  return crossServicePatterns.some(pattern => pattern.test(message));
}
```

#### 3.2 **Update StepExecutorFactory Registration**
**File**: `apps/omnii_mcp/src/services/action-planner/step-executors/step-executor-factory.ts`

**Integration Point**: Update constructor (around line 25):
```typescript
import { N8nAgentStepExecutor } from "./n8n-agent-executor";

constructor(interventionManager?: InterventionManager) {
  // Initialize dependency resolver
  this.dependencyResolver = new DependencyResolver();

  // Register existing step executors
  this.executors.set("email", new EmailStepExecutor());
  this.executors.set("calendar", new CalendarStepExecutor());
  this.executors.set("task", new TaskStepExecutor());
  this.executors.set("contact", new ContactStepExecutor());
  this.executors.set("analysis", new AnalysisStepExecutor());
  
  // NEW: Register n8n agent executor
  this.executors.set("n8n_agent", new N8nAgentStepExecutor());

  // System executor needs intervention manager
  if (interventionManager) {
    this.executors.set("system", new SystemStepExecutor(interventionManager));
  }
  
  console.log(`[StepExecutorFactory] ‚úÖ Registered ${this.executors.size} step executors including n8n agent`);
}
```

### Phase 4: Response Handling and UI Integration

#### 4.1 **Extend WebSocket Response Types** 
**File**: `apps/omnii_mcp/src/types/websocket.types.ts`

**Integration Point**: Add to ResponseCategory enum (around line 10):
```typescript
// Add after existing categories:
N8N_AGENT_RESPONSE = "n8n_agent_response",
AGENT_AUTOMATION = "agent_automation",
WEB_RESEARCH = "web_research", 
YOUTUBE_SEARCH = "youtube_search",
WORKFLOW_COORDINATION = "workflow_coordination",
```

#### 4.2 **Update Enhanced WebSocket Handler**
**File**: `apps/omnii_mcp/src/services/core/enhanced-websocket-handler.ts`

**Integration Point**: Add n8n response handling method after line 1276:
```typescript
/**
 * Handle n8n agent responses and format for mobile app
 */
private handleN8nAgentResponse(stepResult: StepResult): any {
  if (stepResult.category === ResponseCategory.N8N_AGENT_RESPONSE) {
    const agentData = stepResult.structuredData;
    
    return {
        type: WebSocketMessageType.SYSTEM,
        data: {
        action: "n8n_agent_response",
        message: stepResult.message,
        agent: agentData.agent,
        agentAction: agentData.action,
        executionTime: agentData.execution_time,
        result: agentData.result,
        category: stepResult.category,
          metadata: {
          responseType: 'n8n_agent',
          agent: agentData.agent,
          action: agentData.action,
          success: stepResult.success,
          executionTime: agentData.execution_time,
          }
        },
        timestamp: Date.now(),
      };
  }
  
  return null; // Not an n8n response
}
```

#### 4.3 **Update Mobile App Response Handling**
**File**: `apps/omnii-mobile/src/services/chat/ChatService.ts`

**Integration Point**: Add to ResponseCategory enum (around line 48):
```typescript
// Add after existing categories:
N8N_AGENT_RESPONSE = 'n8n_agent_response',
AGENT_AUTOMATION = 'agent_automation',
WEB_RESEARCH = 'web_research',
YOUTUBE_SEARCH = 'youtube_search', 
WORKFLOW_COORDINATION = 'workflow_coordination',
```

#### 4.4 **Create n8n Agent Response Components**
**File**: `apps/omnii-mobile/src/components/chat/N8nAgentComponents.tsx` (NEW)
```typescript
import React from 'react';
import { View, Text, TouchableOpacity, ScrollView } from 'react-native';
import { useTheme } from '~/context/ThemeContext';
import { cn } from '~/utils/cn';

// Agent Automation Response - Shows n8n agent execution results
export const AgentAutomationResponse: React.FC<{
      agent: string;
      action: string;
      result: any;
  executionTime: string;
  success: boolean;
}> = ({ agent, action, result, executionTime, success }) => {
  const { isDark } = useTheme();

  const getAgentIcon = (agentName: string) => {
    const icons = {
      'Email Agent': 'üìß',
      'Calendar Agent': 'üìÖ', 
      'Contact Agent': 'üë•',
      'Web Agent': 'üåê',
      'YouTube Agent': 'üé•',
    };
    return icons[agentName] || 'ü§ñ';
  };

  return (
    <View className={cn(
      "mt-3 p-4 rounded-xl border",
      isDark ? "bg-gray-800 border-gray-700" : "bg-gray-50 border-gray-200"
    )}>
      {/* Agent Header */}
      <View className="flex-row items-center justify-between mb-3">
        <View className="flex-row items-center gap-2">
          <Text className="text-lg">{getAgentIcon(agent)}</Text>
          <Text className={cn(
            "font-semibold",
            isDark ? "text-white" : "text-gray-900"
          )}>
            {agent}
          </Text>
        </View>
        
        <View className={cn(
          "px-2 py-1 rounded-full",
          success 
            ? (isDark ? "bg-green-900/30" : "bg-green-100")
            : (isDark ? "bg-red-900/30" : "bg-red-100")
        )}>
          <Text className={cn(
            "text-xs font-medium",
            success
              ? (isDark ? "text-green-300" : "text-green-700") 
              : (isDark ? "text-red-300" : "text-red-700")
          )}>
            {success ? '‚úÖ Success' : '‚ùå Failed'}
          </Text>
        </View>
      </View>

      {/* Action Description */}
      <Text className={cn(
        "text-sm mb-2",
        isDark ? "text-gray-300" : "text-gray-600"
      )}>
        Action: {action}
      </Text>

      {/* Result Summary */}
      {success && result && (
        <View className={cn(
          "p-3 rounded-lg",
          isDark ? "bg-gray-700" : "bg-white"
        )}>
          <Text className={cn(
            "text-sm",
            isDark ? "text-gray-200" : "text-gray-700"
          )}>
            {typeof result === 'string' ? result : JSON.stringify(result, null, 2)}
          </Text>
        </View>
      )}

      {/* Execution Time */}
      <View className="flex-row justify-between items-center mt-3">
        <Text className={cn(
          "text-xs",
          isDark ? "text-gray-400" : "text-gray-500"
        )}>
          Execution time: {executionTime}
        </Text>
        
        <Text className={cn(
          "text-xs font-medium",
          isDark ? "text-blue-300" : "text-blue-600"
        )}>
          ü§ñ AI Agent
        </Text>
      </View>
    </View>
  );
};

// Web Research Response - Shows web search results
export const WebResearchResponse: React.FC<{
  query: string;
  results: Array<{title: string; snippet: string; link: string}>;
  executionTime: string;
}> = ({ query, results, executionTime }) => {
  const { isDark } = useTheme();

  return (
    <View className={cn(
      "mt-3 p-4 rounded-xl border",
      isDark ? "bg-gray-800 border-gray-700" : "bg-gray-50 border-gray-200"
    )}>
      {/* Header */}
      <View className="flex-row items-center gap-2 mb-3">
        <Text className="text-lg">üåê</Text>
        <Text className={cn(
          "font-semibold",
          isDark ? "text-white" : "text-gray-900"
        )}>
          Web Research Results
        </Text>
      </View>

      {/* Query */}
      <Text className={cn(
        "text-sm mb-3 italic",
        isDark ? "text-gray-300" : "text-gray-600"
      )}>
        Query: "{query}"
      </Text>

      {/* Results */}
      <ScrollView className="max-h-64" showsVerticalScrollIndicator={false}>
        {results.map((result, index) => (
          <TouchableOpacity 
            key={index}
            className={cn(
              "p-3 mb-2 rounded-lg border",
              isDark ? "bg-gray-700 border-gray-600" : "bg-white border-gray-200"
            )}
          >
            <Text className={cn(
              "font-medium mb-1",
              isDark ? "text-white" : "text-gray-900"
            )}>
              {result.title}
            </Text>
            <Text className={cn(
              "text-sm",
              isDark ? "text-gray-300" : "text-gray-600"
            )}>
              {result.snippet}
            </Text>
          </TouchableOpacity>
        ))}
      </ScrollView>

      {/* Footer */}
      <Text className={cn(
        "text-xs mt-2",
        isDark ? "text-gray-400" : "text-gray-500"
      )}>
        Found {results.length} results ‚Ä¢ {executionTime}
      </Text>
    </View>
  );
};

// YouTube Search Response - Shows video search results
export const YoutubeSearchResponse: React.FC<{
  query: string;
  videos: Array<{
    videoId: string;
    title: string;
    description: string;
    channelTitle: string;
  }>;
  executionTime: string;
}> = ({ query, videos, executionTime }) => {
  const { isDark } = useTheme();
  
  return (
    <View className={cn(
      "mt-3 p-4 rounded-xl border",
      isDark ? "bg-gray-800 border-gray-700" : "bg-gray-50 border-gray-200"
    )}>
      {/* Header */}
      <View className="flex-row items-center gap-2 mb-3">
        <Text className="text-lg">üé•</Text>
        <Text className={cn(
          "font-semibold",
          isDark ? "text-white" : "text-gray-900"
        )}>
          YouTube Videos
        </Text>
      </View>
      
      {/* Query */}
      <Text className={cn(
        "text-sm mb-3 italic",
        isDark ? "text-gray-300" : "text-gray-600"
      )}>
        Search: "{query}"
      </Text>

      {/* Video Results */}
      <ScrollView className="max-h-80" showsVerticalScrollIndicator={false}>
        {videos.map((video, index) => (
          <TouchableOpacity 
            key={video.videoId}
            className={cn(
              "p-3 mb-2 rounded-lg border",
              isDark ? "bg-gray-700 border-gray-600" : "bg-white border-gray-200"
            )}
          >
            <Text className={cn(
              "font-medium mb-1",
              isDark ? "text-white" : "text-gray-900"
            )}>
              {video.title}
          </Text>
            <Text className={cn(
              "text-xs mb-1",
              isDark ? "text-blue-300" : "text-blue-600"
            )}>
              {video.channelTitle}
            </Text>
            {video.description && (
              <Text className={cn(
                "text-sm",
                isDark ? "text-gray-300" : "text-gray-600"
              )}>
                {video.description.substring(0, 100)}...
              </Text>
            )}
          </TouchableOpacity>
        ))}
      </ScrollView>

      {/* Footer */}
      <Text className={cn(
        "text-xs mt-2",
        isDark ? "text-gray-400" : "text-gray-500"
      )}>
        {videos.length} videos found ‚Ä¢ {executionTime}
      </Text>
    </View>
  );
};

// n8n Agent Status Indicator - Shows agent processing status
export const N8nAgentStatusIndicator: React.FC<{
  agent: string;
  action: string;
  status: 'processing' | 'completed' | 'failed';
}> = ({ agent, action, status }) => {
  const { isDark } = useTheme();

  const getStatusColor = () => {
    switch (status) {
      case 'processing': return isDark ? "text-yellow-300" : "text-yellow-600";
      case 'completed': return isDark ? "text-green-300" : "text-green-600";  
      case 'failed': return isDark ? "text-red-300" : "text-red-600";
    }
  };

  const getStatusIcon = () => {
    switch (status) {
      case 'processing': return '‚è≥';
      case 'completed': return '‚úÖ';
      case 'failed': return '‚ùå';
    }
  };
  
  return (
    <View className={cn(
      "flex-row items-center gap-2 px-3 py-2 rounded-lg",
      isDark ? "bg-gray-800" : "bg-gray-100"
    )}>
      <Text className="text-sm">{getStatusIcon()}</Text>
      <Text className={cn("text-sm", getStatusColor())}>
        {agent} {status === 'processing' ? 'is working on' : status} {action}
          </Text>
    </View>
  );
};
```

#### 4.5 **Update MessageComponents Integration**
**File**: `apps/omnii-mobile/src/components/chat/MessageComponents.tsx`

**Integration Point**: Add imports and rendering logic:
```typescript
// Add import
import { 
  AgentAutomationResponse, 
  WebResearchResponse, 
  YoutubeSearchResponse,
  N8nAgentStatusIndicator 
} from './N8nAgentComponents';

// Add to message rendering logic (around line 2398):
{/* n8n Agent Response Components */}
{message.metadata?.category === ResponseCategory.N8N_AGENT_RESPONSE && (
  <AgentAutomationResponse
    agent={message.metadata.agent}
    action={message.metadata.agentAction}
    result={message.metadata.result}
    executionTime={message.metadata.executionTime}
    success={message.metadata.success}
  />
)}

{message.metadata?.category === ResponseCategory.WEB_RESEARCH && (
  <WebResearchResponse
    query={message.metadata.webResearch?.query}
    results={message.metadata.webResearch?.results || []}
    executionTime={message.metadata.executionTime}
  />
)}

{message.metadata?.category === ResponseCategory.YOUTUBE_SEARCH && (
  <YoutubeSearchResponse
    query={message.metadata.youtubeSearch?.query}
    videos={message.metadata.youtubeSearch?.videos || []}
    executionTime={message.metadata.executionTime}
  />
)}
```

### Phase 5: Configuration and Environment Setup

#### 5.1 **Environment Variables**
**File**: `apps/omnii_mcp/.env` and Railway Environment
```env
# n8n Agent Swarm Configuration
N8N_AGENT_SWARM_URL=https://omnii-agent-swarm-production.up.railway.app
N8N_AGENT_ENABLED=true
N8N_AGENT_TIMEOUT=600000
N8N_FALLBACK_ENABLED=true
N8N_ENABLED_AGENTS=email,calendar,contact,web,youtube

# n8n Integration Monitoring
N8N_HEALTH_CHECK_INTERVAL=300000
N8N_REQUEST_LOGGING=true
N8N_PERFORMANCE_TRACKING=true
```

#### 5.2 **Update Railway Deployment Configuration**
- Add n8n environment variables to Railway omnii_mcp service
- Ensure network connectivity between omnii_mcp and n8n services
- Configure monitoring and alerting for n8n integration

## üîÑ Enhanced Integration Flow Design

### Complete Message Processing Pipeline
```
User Message 
    ‚Üì
EnhancedWebSocketHandler
    ‚Üì
RDF Semantic Analysis
    ‚Üì
ActionPlanner Decision Engine
    ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Routing Decision Logic          ‚îÇ
‚îÇ                                 ‚îÇ
‚îÇ Analyze:                        ‚îÇ
‚îÇ ‚Ä¢ Message complexity            ‚îÇ
‚îÇ ‚Ä¢ RDF intent analysis          ‚îÇ  
‚îÇ ‚Ä¢ Cross-service needs           ‚îÇ
‚îÇ ‚Ä¢ AI reasoning requirements     ‚îÇ
‚îÇ ‚Ä¢ Web/research components       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
              ‚Üì
    Complex/AI-Suitable?
         ‚Üô        ‚Üò
   YES: n8n Agent    NO: Current System
         ‚Üì                ‚Üì
   N8nAgentExecutor    EmailStepExecutor
         ‚Üì            CalendarStepExecutor
   Agent Swarm API         etc.
         ‚Üì                ‚Üì
   Parse & Format     UnifiedGoogleManager
         ‚Üì                ‚Üì
   Enhanced Response ‚Üê‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚Üì
   Mobile App UI Components
```

### Routing Decision Examples

**Route to n8n Agent**:
```typescript
// Complex automation
"Research the latest AI trends and send a summary email to my team"
‚Üí N8nAgentActionType.WORKFLOW_AUTOMATION

// Multi-service coordination  
"Find YouTube videos about React hooks and create learning tasks for each"
‚Üí N8nAgentActionType.MULTI_SERVICE_COORDINATION

// Smart composition
"Compose a professional email to John about the project delay, include context from recent emails"
‚Üí N8nAgentActionType.SMART_EMAIL_COMPOSE

// Web research
"What's the weather in New York and should I reschedule my outdoor meeting?"
‚Üí N8nAgentActionType.WEB_RESEARCH
```

**Route to Current System**:
```typescript
// Simple operations
"List my emails from today" ‚Üí EmailActionType.FETCH_EMAILS
"Create a task: Buy groceries" ‚Üí TaskActionType.CREATE_TASK  
"What's on my calendar tomorrow?" ‚Üí CalendarActionType.LIST_EVENTS
"Find contact John Smith" ‚Üí ContactActionType.SEARCH_CONTACTS
```

## üö® Error Handling and Fallback Strategy

### Comprehensive Error Handling Pipeline
```typescript
interface ErrorHandlingStrategy {
  // n8n service errors
  n8nTimeout: () => {
    message: "Your request is being processed by our AI agents. This may take up to 10 minutes for complex operations.";
    action: "show_progress_indicator";
    fallback: "continue_monitoring";
  };
  
  n8nUnavailable: () => {
    message: "AI agent service temporarily unavailable. Processing with local system.";
    action: "fallback_to_local";
    fallback: "execute_local_equivalent";
  };
  
  authenticationError: () => {
    message: "Authentication required for AI agent operations. Please reconnect your Google account.";
    action: "request_oauth";
    fallback: "show_auth_flow";
  };
  
  rateLimitExceeded: () => {
    message: "AI agent capacity reached. Your request has been queued and will process shortly.";
    action: "queue_request";
    fallback: "retry_with_delay";
  };
  
  complexityTooHigh: () => {
    message: "Request too complex for AI agents. Breaking down into simpler steps.";
    action: "decompose_request";
    fallback: "use_local_system";
  };
}
```

### Fallback Hierarchy
```
1. n8n Agent Request
   ‚Üì (if timeout)
2. Show progress indicator, continue monitoring
   ‚Üì (if service unavailable)  
3. Fallback to Current System (if action has local equivalent)
   ‚Üì (if no local equivalent)
4. Queue for retry when service available
   ‚Üì (if queue full)
5. Graceful error with helpful message and suggested alternatives
```

## üéØ Implementation Phases

### Phase 1: Foundation (Week 1)
**Files to Create**:
- ‚úÖ `apps/omnii_mcp/src/config/n8n-agent.config.ts`
- ‚úÖ `apps/omnii_mcp/src/services/integrations/n8n-agent-client.ts`  
- ‚úÖ `apps/omnii_mcp/src/services/action-planner/step-executors/n8n-agent-executor.ts`
- ‚úÖ `apps/omnii_mcp/src/types/n8n-agent.types.ts`

**Files to Modify**:
- ‚úÖ `apps/omnii_mcp/src/types/action-planning.types.ts` - Add N8nAgentActionType enum
- ‚úÖ `apps/omnii_mcp/src/config/env.validation.ts` - Add n8n environment validation
- ‚úÖ `apps/omnii_mcp/src/services/action-planner/step-executors/step-executor-factory.ts` - Register n8n executor

### Phase 2: Smart Routing (Week 2)
**Files to Modify**:
- ‚úÖ `apps/omnii_mcp/src/services/core/action-planner.ts` - Add n8n routing logic to LLM prompt
- ‚úÖ `apps/omnii_mcp/src/services/core/action-planner.ts` - Add shouldUseN8nAgent method
- ‚úÖ `apps/omnii_mcp/src/services/core/enhanced-websocket-handler.ts` - Add n8n response handling

### Phase 3: Mobile App Integration (Week 3)
**Files to Create**:
- ‚úÖ `apps/omnii-mobile/src/components/chat/N8nAgentComponents.tsx`

**Files to Modify**:
- ‚úÖ `apps/omnii-mobile/src/types/chat.ts` - Add n8n response types
- ‚úÖ `apps/omnii-mobile/src/services/chat/ChatService.ts` - Add n8n response categories  
- ‚úÖ `apps/omnii-mobile/src/components/chat/ChatMessage.tsx` - Add n8n response rendering
- ‚úÖ `apps/omnii-mobile/src/components/chat/MessageComponents.tsx` - Import n8n components

### Phase 4: Production Hardening (Week 4)
**Enhancements**:
- ‚úÖ Comprehensive logging and monitoring
- ‚úÖ Rate limiting and request queuing
- ‚úÖ Performance metrics and analytics
- ‚úÖ Load testing and optimization
- ‚úÖ Documentation and deployment guides

## üìä Expected Benefits

### For Users
- **ü§ñ Intelligent Automation**: AI agents handle complex multi-step workflows automatically
- **üîç Enhanced Research**: Web and YouTube search integrated into chat experience  
- **üìß Smart Email**: Context-aware email composition with AI reasoning
- **üìÖ Intelligent Scheduling**: Multi-person coordination with conflict resolution
- **üîÑ Seamless Experience**: Transparent fallback maintains reliability when agents unavailable

### For Developers
- **üèóÔ∏è Modular Architecture**: Clean separation between local and agent operations
- **üîÑ Backward Compatibility**: Existing functionality remains completely unchanged
- **üìà Scalable Design**: Easy to add new agent types and capabilities
- **üõ°Ô∏è Robust Fallbacks**: System remains functional even if n8n unavailable
- **üì± Rich UI Components**: Ready-made components for agent response display

## üîç Technical Integration Details

### Performance Characteristics
- **n8n Agent Latency**: 2-10 seconds (vs current <2s for simple operations)
- **Throughput Limits**: ~30 requests/minute/user (n8n rate limits)
- **Timeout Handling**: 10-minute maximum with progress indicators
- **Fallback Speed**: <500ms to switch to local execution
- **Memory Impact**: Minimal - stateless client design

### Architecture Benefits
- **üéØ Smart Routing**: Automatically chooses optimal execution path
- **üîå Service Isolation**: n8n integration doesn't affect existing flows
- **üìä Rich Analytics**: Track agent usage, performance, and user satisfaction
- **üöÄ Future-Ready**: Foundation for advanced AI agent capabilities

### Security Considerations
- **üîê OAuth Passthrough**: n8n uses existing Supabase OAuth tokens
- **üõ°Ô∏è No Token Exposure**: Client never handles sensitive credentials
- **üìù Audit Logging**: All agent requests logged for security monitoring
- **üö® Rate Limiting**: Built-in protection against abuse

## üéØ Success Metrics

### Technical Metrics
- **Response Time**: <10s for 90% of n8n agent requests
- **Fallback Rate**: <5% of requests need fallback to local system
- **Error Rate**: <2% unrecoverable errors
- **User Satisfaction**: >4.5/5 rating for agent automation features

### Business Metrics  
- **Automation Adoption**: >60% of complex requests use n8n agents
- **Task Completion**: >90% successful completion rate for agent workflows
- **User Engagement**: +40% increase in chat interaction frequency
- **Productivity Gain**: Measurable reduction in manual task execution time

# Agent Swarm Complete Implementation Guide

## üéØ Overview
The Agent Swarm is a production-ready AI agent orchestration system deployed on Railway, consisting of two main services:
1. **Express/TypeScript API Server** - Handles authentication, token management, and request routing
2. **n8n Workflow Engine** - Orchestrates AI agents and executes Google API operations

## üèóÔ∏è Architecture

### System Components
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Your App      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ POST /webhook/agent-input
         ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  n8n Service (Railway)                  ‚îÇ
‚îÇ  URL: omnii-agent-swarm-production...   ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
‚îÇ  ‚îÇ Agent Swarm Workflow            ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ - Receives webhook              ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ - Calls Access-Token workflow   ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ - Routes to agents              ‚îÇ   ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
‚îÇ               ‚îÇ                         ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
‚îÇ  ‚îÇ Access-Token Workflow           ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ - Validates user_id             ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ - Fetches OAuth from Supabase   ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ - Auto-refreshes if needed      ‚îÇ   ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ
         ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Express API Server (Railway)           ‚îÇ
‚îÇ  (Optional - for advanced integrations) ‚îÇ
‚îÇ  - Token caching (Redis)                ‚îÇ
‚îÇ  - Rate limiting                        ‚îÇ
‚îÇ  - Additional validation                ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ
         ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Supabase (External)                    ‚îÇ
‚îÇ  URL: https://auth.omnii.net            ‚îÇ
‚îÇ  - User authentication                  ‚îÇ
‚îÇ  - OAuth token storage                  ‚îÇ
‚îÇ  - Token refresh logic                  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Deployment Structure
```
Railway Project: Agent Swarm
‚îú‚îÄ‚îÄ Service 1: n8n Instance
‚îÇ   ‚îú‚îÄ‚îÄ Docker: n8nio/n8n:latest
‚îÇ   ‚îú‚îÄ‚îÄ Workflows: Agent Swarm, Access-Token, Call-Access-Token
‚îÇ   ‚îú‚îÄ‚îÄ Database: PostgreSQL (Railway)
‚îÇ   ‚îî‚îÄ‚îÄ URL: https://omnii-agent-swarm-production.up.railway.app
‚îÇ
‚îî‚îÄ‚îÄ Service 2: Express API Server (Optional)
    ‚îú‚îÄ‚îÄ Runtime: Node.js 18+
    ‚îú‚îÄ‚îÄ Code: TypeScript/Express
    ‚îú‚îÄ‚îÄ Cache: Redis (Railway)
    ‚îî‚îÄ‚îÄ URL: https://agent-swarm-api.up.railway.app
```

## üöÄ Quick Start Integration

### Basic Integration (5 lines)
```javascript
async function sendToAgentSwarm(message, userId) {
    const response = await fetch('https://omnii-agent-swarm-production.up.railway.app/webhook/agent-input', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ message, user_id: userId })
    });
    return response.json();
}
```

### Advanced Integration with Error Handling
```javascript
class AgentSwarmClient {
    constructor(options = {}) {
        this.baseUrl = options.baseUrl || 'https://omnii-agent-swarm-production.up.railway.app';
        this.timeout = options.timeout || 600000; // 10 minutes
        this.retryAttempts = options.retryAttempts || 3;
    }

    async sendMessage(message, userId, options = {}) {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), this.timeout);
        
        try {
            const response = await fetch(`${this.baseUrl}/webhook/agent-input`, {
                method: 'POST',
                headers: { 
                    'Content-Type': 'application/json',
                    ...options.headers 
                },
                body: JSON.stringify({ 
                    message, 
                    user_id: userId,
                    ...options.metadata 
                }),
                signal: controller.signal
            });
            
            clearTimeout(timeoutId);
            
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            
            return await response.json();
        } catch (error) {
            clearTimeout(timeoutId);
            
            if (error.name === 'AbortError') {
                throw new Error('Request timeout after 10 minutes');
            }
            
            throw error;
        }
    }
    
    async executeWithRetry(message, userId, options = {}) {
        let lastError;
        
        for (let i = 0; i < this.retryAttempts; i++) {
            try {
                return await this.sendMessage(message, userId, options);
            } catch (error) {
                lastError = error;
                
                // Don't retry on auth errors
                if (error.message.includes('401') || error.message.includes('403')) {
                    throw error;
                }
                
                // Exponential backoff
                if (i < this.retryAttempts - 1) {
                    await new Promise(r => setTimeout(r, Math.pow(2, i) * 1000));
                }
            }
        }
        
        throw lastError;
    }
}

// Usage
const client = new AgentSwarmClient();
const result = await client.executeWithRetry(
    "Send an email to john@example.com",
    "user-uuid-here"
);
```

## ü§ñ Available Agents

### 1. Email Agent (Gmail)
```javascript
// Capabilities
"Send an email to john@example.com about the meeting tomorrow"
"Reply to the latest email from Sarah"
"Show me my latest 5 emails"
"Search for emails about project alpha"
"Label all emails from marketing@ with 'Marketing'"
"Create a draft email to the team"

// Response includes
{
    agent: "Email Agent",
    action: "Send Email",
    result: {
        messageId: "...",
        threadId: "...",
        labelIds: ["SENT"]
    }
}
```

### 2. Calendar Agent (Google Calendar)
```javascript
// Capabilities
"What's on my calendar today?"
"Schedule a meeting with Bob tomorrow at 3pm"
"List my events for next week"
"Update the team meeting to 4pm"
"Cancel my 2pm appointment"
"Find free time slots this week"

// Response includes
{
    agent: "Calendar Agent",
    action: "Create Event",
    result: {
        eventId: "...",
        htmlLink: "...",
        start: { dateTime: "..." },
        end: { dateTime: "..." }
    }
}
```

### 3. Contact Agent (Google People API)
```javascript
// Capabilities
"Find John Smith's phone number"
"Add sarah@example.com to my contacts"
"Update Bob's email to bob@newcompany.com"
"Search for contacts at Acme Corp"
"List all my contacts with phone numbers"

// Response includes
{
    agent: "Contact Agent",
    action: "Search Contact",
    result: {
        resourceName: "people/...",
        names: [...],
        emailAddresses: [...],
        phoneNumbers: [...]
    }
}
```

### 4. Web Agent
```javascript
// Capabilities
"Search for the latest AI news"
"What's the weather in New York?"
"Find information about quantum computing"
"Get today's stock market summary"

// Response includes
{
    agent: "Web Agent",
    action: "Web Search",
    result: {
        query: "...",
        results: [
            { title: "...", snippet: "...", link: "..." }
        ]
    }
}
```

### 5. YouTube Agent
```javascript
// Capabilities
"Find popular Python programming tutorials"
"Search for videos about machine learning"
"What are the trending videos today?"
"Find cooking tutorials for beginners"

// Response includes
{
    agent: "YouTube Agent",
    action: "Video Search",
    result: {
        videos: [
            { 
                videoId: "...",
                title: "...",
                description: "...",
                channelTitle: "..."
            }
        ]
    }
}
```

## üîê Authentication & Token Management

### Prerequisites
1. User must exist in Supabase auth.users table
2. User must have Google OAuth tokens in oauth_tokens table
3. Tokens must include required scopes for the operations

### Token Flow
```
1. Request arrives with user_id
2. n8n calls Access-Token workflow
3. Access-Token queries Supabase for user's OAuth tokens
4. If token expires in < 5 minutes, auto-refresh via Google
5. Fresh token returned to Agent Swarm workflow
6. Agent uses token for Google API calls
```

### Supabase Database Schema
```sql
-- OAuth tokens table (already set up)
CREATE TABLE oauth_tokens (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID REFERENCES auth.users(id),
    provider TEXT NOT NULL,
    access_token TEXT NOT NULL,
    refresh_token TEXT,
    expires_at TIMESTAMPTZ,
    scope TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Required Google OAuth scopes
-- Gmail: https://www.googleapis.com/auth/gmail.modify
-- Calendar: https://www.googleapis.com/auth/calendar
-- Contacts: https://www.googleapis.com/auth/contacts
```

## üì¶ Codebase Structure

### Main Application Server (`/src`)
```
src/
‚îú‚îÄ‚îÄ index.ts                 # Express server entry point
‚îú‚îÄ‚îÄ api/
‚îÇ   ‚îî‚îÄ‚îÄ authController.ts    # Token validation & agent routing
‚îú‚îÄ‚îÄ auth/
‚îÇ   ‚îú‚îÄ‚îÄ tokenManager.ts      # Redis caching & token refresh
‚îÇ   ‚îî‚îÄ‚îÄ supabaseProxy.ts     # Supabase API interactions
‚îú‚îÄ‚îÄ middleware/
‚îÇ   ‚îî‚îÄ‚îÄ apiKey.ts           # API key validation
‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îú‚îÄ‚îÄ logger.ts           # Winston logging
‚îÇ   ‚îî‚îÄ‚îÄ scheduler.ts        # Cron jobs for token cleanup
‚îî‚îÄ‚îÄ types/
    ‚îî‚îÄ‚îÄ index.ts            # TypeScript definitions
```

### n8n Docker Instance (`/docker/n8n-instance`)
```
docker/n8n-instance/
‚îú‚îÄ‚îÄ Dockerfile              # n8n container configuration
‚îú‚îÄ‚îÄ docker-compose.yml      # Local testing setup
‚îú‚îÄ‚îÄ railway.json           # Railway deployment config
‚îú‚îÄ‚îÄ workflows/
‚îÇ   ‚îú‚îÄ‚îÄ Agent Swarm.json      # Main orchestrator workflow
‚îÇ   ‚îú‚îÄ‚îÄ Access-Token.json     # Token validation workflow
‚îÇ   ‚îî‚îÄ‚îÄ Call-Access-Token.json # Token refresh workflow
‚îî‚îÄ‚îÄ scripts/
    ‚îú‚îÄ‚îÄ entrypoint.sh         # Container startup script
    ‚îú‚îÄ‚îÄ workflow-sync.js      # Auto-import workflows
    ‚îî‚îÄ‚îÄ user-isolation.js     # Multi-tenant isolation
```

## üö¢ Deployment on Railway

### Current Production Services

#### 1. n8n Service
- **URL**: https://omnii-agent-swarm-production.up.railway.app
- **Status**: ‚úÖ Deployed and running
- **Database**: PostgreSQL (Railway managed)
- **Workflows**: 3 workflows auto-imported on startup

#### 2. Express API Service (Optional Enhancement)
- **URL**: https://agent-swarm-api.up.railway.app (if deployed)
- **Purpose**: Advanced features like caching, rate limiting
- **Database**: Redis for token caching
- **Status**: Ready to deploy if needed

### Environment Variables (n8n Service)
```env
# Core n8n
N8N_ENCRYPTION_KEY=aB3dF9hK2mN5pQ8rT1uW4xY7zC6eG0jL
N8N_WEBHOOK_BASE_URL=https://omnii-agent-swarm-production.up.railway.app
N8N_EDITOR_BASE_URL=https://omnii-agent-swarm-production.up.railway.app

# Database
DB_TYPE=postgresdb
DB_POSTGRESDB_HOST=postgres.railway.internal
DB_POSTGRESDB_PORT=5432
DB_POSTGRESDB_DATABASE=railway
DB_POSTGRESDB_USER=postgres
DB_POSTGRESDB_PASSWORD=[auto-generated]

# Supabase Integration
SUPABASE_URL=https://auth.omnii.net
SUPABASE_ANON_KEY=[your-anon-key]
SUPABASE_SERVICE_ROLE_KEY=[your-service-key]

# Workflow Management
AUTO_SYNC_WORKFLOWS=true
AUTO_ACTIVATE_WORKFLOWS=true

# Trust Proxy (fixes X-Forwarded-For errors)
N8N_TRUST_PROXY=true
EXPRESS_TRUST_PROXY=true
NODE_ENV=production
```

### Deployment Commands
```bash
# Deploy n8n instance
cd docker/n8n-instance
railway up

# View logs
railway logs --tail 100

# Restart service
railway restart

# Update environment variables
railway variables set KEY=value
```

## üß™ Testing & Debugging

### Test Endpoints
```bash
# 1. Health Check
curl https://omnii-agent-swarm-production.up.railway.app/healthz

# 2. Simple Test
curl -X POST https://omnii-agent-swarm-production.up.railway.app/webhook/agent-input \
  -H "Content-Type: application/json" \
  -d '{
    "message": "What is 2+2?",
    "user_id": "cd9bdc60-35af-4bb6-b87e-1932e96fb354"
  }'

# 3. Email Test
curl -X POST https://omnii-agent-swarm-production.up.railway.app/webhook/agent-input \
  -H "Content-Type: application/json" \
  -d '{
    "message": "Show me my latest 5 emails",
    "user_id": "cd9bdc60-35af-4bb6-b87e-1932e96fb354"
  }'

# 4. Calendar Test
curl -X POST https://omnii-agent-swarm-production.up.railway.app/webhook/agent-input \
  -H "Content-Type: application/json" \
  -d '{
    "message": "What is on my calendar today?",
    "user_id": "cd9bdc60-35af-4bb6-b87e-1932e96fb354"
  }'
```

### Common Issues & Solutions

#### 1. "AUTH_FAILED" Error
```javascript
// Problem: User doesn't have OAuth tokens
// Solution: Ensure user has completed Google OAuth flow

// Check tokens in Supabase
SELECT * FROM oauth_tokens WHERE user_id = 'user-uuid';
```

#### 2. "TOKEN_EXPIRED" Error
```javascript
// Problem: Refresh token is invalid
// Solution: User needs to re-authenticate with Google

// Force token refresh
UPDATE oauth_tokens 
SET expires_at = NOW() - INTERVAL '1 hour'
WHERE user_id = 'user-uuid';
```

#### 3. Timeout Issues
```javascript
// Problem: Operation takes > 10 minutes
// Solution: Implement async pattern with webhooks

// Example async implementation
async function longOperation(message, userId) {
    // Start operation
    const { operationId } = await startOperation(message, userId);
    
    // Poll for results
    let result;
    while (!result) {
        await sleep(5000);
        result = await checkOperation(operationId);
    }
    
    return result;
}
```

#### 4. Rate Limiting
```javascript
// Problem: Too many requests
// Solution: Implement client-side rate limiting

class RateLimitedClient {
    constructor() {
        this.queue = [];
        this.processing = false;
        this.requestsPerMinute = 30;
    }
    
    async sendMessage(message, userId) {
        return new Promise((resolve, reject) => {
            this.queue.push({ message, userId, resolve, reject });
            this.processQueue();
        });
    }
    
    async processQueue() {
        if (this.processing || this.queue.length === 0) return;
        
        this.processing = true;
        const delay = 60000 / this.requestsPerMinute;
        
        while (this.queue.length > 0) {
            const { message, userId, resolve, reject } = this.queue.shift();
            
            try {
                const result = await this.makeRequest(message, userId);
                resolve(result);
            } catch (error) {
                reject(error);
            }
            
            await new Promise(r => setTimeout(r, delay));
        }
        
        this.processing = false;
    }
}
```

## üìä Monitoring & Logging

### Railway Logs
```bash
# View real-time logs
railway logs --tail

# Search logs
railway logs | grep "ERROR"

# Export logs
railway logs > agent-swarm.log
```

### n8n Execution History
1. Access n8n UI: https://omnii-agent-swarm-production.up.railway.app
2. Navigate to Executions
3. Filter by workflow, status, or date
4. View detailed execution logs and data

### Client-Side Logging
```javascript
class AgentSwarmLogger {
    constructor(userId) {
        this.userId = userId;
        this.logs = [];
    }
    
    async log(action, data) {
        const entry = {
            timestamp: new Date().toISOString(),
            userId: this.userId,
            action,
            data,
            ...this.getMetadata()
        };
        
        this.logs.push(entry);
        
        // Send to your logging service
        await this.sendToLoggingService(entry);
    }
    
    getMetadata() {
        return {
            userAgent: navigator.userAgent,
            platform: navigator.platform,
            language: navigator.language,
            timezone: Intl.DateTimeFormat().resolvedOptions().timeZone
        };
    }
    
    async sendToLoggingService(entry) {
        // Implement your logging service integration
        // e.g., Sentry, LogRocket, Datadog, etc.
    }
}
```

## üöÄ Production Checklist

### Before Launch
- [ ] Test all agent types with real user accounts
- [ ] Verify OAuth token refresh works correctly
- [ ] Test error handling for all failure scenarios
- [ ] Implement request/response logging
- [ ] Set up monitoring alerts
- [ ] Document rate limits and quotas
- [ ] Create user onboarding flow for OAuth

### Performance Optimization
- [ ] Implement Redis caching for frequently accessed data
- [ ] Use webhook callbacks for long operations
- [ ] Batch similar requests when possible
- [ ] Implement client-side request queuing
- [ ] Add CDN for static assets

### Security
- [ ] Validate all user inputs
- [ ] Implement rate limiting per user
- [ ] Add request signing for sensitive operations
- [ ] Regular security audits of OAuth scopes
- [ ] Monitor for suspicious activity patterns

### Scaling Considerations
- [ ] Current setup handles ~100 concurrent users
- [ ] For higher load, deploy multiple n8n instances
- [ ] Consider implementing queue system (Redis/RabbitMQ)
- [ ] Database connection pooling configured
- [ ] Railway auto-scaling available if needed

## üìö Additional Resources

### Documentation Files
- **AGENT_SWARM_IMPLEMENTATION_PLAN.md** - Detailed implementation guide
- **AGENT_SWARM_TECHNICAL_ARCHITECTURE.md** - System design details
- **AGENT_SWARM_QUICK_REFERENCE.md** - Quick code snippets
- **AGENT_SWARM_IMPLEMENTATION_SUMMARY.md** - Executive overview

### Test Scripts
```bash
# Located in /tests directory
tests/
‚îú‚îÄ‚îÄ agents/           # Individual agent tests
‚îú‚îÄ‚îÄ basic/           # Authentication tests
‚îú‚îÄ‚îÄ calendar/        # Calendar-specific tests
‚îú‚îÄ‚îÄ contacts/        # Contact management tests
‚îî‚îÄ‚îÄ run-all-tests.sh # Complete test suite
```

### Support Contacts
- **Railway Status**: https://railway.app/status
- **Supabase Dashboard**: https://auth.omnii.net
- **n8n Documentation**: https://docs.n8n.io

## üéØ Next Steps for App Developers

1. **Immediate (Day 1)**
   - Test the webhook endpoint with your user_id
   - Implement basic error handling
   - Add loading states for long operations

2. **Short Term (Week 1)**
   - Implement retry logic with exponential backoff
   - Add client-side caching for common queries
   - Create UI components for each agent type

3. **Medium Term (Month 1)**
   - Build conversation history system
   - Implement webhook callbacks for async operations
   - Add analytics tracking for agent usage

4. **Long Term**
   - Create custom workflows for your specific use cases
   - Implement multi-step agent chains
   - Build predictive features based on usage patterns

## Summary

The Agent Swarm is a fully deployed, production-ready system on Railway that provides AI-powered automation through Google APIs. The system consists of an n8n workflow engine handling the orchestration and a supporting Express/TypeScript server for advanced features. Integration requires only a few lines of code, but the system is robust enough to handle complex, production-scale applications.

Start with the basic integration, test with the provided user_id, and gradually expand based on your application's needs. The system is designed to be maintainable, scalable, and secure, with automatic token management and user isolation built in.

# ü§ù Agent Swarm Project Handover Document

## Executive Summary

You're receiving a **fully deployed, production-ready AI agent system** that orchestrates Google services (Gmail, Calendar, Contacts) through natural language commands. The system is live on Railway and ready for immediate integration.

**Live Endpoint**: `https://omnii-agent-swarm-production.up.railway.app/webhook/agent-input`
**Test User ID**: `cd9bdc60-35af-4bb6-b87e-1932e96fb354`

## üéØ What You're Getting

### Working System Components
1. **n8n Workflow Engine** (Deployed on Railway)
   - Main orchestration workflow
   - Token management workflow  
   - Agent routing logic
   - Live URL: https://omnii-agent-swarm-production.up.railway.app

2. **5 Operational AI Agents**
   - Email Agent (Gmail API)
   - Calendar Agent (Google Calendar API)
   - Contact Agent (Google People API)
   - Web Agent (Web search)
   - YouTube Agent (Video search)

3. **Supporting Infrastructure**
   - PostgreSQL database (Railway managed)
   - Supabase authentication (https://auth.omnii.net)
   - OAuth token auto-refresh system
   - User isolation and security

4. **Optional Express Server** (Ready to deploy)
   - Advanced token caching with Redis
   - Rate limiting
   - Additional API endpoints
   - Located in `/src` directory

## üìÅ Project Structure

```
Agent Swarm/
‚îú‚îÄ‚îÄ docker/n8n-instance/      # n8n deployment files
‚îÇ   ‚îú‚îÄ‚îÄ Dockerfile           # Container configuration
‚îÇ   ‚îú‚îÄ‚îÄ workflows/           # 3 n8n workflows (JSON)
‚îÇ   ‚îî‚îÄ‚îÄ scripts/            # Container scripts
‚îÇ
‚îú‚îÄ‚îÄ src/                     # Express API server (optional)
‚îÇ   ‚îú‚îÄ‚îÄ index.ts            # Main server file
‚îÇ   ‚îú‚îÄ‚îÄ api/                # Controllers
‚îÇ   ‚îú‚îÄ‚îÄ auth/               # Token management
‚îÇ   ‚îî‚îÄ‚îÄ utils/              # Logging, scheduling
‚îÇ
‚îú‚îÄ‚îÄ tests/                   # Comprehensive test suite
‚îÇ   ‚îú‚îÄ‚îÄ agents/             # Individual agent tests
‚îÇ   ‚îú‚îÄ‚îÄ calendar/           # Calendar-specific tests
‚îÇ   ‚îî‚îÄ‚îÄ contacts/           # Contact management tests
‚îÇ
‚îî‚îÄ‚îÄ Documentation Files:
    ‚îú‚îÄ‚îÄ AGENT_SWARM_IMPLEMENTATION_PLAN.md
    ‚îú‚îÄ‚îÄ AGENT_SWARM_TECHNICAL_ARCHITECTURE.md
    ‚îú‚îÄ‚îÄ AGENT_SWARM_QUICK_REFERENCE.md
    ‚îî‚îÄ‚îÄ AGENT_SWARM_IMPLEMENTATION_SUMMARY.md
```

## üö¶ Current Status

### ‚úÖ What's Working
- n8n instance deployed and running on Railway
- All 5 agents operational
- Token validation and auto-refresh functioning
- Test user configured with valid OAuth tokens
- PostgreSQL persistence active
- Workflows auto-import on deployment

### ‚ö†Ô∏è Known Limitations
- 10-minute timeout for long operations
- Rate limited to ~30 requests/minute per user
- Requires users to have Google OAuth tokens in Supabase
- Current setup handles ~100 concurrent users

### üîß Recent Fixes Applied
- Fixed X-Forwarded-For header errors with trust proxy
- Improved workflow import process
- Enhanced logging for debugging
- Added duplicate prevention for contacts

## üöÄ Quick Test (Verify It's Working)

Run this command right now to test:

```bash
curl -X POST https://omnii-agent-swarm-production.up.railway.app/webhook/agent-input \
  -H "Content-Type: application/json" \
  -d '{
    "message": "What is 2+2?",
    "user_id": "cd9bdc60-35af-4bb6-b87e-1932e96fb354"
  }'
```

Expected response:
```json
{
  "success": true,
  "agent": "Web Agent",
  "action": "Calculate",
  "result": "4",
  "execution_time": "2.3s"
}
```

## üìù Integration Code (Copy & Paste)

### JavaScript/TypeScript
```javascript
// Basic integration
async function askAgentSwarm(message, userId) {
    const response = await fetch(
        'https://omnii-agent-swarm-production.up.railway.app/webhook/agent-input',
        {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ message, user_id: userId })
        }
    );
    return response.json();
}

// Example usage
const result = await askAgentSwarm(
    "Send an email to test@example.com saying Hello",
    "cd9bdc60-35af-4bb6-b87e-1932e96fb354"
);
console.log(result);
```

### Python
```python
import requests

def ask_agent_swarm(message, user_id):
    response = requests.post(
        'https://omnii-agent-swarm-production.up.railway.app/webhook/agent-input',
        json={'message': message, 'user_id': user_id}
    )
    return response.json()

# Example usage
result = ask_agent_swarm(
    "What's on my calendar today?",
    "cd9bdc60-35af-4bb6-b87e-1932e96fb354"
)
print(result)
```

## üîë Access Credentials

### Railway Dashboard
- Project: Agent Swarm
- Service: omnii-agent-swarm-production
- Region: US West

### n8n Admin Access
- URL: https://omnii-agent-swarm-production.up.railway.app
- Email: rsantin@omnii.net
- Password: Aileen6274!

### Supabase (Token Storage)
- URL: https://auth.omnii.net
- Project: aaxiawuatfajjpvwtjuz
- Keys are configured in Railway environment

### Test User
- User ID: `cd9bdc60-35af-4bb6-b87e-1932e96fb354`
- Has valid Google OAuth tokens
- Full Gmail, Calendar, Contacts permissions

## üõ†Ô∏è Common Tasks

### View Logs
```bash
railway logs --tail 100
```

### Restart Service
```bash
railway restart
```

### Update Environment Variable
```bash
railway variables set KEY=value
```

### Deploy Updates
```bash
cd docker/n8n-instance
railway up
```

### Test Specific Agent
```bash
# Email Agent
curl -X POST https://omnii-agent-swarm-production.up.railway.app/webhook/agent-input \
  -H "Content-Type: application/json" \
  -d '{"message": "Show my latest emails", "user_id": "cd9bdc60-35af-4bb6-b87e-1932e96fb354"}'

# Calendar Agent  
curl -X POST https://omnii-agent-swarm-production.up.railway.app/webhook/agent-input \
  -H "Content-Type: application/json" \
  -d '{"message": "What is on my calendar today?", "user_id": "cd9bdc60-35af-4bb6-b87e-1932e96fb354"}'

# Contact Agent
curl -X POST https://omnii-agent-swarm-production.up.railway.app/webhook/agent-input \
  -H "Content-Type: application/json" \
  -d '{"message": "Find contacts named John", "user_id": "cd9bdc60-35af-4bb6-b87e-1932e96fb354"}'
```

## üêõ Troubleshooting Guide

### Issue: "AUTH_FAILED" Error
**Cause**: User doesn't have OAuth tokens
**Solution**: Check tokens in Supabase
```sql
SELECT * FROM oauth_tokens WHERE user_id = 'user-uuid';
```

### Issue: "TOKEN_EXPIRED" Error
**Cause**: Refresh token is invalid
**Solution**: User needs to re-authenticate with Google

### Issue: Timeout (>10 minutes)
**Cause**: Operation too complex
**Solution**: Break into smaller requests or implement async pattern

### Issue: "Too many requests" Error
**Cause**: Rate limiting triggered
**Solution**: Implement client-side queuing with delays

### Issue: Workflows Missing
**Solution**: Check Railway logs
```bash
railway logs | grep "Workflow Sync"
```

## üìä Performance Metrics

- **Average Response Time**: 2-5 seconds
- **Timeout**: 600 seconds (10 minutes)
- **Rate Limit**: 30 requests/minute/user
- **Concurrent Users**: ~100 (current setup)
- **Uptime**: 99.9% (Railway SLA)

## üîÑ Next Steps (Priority Order)

### Week 1 - Basic Integration
1. [ ] Test with your actual user accounts
2. [ ] Implement error handling for all error codes
3. [ ] Add loading indicators for long operations
4. [ ] Create basic UI for agent interactions

### Week 2 - Enhanced Features
1. [ ] Add retry logic with exponential backoff
2. [ ] Implement client-side caching
3. [ ] Create agent-specific UI components
4. [ ] Add request/response logging

### Week 3 - Production Ready
1. [ ] Set up monitoring and alerts
2. [ ] Document rate limits for users
3. [ ] Create user onboarding flow
4. [ ] Implement analytics tracking

### Month 2+ - Advanced Features
1. [ ] Deploy Express server for caching (optional)
2. [ ] Implement webhook callbacks for async
3. [ ] Build conversation history system
4. [ ] Create custom workflows for your use cases

## üö® Important Notes

1. **OAuth Tokens**: Users MUST have valid Google OAuth tokens in Supabase
2. **Rate Limits**: Google APIs have quotas - monitor usage
3. **Costs**: Railway charges for compute and bandwidth
4. **Security**: Never expose tokens client-side
5. **Scaling**: For >100 users, consider multiple n8n instances

## üìû Support Resources

### Documentation
- `/AGENT_SWARM_IMPLEMENTATION_PLAN.md` - Complete guide
- `/AGENT_SWARM_TECHNICAL_ARCHITECTURE.md` - System design
- `/AGENT_SWARM_QUICK_REFERENCE.md` - Code snippets
- `.cursor/rules/app-implementation.mdc` - Cursor AI assistant rules

### External Resources
- Railway Status: https://railway.app/status
- n8n Documentation: https://docs.n8n.io
- Google API Quotas: https://console.cloud.google.com/apis

### Test Scripts
All test scripts are in `/tests` directory:
- `run-all-tests.sh` - Complete test suite
- Individual agent tests in `/tests/agents/`

## ‚úÖ Handover Checklist

### For the Receiving Developer:
- [ ] Run the quick test command above
- [ ] Access n8n UI with provided credentials
- [ ] Review the 4 main documentation files
- [ ] Try each agent with test commands
- [ ] Check Railway logs for any errors
- [ ] Review the codebase structure
- [ ] Test with a real user account (if available)

### System Health Checks:
- [ ] n8n webhook responding
- [ ] Workflows visible in n8n UI
- [ ] PostgreSQL connected
- [ ] Supabase authentication working
- [ ] Token refresh functioning

## üéØ Success Criteria

You'll know the handover is complete when you can:
1. Successfully call the webhook endpoint
2. Receive responses from all 5 agents
3. View execution history in n8n UI
4. Understand the token flow
5. Deploy updates via Railway

## Final Notes

The Agent Swarm is production-ready and actively running. The architecture is designed for maintainability and scalability. Start with simple integrations and gradually add complexity based on your needs.

The system has been battle-tested with comprehensive test suites. All critical issues have been resolved. The optional Express server in `/src` provides additional capabilities if needed, but the core n8n system is fully functional without it.

**Remember**: This is a living system. Monitor the logs, track usage patterns, and iterate based on user feedback.

---

*Handover prepared on: January 2025*
*System Status: ‚úÖ Operational*
*Last Tested: Working with test user*
