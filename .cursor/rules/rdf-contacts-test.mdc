---
description: 
globs: 
alwaysApply: false
---
# RDF Contact Resolution Test Suite

## Overview
Comprehensive test suite for Test-Driven Development of the RDF-driven contact resolution system with Neo4j Brain Memory integration using **Bun Test Runner**.

## Bun Test Configuration

### bunfig.toml
```toml
[test]
# Test configuration
coverage = true
timeout = 10000
preload = ["./tests/setup.ts"]

# Test file patterns
include = ["tests/**/*.test.ts", "tests/**/*.spec.ts"]
exclude = ["node_modules", "dist"]
```

### Test Setup (tests/setup.ts)
```typescript
// Global test setup for Bun
import { beforeAll, afterAll } from "bun:test";

// Global test configuration
beforeAll(() => {
  console.log("ðŸ§ª Starting RDF Contact Resolution Test Suite");
  // Setup global mocks, test databases, etc.
});

afterAll(() => {
  console.log("âœ… Test suite completed");
  // Cleanup global resources
});
```

## Test Architecture

### Test Categories
1. **Unit Tests** - Individual component testing
2. **Integration Tests** - End-to-end flow testing
3. **Performance Tests** - Response time and scalability
4. **Mock Data Tests** - Realistic scenarios with test data

## Core Component Tests

### 1. RDF Message Analysis Tests

```typescript
// tests/unit/rdf-contact-analyzer.test.ts
import { describe, test, expect, beforeEach } from "bun:test";
import { RDFContactAnalyzer } from '../../src/services/rdf-contact-analyzer';
import { MessageAnalysis } from '../../src/types/contact-resolution';

describe('RDFContactAnalyzer - Message Analysis', () => {
  let analyzer: RDFContactAnalyzer;
  
  beforeEach(() => {
    analyzer = new RDFContactAnalyzer();
  });

  describe('analyzeMessage', () => {
    test('should extract contact and intent from simple email request', async () => {
      const message = "Send Eden an email about the quarterly report";
      
      const result = await analyzer.analyzeMessage(message);
      
      expect(result).toEqual({
        primary_contact: "Eden",
        intent: "send_email",
        context_clues: expect.arrayContaining(["quarterly", "report"]),
        formality: "business",
        urgency: "normal",
        additional_context: expect.stringContaining("work-related"),
        confidence: expect.any(Number)
      });
      
      expect(result.confidence).toBeGreaterThan(0.8);
    });

    test('should handle casual text message requests', async () => {
      const message = "Text Mike about dinner tonight";
      
      const result = await analyzer.analyzeMessage(message);
      
      expect(result).toEqual({
        primary_contact: "Mike",
        intent: "send_text",
        context_clues: expect.arrayContaining(["dinner", "tonight"]),
        formality: "casual",
        urgency: "normal",
        additional_context: expect.stringContaining("personal"),
        confidence: expect.any(Number)
      });
    });

    test('should detect urgency indicators', async () => {
      const message = "URGENT: Call Dr. Smith immediately about test results";
      
      const result = await analyzer.analyzeMessage(message);
      
      expect(result.urgency).toBe("urgent");
      expect(result.intent).toBe("make_call");
      expect(result.formality).toBe("formal");
    });

    test('should handle ambiguous contact references', async () => {
      const message = "Remind me to follow up with J about the project";
      
      const result = await analyzer.analyzeMessage(message);
      
      expect(result.primary_contact).toBe("J");
      expect(result.confidence).toBeLessThan(0.6); // Low confidence for single letter
    });
  });
});
```

### 2. Contact Name Expansion Tests

```typescript
// tests/unit/contact-name-expansion.test.ts
import { describe, test, expect } from "bun:test";

describe('RDFContactAnalyzer - Name Expansion', () => {
  test('should generate comprehensive name variations', async () => {
    const contactName = "Eden";
    const messageContext = {
      intent: "send_email",
      formality: "business",
      relationship_context: "professional"
    };
    
    const variations = await analyzer.expandContactName(contactName, messageContext);
    
    expect(variations).toEqual(
      expect.arrayContaining([
        { name: "Eden", confidence: 1.0, type: "exact" },
        { name: "Edan", confidence: expect.any(Number), type: "phonetic" },
        { name: "Aiden", confidence: expect.any(Number), type: "similar" },
        { name: "Ethan", confidence: expect.any(Number), type: "similar_sound" }
      ])
    );
    
    // Verify exact match has highest confidence
    const exactMatch = variations.find(v => v.type === "exact");
    expect(exactMatch?.confidence).toBe(1.0);
    
    // Verify variations are sorted by confidence
    for (let i = 1; i < variations.length; i++) {
      expect(variations[i-1].confidence).toBeGreaterThanOrEqual(variations[i].confidence);
    }
  });

  test('should consider cultural and linguistic variations', async () => {
    const variations = await analyzer.expandContactName("Maria", {
      intent: "send_email",
      formality: "neutral"
    });
    
    expect(variations.map(v => v.name)).toEqual(
      expect.arrayContaining(["Maria", "Marie", "Mary", "Mariah", "MÃ¡ria"])
    );
  });
});
```

### 3. Neo4j Brain Memory Integration Tests

```typescript
// tests/unit/brain-memory-contact-enhancer.test.ts
import { describe, test, expect, beforeEach } from "bun:test";
import { BrainMemoryContactEnhancer } from '../../src/services/brain-memory-contact-enhancer';
import { MockNeo4jDriver } from '../mocks/neo4j-driver.mock';

describe('BrainMemoryContactEnhancer', () => {
  let enhancer: BrainMemoryContactEnhancer;
  let mockDriver: MockNeo4jDriver;

  beforeEach(() => {
    mockDriver = new MockNeo4jDriver();
    enhancer = new BrainMemoryContactEnhancer(mockDriver);
  });

  describe('getTemporalContactContext', () => {
    test('should extract past week communication patterns', async () => {
      // Mock Neo4j responses
      mockDriver.mockQuery('past_week_communications', [
        {
          'msg.content': 'Hey Eden, can we move the meeting to 3pm?',
          'msg.channel': 'email',
          'msg.timestamp': new Date(Date.now() - 2 * 24 * 60 * 60 * 1000), // 2 days ago
          'msg.intent': 'schedule_meeting',
          'msg.sentiment': 'neutral',
          'msg.importance_score': 0.7,
          'mentioned_concepts': ['meeting', 'schedule']
        },
        {
          'msg.content': 'Eden - quarterly report is ready for review',
          'msg.channel': 'email', 
          'msg.timestamp': new Date(Date.now() - 5 * 24 * 60 * 60 * 1000), // 5 days ago
          'msg.intent': 'share_document',
          'msg.sentiment': 'positive',
          'msg.importance_score': 0.8,
          'mentioned_concepts': ['report', 'review']
        }
      ]);

      const result = await enhancer.getTemporalContactContext('user123', 'Eden');

      expect(result.past_week.interaction_count).toBe(2);
      expect(result.past_week.primary_channels).toContain('email');
      expect(result.past_week.topics).toContain('meeting');
      expect(result.past_week.average_sentiment).toBeCloseTo(0.75); // Average of neutral(0.5) and positive(1.0)
    });

    test('should identify current week activity trends', async () => {
      mockDriver.mockQuery('current_week_activity', [
        {
          'msg.content': 'Eden, following up on our call yesterday',
          'msg.channel': 'email',
          'msg.timestamp': new Date(Date.now() - 1 * 24 * 60 * 60 * 1000), // 1 day ago
          'interaction_frequency': 3
        }
      ]);

      const result = await enhancer.getTemporalContactContext('user123', 'Eden');

      expect(result.current_week.active_conversations).toBe(1);
      expect(result.current_week.frequency_trend).toBe('increasing'); // Based on frequency of 3
    });

    test('should detect future scheduled interactions', async () => {
      mockDriver.mockQuery('future_interactions', [
        {
          'msg.content': 'Calendar: Meeting with Eden tomorrow at 2pm',
          'msg.timestamp': new Date(),
          'concept.name': 'calendar_event',
          'concept.activation_strength': 0.9,
          'time_concepts': ['meeting', 'tomorrow']
        }
      ]);

      const result = await enhancer.getTemporalContactContext('user123', 'Eden');

      expect(result.future_week.upcoming_events).toHaveLength(1);
      expect(result.future_week.upcoming_events[0]).toMatchObject({
        type: 'meeting',
        timeframe: 'tomorrow'
      });
    });
  });

  describe('getCommunicationPatterns', () => {
    test('should identify preferred communication channels', async () => {
      mockDriver.mockQuery('communication_patterns', [
        { normalized_channel: 'email', usage_count: 15, avg_importance: 0.8 },
        { normalized_channel: 'text', usage_count: 3, avg_importance: 0.4 },
        { normalized_channel: 'chat', usage_count: 1, avg_importance: 0.3 }
      ]);

      const result = await enhancer.getCommunicationPatterns('user123', 'Eden');

      expect(result.preferred_channels[0]).toMatchObject({
        channel: 'email',
        usage_percentage: expect.any(Number),
        avg_importance: 0.8
      });
      
      expect(result.preferred_channels[0].usage_percentage).toBeGreaterThan(0.7); // 15/19 = ~79%
    });

    test('should detect relationship context from concept co-occurrence', async () => {
      mockDriver.mockQuery('relationship_indicators', [
        { 
          'concept.name': 'work', 
          co_occurrence_count: 8, 
          relationship_indicator: 'professional' 
        },
        { 
          'concept.name': 'meeting', 
          co_occurrence_count: 6, 
          relationship_indicator: 'professional' 
        },
        { 
          'concept.name': 'project', 
          co_occurrence_count: 4, 
          relationship_indicator: 'professional' 
        }
      ]);

      const result = await enhancer.getCommunicationPatterns('user123', 'Eden');

      expect(result.relationship_indicators.primary_context).toBe('professional');
      expect(result.relationship_indicators.context_match).toBeGreaterThan(0.8);
    });
  });
});
```

### 4. Contact Confidence Boosting Tests

```typescript
// tests/unit/contact-confidence-booster.test.ts
import { describe, test, expect, beforeEach } from "bun:test";

describe('ContactConfidenceBooster', () => {
  let booster: ContactConfidenceBooster;

  beforeEach(() => {
    booster = new ContactConfidenceBooster();
  });

  test('should boost confidence based on recent communication', () => {
    const baseConfidence = 0.6;
    const temporalContext = {
      past_week: { interaction_count: 3 },
      current_week: { active_conversations: 1 },
      future_week: { scheduled_interactions: [] }
    };
    const communicationPatterns = {
      preferred_channels: [{ channel: 'email', usage_percentage: 0.8 }],
      relationship_indicators: { context_match: 0.9, primary_context: 'professional' }
    };
    const brainMemoryContext = {
      semantic_memory: { activated_concepts: [{ activation_strength: 0.8 }] }
    };

    const result = booster.calculateEnhancedConfidence(
      baseConfidence,
      temporalContext,
      communicationPatterns,
      brainMemoryContext
    );

    expect(result.enhanced_confidence).toBeGreaterThan(baseConfidence);
    expect(result.total_boost).toBeGreaterThan(0);
    expect(result.boost_factors).toEqual(
      expect.arrayContaining([
        expect.objectContaining({ type: 'recent_communication' }),
        expect.objectContaining({ type: 'current_activity' }),
        expect.objectContaining({ type: 'relationship_context' })
      ])
    );
  });

  test('should cap enhanced confidence at 0.95', () => {
    const baseConfidence = 0.8;
    const temporalContext = {
      past_week: { interaction_count: 10 }, // Very high interaction
      current_week: { active_conversations: 5 },
      future_week: { scheduled_interactions: [1, 2, 3] }
    };

    const result = booster.calculateEnhancedConfidence(
      baseConfidence,
      temporalContext,
      {} as any,
      {} as any
    );

    expect(result.enhanced_confidence).toBeLessThanOrEqual(0.95);
  });
});
```

## Integration Tests

### 5. End-to-End Contact Resolution Tests

```typescript
// tests/integration/contact-resolution-flow.test.ts
import { describe, test, expect, beforeEach } from "bun:test";
import type { ActionPlanner } from '../../src/services/action-planner';
import { MockGoogleContactsService, MockBrainMemoryService } from '../mocks/mock-services';

describe('Contact Resolution Flow Integration', () => {
  let actionPlanner: ActionPlanner;
  let mockGoogleContacts: MockGoogleContactsService;
  let mockBrainMemory: MockBrainMemoryService;

  beforeEach(() => {
    mockGoogleContacts = new MockGoogleContactsService();
    mockBrainMemory = new MockBrainMemoryService();
    actionPlanner = new ActionPlanner({
      googleContacts: mockGoogleContacts,
      brainMemory: mockBrainMemory
    });
  });

  test('should resolve contact with high confidence and auto-execute', async () => {
    // Setup mock data
    mockGoogleContacts.addContact({
      name: 'Eden Chen',
      email: 'eden.chen@company.com',
      title: 'Product Manager'
    });

    mockBrainMemory.addTemporalContext('user123', 'Eden', {
      past_week: { interaction_count: 3 },
      current_week: { active_conversations: 1 }
    });

    const message = "Send Eden an email about the quarterly report";
    const plan = await actionPlanner.createPlan(message, undefined, 'user123');

    expect(plan.steps).toHaveLength(1);
    expect(plan.steps[0]).toMatchObject({
      type: 'email',
      recipient: 'eden.chen@company.com',
      subject: expect.stringContaining('Quarterly Report'),
      confidence: expect.any(Number)
    });

    expect(plan.steps[0].confidence).toBeGreaterThan(0.8);
  });

  test('should create intervention when confidence is low', async () => {
    // Setup multiple potential matches
    mockGoogleContacts.addContact({
      name: 'Eden Chen',
      email: 'eden.chen@company.com'
    });
    mockGoogleContacts.addContact({
      name: 'Eden Martinez', 
      email: 'eden.martinez@personal.com'
    });

    // No recent communication history
    mockBrainMemory.addTemporalContext('user123', 'Eden', {
      past_week: { interaction_count: 0 },
      current_week: { active_conversations: 0 }
    });

    const message = "Send Eden a message";
    const plan = await actionPlanner.createPlan(message, undefined, 'user123');

    expect(plan.steps).toHaveLength(1);
    expect(plan.steps[0].type).toBe('user_intervention');
    expect(plan.steps[0].interventionMessage).toContain('I found 2 possible matches');
    expect(plan.steps[0].alternatives).toHaveLength(2);
  });

  test('should personalize communication based on historical patterns', async () => {
    mockGoogleContacts.addContact({
      name: 'Eden Chen',
      email: 'eden.chen@company.com'
    });

    mockBrainMemory.addCommunicationStyle('user123', 'Eden', {
      formality_level: 'casual',
      preferred_greeting: 'Hi',
      typical_message_length: 'brief'
    });

    const message = "Email Eden about the meeting tomorrow";
    const plan = await actionPlanner.createPlan(message, undefined, 'user123');

    expect(plan.steps[0].body).toMatch(/^Hi Eden,/); // Should use casual greeting
    expect(plan.steps[0].body.split(' ').length).toBeLessThan(50); // Brief message
  });
});
```

## Performance Tests

### 6. Performance and Scalability Tests

```typescript
// tests/performance/contact-resolution-performance.test.ts
import { describe, test, expect } from "bun:test";

describe('Contact Resolution Performance', () => {
  test('should resolve contact within 2 seconds', async () => {
    const startTime = Date.now();
    
    const message = "Send Eden an email about the quarterly report";
    await actionPlanner.createPlan(message, undefined, 'user123');
    
    const executionTime = Date.now() - startTime;
    expect(executionTime).toBeLessThan(2000); // 2 seconds
  });

  test('should handle batch contact resolution efficiently', async () => {
    const messages = [
      "Email Eden about the report",
      "Text Mike about dinner", 
      "Call Sarah about the project",
      "Send Alex the documents",
      "Message Jordan about the meeting"
    ];

    const startTime = Date.now();
    
    const plans = await Promise.all(
      messages.map(msg => actionPlanner.createPlan(msg, undefined, 'user123'))
    );
    
    const executionTime = Date.now() - startTime;
    expect(executionTime).toBeLessThan(5000); // 5 seconds for 5 contacts
    expect(plans).toHaveLength(5);
  });

  test('should cache RDF analysis results', async () => {
    const message = "Send Eden an email about the quarterly report";
    
    // First call
    const startTime1 = Date.now();
    await actionPlanner.createPlan(message, undefined, 'user123');
    const firstCallTime = Date.now() - startTime1;
    
    // Second call (should be cached)
    const startTime2 = Date.now();
    await actionPlanner.createPlan(message, undefined, 'user123');
    const secondCallTime = Date.now() - startTime2;
    
    expect(secondCallTime).toBeLessThan(firstCallTime * 0.5); // At least 50% faster
  });
});
```

## Mock Data and Test Scenarios

### 7. Realistic Test Scenarios

```typescript
// tests/scenarios/realistic-contact-scenarios.test.ts
import { describe, test, expect } from "bun:test";

describe('Realistic Contact Resolution Scenarios', () => {
  const testScenarios = [
    {
      name: 'Work colleague with recent interaction',
      message: 'Email Sarah about the budget review',
      expectedContact: 'sarah.johnson@company.com',
      brainMemorySetup: {
        pastWeekInteractions: 2,
        primaryChannel: 'email',
        relationshipContext: 'professional'
      },
      expectedConfidence: 0.85
    },
    {
      name: 'Family member personal communication',
      message: 'Text mom about dinner Sunday',
      expectedContact: '+1234567890',
      brainMemorySetup: {
        pastWeekInteractions: 5,
        primaryChannel: 'text',
        relationshipContext: 'family'
      },
      expectedConfidence: 0.9
    },
    {
      name: 'New contact with no history',
      message: 'Send Alex Thompson the presentation',
      expectedBehavior: 'intervention',
      brainMemorySetup: {
        pastWeekInteractions: 0,
        primaryChannel: null,
        relationshipContext: 'unknown'
      },
      expectedConfidence: 0.3
    }
  ];

  testScenarios.forEach(scenario => {
    test(`should handle: ${scenario.name}`, async () => {
      // Setup mock data based on scenario
      setupScenario(scenario);
      
      const plan = await actionPlanner.createPlan(
        scenario.message, 
        undefined, 
        'user123'
      );

      if (scenario.expectedBehavior === 'intervention') {
        expect(plan.steps[0].type).toBe('user_intervention');
      } else {
        expect(plan.steps[0].recipient).toBe(scenario.expectedContact);
        expect(plan.steps[0].confidence).toBeGreaterThan(scenario.expectedConfidence);
      }
    });
  });
});
```

## Test Utilities and Mocks

### 8. Mock Services

```typescript
// tests/mocks/mock-services.ts
export class MockGoogleContactsService {
  private contacts: Contact[] = [];

  addContact(contact: Contact) {
    this.contacts.push(contact);
  }

  async searchContacts(query: string): Promise<Contact[]> {
    return this.contacts.filter(contact => 
      contact.name.toLowerCase().includes(query.toLowerCase()) ||
      (contact.email && contact.email.toLowerCase().includes(query.toLowerCase()))
    );
  }
}

export class MockBrainMemoryService {
  private temporalContexts = new Map<string, any>();
  private communicationStyles = new Map<string, any>();

  addTemporalContext(userId: string, contactName: string, context: any) {
    this.temporalContexts.set(`${userId}:${contactName}`, context);
  }

  async getTemporalContactContext(userId: string, contactName: string) {
    return this.temporalContexts.get(`${userId}:${contactName}`) || {
      past_week: { interaction_count: 0 },
      current_week: { active_conversations: 0 },
      future_week: { scheduled_interactions: [] }
    };
  }
}

export class MockNeo4jDriver {
  private queryMocks = new Map<string, any[]>();

  mockQuery(queryName: string, results: any[]) {
    this.queryMocks.set(queryName, results);
  }

  session() {
    return {
      run: async (query: string, params: any) => {
        // Simple mock implementation
        const mockKey = this.identifyQuery(query);
        const results = this.queryMocks.get(mockKey) || [];
        
        return {
          records: results.map(result => ({
            get: (key: string) => result[key]
          }))
        };
      },
      close: async () => {}
    };
  }

  private identifyQuery(query: string): string {
    if (query.includes('msg.timestamp > datetime() - duration({days: 7})')) {
      return 'past_week_communications';
    }
    if (query.includes('normalized_channel')) {
      return 'communication_patterns';
    }
    return 'unknown_query';
  }
}
```

## Test Execution Plan

### 9. TDD Implementation Order

```typescript
// Test execution order for TDD implementation:
import { describe, test } from "bun:test";

describe('TDD Implementation Plan', () => {
  test('Phase 1: Core RDF Analysis', () => {
    // 1. Message semantic analysis
    // 2. Contact name expansion 
    // 3. Basic contact resolution
  });

  test('Phase 2: Brain Memory Integration', () => {
    // 1. Temporal context extraction
    // 2. Communication pattern analysis
    // 3. Confidence boosting algorithm
  });

  test('Phase 3: ActionPlanner Integration', () => {
    // 1. Entity resolution enhancement
    // 2. Personalized communication generation
    // 3. Smart intervention logic
  });

  test('Phase 4: Performance & Polish', () => {
    // 1. Caching and optimization
    // 2. Error handling and edge cases
    // 3. User experience improvements
  });
});
```

## Running the Tests

```bash
# Install Bun (if not already installed)
curl -fsSL https://bun.sh/install | bash

# Install test dependencies (Bun has built-in test runner)
bun install --dev @types/bun

# Run all tests
bun test

# Run specific test suites
bun test tests/unit/
bun test tests/integration/
bun test tests/performance/

# Run tests with coverage
bun test --coverage

# Watch mode for TDD
bun test --watch

# Run tests matching a pattern
bun test --grep "RDFContactAnalyzer"
bun test --grep "BrainMemoryContactEnhancer"
```

## Package.json Scripts

```json
{
  "scripts": {
    "test": "bun test",
    "test:unit": "bun test tests/unit/",
    "test:integration": "bun test tests/integration/", 
    "test:performance": "bun test tests/performance/",
    "test:watch": "bun test --watch",
    "test:coverage": "bun test --coverage",
    "test:verbose": "bun test --verbose",
    "test:rdf": "bun test --grep RDF",
    "test:brain": "bun test --grep Brain"
  },
  "devDependencies": {
    "@types/bun": "latest",
    "bun-types": "latest"
  }
}
```

## Bun-Specific Optimizations

### Fast Test Execution
```typescript
// tests/utils/bun-optimizations.ts
import { spawnSync } from "bun";

// Parallel test execution for performance tests
export async function runParallelTests(testFiles: string[]) {
  const processes = testFiles.map(file => 
    spawnSync(["bun", "test", file], { 
      stdio: ["inherit", "inherit", "inherit"] 
    })
  );
  
  return Promise.all(processes);
}

// Fast mock data generation using Bun's built-in performance
export function generateMockData(count: number) {
  return Array.from({ length: count }, (_, i) => ({
    id: `contact_${i}`,
    name: `Test Contact ${i}`,
    email: `test${i}@example.com`,
    timestamp: new Date(Date.now() - i * 24 * 60 * 60 * 1000)
  }));
}
```

### Memory-Efficient Testing
```typescript
// tests/setup.ts - Enhanced for Bun
import { beforeAll, afterAll, afterEach } from "bun:test";

beforeAll(() => {
  // Bun-specific optimizations
  process.env.BUN_JSC_forceRAMSize = "2GB";
  console.log("ðŸš€ Bun Test Suite Starting with optimized memory");
});

afterEach(() => {
  // Force garbage collection between tests for consistent memory usage
  if (global.gc) {
    global.gc();
  }
});

afterAll(() => {
  console.log("âœ… All tests completed successfully");
});
```

This comprehensive test suite enables true Test-Driven Development for the RDF contact resolution system using **Bun's lightning-fast test runner**, ensuring each component works correctly and integrates seamlessly with the Neo4j brain memory system.
