---
description: WebSocket vs HTTP Architecture Analysis & Implementation Plan
globs: ["apps/omnii-mobile/src/**", "apps/omnii_mcp/src/**"]
alwaysApply: false
---

# ğŸ”„ WebSocket vs HTTP Architecture Analysis & Implementation Plan

## ğŸš¨ **Current WebSocket Issues (Multiple Users)**

### **Scalability Problems**
```typescript
// Current implementation - SINGLE MAP FOR ALL USERS
private connections = new Map<string, ElysiaWebSocket>() // âŒ All users in one map
```

**Issues with Multiple Users:**
- âŒ **Memory Leaks**: Disconnected WebSockets not properly cleaned up
- âŒ **Railway Scaling**: Each Railway instance maintains separate connection maps
- âŒ **Connection Limits**: Railway has WebSocket connection limits per instance
- âŒ **State Loss**: When Railway scales up/down, WebSocket connections are lost
- âŒ **No Load Balancing**: WebSocket connections stick to specific Railway instances

### **Chat State Problems**
- âŒ **Navigation Resets**: Chat history lost when switching tabs
- âŒ **Connection Drops**: WebSocket disconnects on app backgrounding
- âŒ **No Persistence**: Messages only exist in memory, lost on reconnection
- âŒ **Race Conditions**: Multiple users can overwrite each other's state

## ğŸ“Š **Architecture Comparison**

### **WebSocket Architecture (Current)**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    WebSocket     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    Direct Call    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Mobile App  â”‚ â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º â”‚ Railway API â”‚ â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º â”‚ n8n Agents  â”‚
â”‚ (User 1)    â”‚                  â”‚ Instance 1  â”‚                   â”‚             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Mobile App  â”‚ â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º â”‚ Railway API â”‚ 
â”‚ (User 2)    â”‚                  â”‚ Instance 2  â”‚ âŒ Different instance!
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Problems:**
- Users can end up on different Railway instances
- No shared state between instances
- WebSocket connections lost during scaling
- n8n requests tied to specific instances

### **HTTP + SSE Architecture (Proposed)**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    HTTP POST     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    HTTP POST     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Mobile App  â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º â”‚ Railway API  â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º â”‚ n8n Agents  â”‚
â”‚ (Any User)  â”‚                  â”‚ (Any Instanceâ”‚                   â”‚             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚                                â”‚                                   â”‚
       â”‚ Server-Sent Events             â”‚ Database                          â”‚
       â”‚ (Progress Updates)             â”‚ (Shared State)                    â”‚
       â–¼                                â–¼                                   â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Real-time   â”‚                  â”‚ Supabase DB  â”‚                   â”‚ Webhook     â”‚
â”‚ Updates     â”‚                  â”‚ (Chat Historyâ”‚                   â”‚ Callbacks   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Benefits:**
- âœ… Any Railway instance can handle any user
- âœ… Shared state via database
- âœ… Automatic load balancing
- âœ… Chat history persistence
- âœ… Better n8n integration

## ğŸ¯ **Detailed Architecture Comparison**

| Feature | WebSocket (Current) | HTTP + SSE (Proposed) |
|---------|--------------------|-----------------------|
| **Multiple Users** | âŒ Connection map per instance | âœ… Stateless, any instance |
| **Railway Scaling** | âŒ Connections lost on scale | âœ… Seamless scaling |
| **Chat Persistence** | âŒ Memory only, resets | âœ… Database stored |
| **n8n Integration** | âŒ Instance-specific | âœ… Any instance can handle |
| **Connection Reliability** | âŒ Drops on navigation | âœ… Stateless HTTP calls |
| **Real-time Updates** | âœ… Instant via WebSocket | âœ… Near-instant via SSE |
| **Complexity** | âŒ High (connection mgmt) | âœ… Lower (stateless) |
| **Mobile Battery** | âŒ Constant connection | âœ… Only when needed |

## ğŸš€ **Recommended Architecture: HTTP + SSE**

### **Why HTTP is Better for Multiple Users:**

1. **Railway Scaling**: HTTP requests can hit any Railway instance
2. **State Persistence**: Chat history stored in Supabase, survives restarts
3. **Load Balancing**: Railway automatically balances HTTP requests
4. **n8n Integration**: Direct HTTP calls to n8n, webhooks for responses
5. **Mobile Friendly**: No persistent connections to maintain

### **User Experience Impact:**

**What Users Will Notice (POSITIVE):**
- âœ… **Chat Never Resets**: History persists across navigation
- âœ… **Faster Initial Load**: No WebSocket connection delay
- âœ… **Better Battery Life**: No persistent connection drain
- âœ… **More Reliable**: Works even with poor network connections
- âœ… **Instant n8n Responses**: Direct integration, no proxy

**What Users Won't Notice:**
- ğŸ”„ **Real-time Feel**: SSE provides same instant updates
- ğŸ”„ **Response Speed**: HTTP can be faster than WebSocket for single requests
- ğŸ”„ **UI Experience**: Same chat interface, different backend

## ğŸ“‹ **Implementation Plan Based on Current Codebase**

### **Current Architecture Analysis:**
- âœ… **Mobile App**: Uses `ChatService` class with WebSocket connection
- âœ… **Backend**: `EnhancedWebSocketHandler` processes messages via WebSocket
- âœ… **Database**: Has Drizzle ORM with PostgreSQL (Vercel Postgres)
- âœ… **Brain Memory**: `BrainConversationManager` stores chat in Neo4j
- âœ… **Action Planning**: `ActionPlanner` processes messages and creates steps
- âœ… **n8n Integration**: Already implemented with routing logic

### **Phase 1: Add HTTP Chat Endpoints (Week 1)**

#### **1.1 Create New HTTP Routes (apps/omnii_mcp/src/routes/)**
- Add `chat-http.ts` route file alongside existing routes
- Integrate with existing `ActionPlanner` and `EnhancedWebSocketHandler` logic
- Use existing `BrainConversationManager` for chat persistence
- Reuse existing n8n integration from `n8n-agent-executor.ts`

#### **1.2 Database Schema Addition (packages/db/src/)**
- Add chat tables to existing `schema.ts` file
- Use existing Drizzle ORM setup
- Integrate with current user authentication system

#### **1.3 Leverage Existing Systems**
- **Chat Persistence**: Use existing `BrainConversationManager.storeChatConversation()` 
- **Message Processing**: Reuse existing `ActionPlanner.createPlan()` logic
- **n8n Integration**: Use existing `N8nAgentStepExecutor` and routing
- **Database**: Add chat tables to existing Drizzle schema in `packages/db/src/schema.ts`

### **Phase 2: Enhance Existing n8n Integration (Week 2)**

#### **2.1 Modify Current n8n Integration**
- **Current**: `N8nAgentStepExecutor` already exists and works
- **Enhancement**: Add HTTP webhook callbacks for progress updates
- **Current**: `EnhancedWebSocketHandler.shouldRouteToN8nAgent()` already routes correctly
- **Enhancement**: Add progress tracking via Server-Sent Events

#### **2.2 Add Progress Tracking to Existing System**
- **Current**: n8n requests go through existing `N8nAgentClient`
- **Enhancement**: Add webhook endpoints for n8n to send progress updates
- **Current**: Mobile app already has n8n UI components (`N8nAgentComponents.tsx`)
- **Enhancement**: Add progress indicators to existing components

### **Phase 3: Modify Mobile App to Use HTTP (Week 3)**

#### **3.1 Update Current ChatService Class**
- **Current**: `apps/omnii-mobile/src/services/chat/ChatService.ts` uses WebSocket
- **Change**: Add HTTP mode option to existing `ChatService` class
- **Current**: `apps/omnii-mobile/src/hooks/useChat.ts` creates WebSocket connection
- **Change**: Modify to use HTTP + Server-Sent Events instead

#### **3.2 Modify Existing Chat Components**
- **Current**: `apps/omnii-mobile/src/app/(tabs)/chat.tsx` uses `useChatState()` hook
- **Keep**: Same UI, same components, same user experience
- **Change**: Backend communication method only (WebSocket â†’ HTTP)
- **Current**: `apps/omnii-mobile/src/components/chat/N8nAgentComponents.tsx` exists
- **Enhancement**: Add progress indicators to existing components

### **Phase 4: Production Optimization (Week 4)**

#### **4.1 Use Existing Caching Systems**
- **Current**: Redis is already configured and used in the system
- **Enhancement**: Add chat response caching to existing Redis setup
- **Current**: Brain memory cache system already exists
- **Integration**: Use existing cache patterns for chat responses

#### **4.2 Use Existing Security & Rate Limiting**
- **Current**: Authentication system already exists with Supabase
- **Current**: User management already implemented
- **Enhancement**: Add rate limiting to new HTTP chat endpoints

## ğŸ¯ **Migration Strategy Based on Current Codebase**

### **Step 1: Add HTTP Alongside WebSocket**
- **Keep**: All existing WebSocket functionality (`EnhancedWebSocketHandler`, `ChatService`)
- **Add**: New HTTP endpoints that use same backend logic
- **Test**: HTTP system with development users first

### **Step 2: Mobile App Feature Flag**
- **Current**: `apps/omnii-mobile/src/lib/env.ts` handles environment configuration
- **Add**: Feature flag to switch between WebSocket and HTTP modes
- **Test**: A/B test with subset of users

### **Step 3: Gradual Migration**
- **Monitor**: Chat reset issues, connection stability, user feedback
- **Migrate**: Move users to HTTP mode gradually
- **Keep**: WebSocket as fallback during transition

### **Step 4: Complete Migration**
- **Remove**: WebSocket chat code after HTTP is stable
- **Keep**: All existing backend logic (ActionPlanner, n8n integration, etc.)
- **Optimize**: Based on HTTP usage patterns

## âœ… **Success Metrics**

### **Technical Metrics**
- âœ… Chat history persists across navigation (100% retention)
- âœ… n8n response time under 30 seconds (95th percentile)
- âœ… System supports 1000+ concurrent users
- âœ… Railway auto-scaling works seamlessly

### **User Experience Metrics**
- âœ… Reduced chat resets to 0%
- âœ… Faster initial chat load (< 2 seconds)
- âœ… Improved mobile battery life
- âœ… Better n8n task completion rates

## ğŸš¨ **Risks & Mitigation**

### **Potential Risks**
1. **SSE Browser Compatibility**: Older browsers might not support SSE
2. **Real-time Feel**: HTTP might feel less responsive than WebSocket
3. **Development Time**: Complete rewrite takes significant effort

### **Mitigation Strategies**
1. **SSE Fallback**: Implement polling fallback for unsupported browsers
2. **Optimistic UI**: Show user messages immediately, confirm via HTTP
3. **Phased Rollout**: Implement gradually, maintain backward compatibility

## ğŸ‰ **Conclusion: Leverage Existing Architecture**

**HTTP + SSE is the right approach, and we can reuse most existing code:**

### **What We Keep (90% of current code):**
- âœ… **All Backend Logic**: `ActionPlanner`, `BrainConversationManager`, `N8nAgentStepExecutor`
- âœ… **All Mobile UI**: Chat components, n8n components, user interface
- âœ… **All Integrations**: Google services, Neo4j brain memory, Redis cache
- âœ… **All Authentication**: Supabase auth, user management

### **What We Add (10% new code):**
- âœ… **HTTP Routes**: New endpoints that call existing backend logic
- âœ… **Chat Persistence**: Database tables using existing Drizzle setup
- âœ… **Server-Sent Events**: For real-time updates (replaces WebSocket)
- âœ… **Mobile HTTP Client**: Modify existing `ChatService` class

### **Why This Works:**
1. **Minimal Changes**: We're changing communication method, not business logic
2. **Risk Reduction**: Keep all existing functionality while fixing chat resets
3. **Railway Optimized**: HTTP scales better than WebSocket on Railway
4. **User Experience**: Same UI, better reliability, no chat resets

**The WebSocket implementation has good logic - we just need to make it stateless and persistent for multiple users.**