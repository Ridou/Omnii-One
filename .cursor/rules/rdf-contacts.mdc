---
description: 
globs: 
alwaysApply: false
---
# RDF-Driven Contact Resolution System

## Overview
Replace hard-coded nickname mappings with intelligent RDF reasoning for contact resolution. This creates a multi-phase pipeline that uses semantic analysis to understand user intent and resolve contacts with high accuracy for ANY action type (email, text, calendar, etc.).

## Enhanced Context Integration with Neo4j Brain Memory System

### Leveraging Existing Brain Memory Infrastructure
Your Neo4j brain memory system provides rich contextual data that dramatically improves contact resolution:

```typescript
interface EnhancedContactContext {
  temporal_context: {
    past_week: CommunicationPattern[];
    current_week: CommunicationPattern[];
    future_week: ScheduledInteraction[];
  };
  communication_patterns: {
    preferred_channels: ChannelPreference[];
    interaction_frequency: number;
    response_patterns: ResponseStyle;
    relationship_indicators: RelationshipContext;
  };
  brain_memory_insights: {
    recent_mentions: ConceptActivation[];
    semantic_associations: ConceptRelationship[];
    episodic_connections: MemoryThread[];
    consolidation_status: MemoryConsolidation;
  };
}
```

### Brain Memory Context Extraction for Contact Resolution

#### 1. Temporal Communication Analysis (Past/Present/Future Weeks)
```typescript
export class BrainMemoryContactEnhancer {
  async getTemporalContactContext(
    userId: string, 
    contactName: string
  ): Promise<TemporalContactContext> {
    const session = this.neo4jDriver.session();
    
    try {
      // Query past week communication patterns
      const pastWeekResult = await session.run(`
        MATCH (user:User {id: $userId})-[:OWNS]->(msg:ChatMessage)
        WHERE msg.timestamp > datetime() - duration({days: 7})
        AND msg.timestamp < datetime() - duration({days: 0})
        AND (
          toLower(msg.content) CONTAINS toLower($contactName)
          OR EXISTS {
            MATCH (msg)-[:MENTIONS]->(concept:Concept)
            WHERE toLower(concept.name) CONTAINS toLower($contactName)
          }
        )
        
        OPTIONAL MATCH (msg)-[:HAS_MEMORY]->(memory:Memory)
        OPTIONAL MATCH (msg)-[:MENTIONS]->(concept:Concept)
        
        RETURN msg.content,
               msg.channel,
               msg.source_identifier,
               msg.timestamp,
               msg.intent,
               msg.sentiment,
               msg.importance_score,
               memory.consolidation_status,
               collect(concept.name) as mentioned_concepts
        ORDER BY msg.timestamp DESC
        LIMIT 20
      `, { userId, contactName });

      // Query current week activity
      const currentWeekResult = await session.run(`
        MATCH (user:User {id: $userId})-[:OWNS]->(msg:ChatMessage)
        WHERE msg.timestamp > datetime() - duration({days: 7})
        AND (
          toLower(msg.content) CONTAINS toLower($contactName)
          OR EXISTS {
            MATCH (msg)-[:MENTIONS]->(concept:Concept)
            WHERE toLower(concept.name) CONTAINS toLower($contactName)
          }
        )
        
        WITH msg, count(*) as interaction_frequency
        ORDER BY msg.timestamp DESC
        
        RETURN msg.content,
               msg.channel,
               msg.timestamp,
               msg.intent,
               msg.sentiment,
               interaction_frequency
        LIMIT 10
      `, { userId, contactName });

      // Query future scheduled interactions (from calendar concepts)
      const futureWeekResult = await session.run(`
        MATCH (user:User {id: $userId})-[:OWNS]->(msg:ChatMessage)-[:MENTIONS]->(concept:Concept)
        WHERE concept.name CONTAINS "calendar"
        AND toLower(msg.content) CONTAINS toLower($contactName)
        AND msg.timestamp > datetime() - duration({days: 1})
        
        OPTIONAL MATCH (concept)-[:RELATED_TO]->(timeConcept:Concept)
        WHERE timeConcept.name CONTAINS "meeting" OR timeConcept.name CONTAINS "call"
        
        RETURN msg.content,
               msg.timestamp,
               concept.name,
               concept.activation_strength,
               collect(timeConcept.name) as time_concepts
        ORDER BY msg.timestamp DESC
        LIMIT 5
      `, { userId, contactName });

      return this.processTemporalResults(pastWeekResult, currentWeekResult, futureWeekResult);
      
    } finally {
      await session.close();
    }
  }
}
```

#### 2. Communication Pattern Analysis
```typescript
async getCommunicationPatterns(
  userId: string, 
  contactName: string
): Promise<CommunicationPatterns> {
  const session = this.neo4jDriver.session();
  
  try {
    // Analyze preferred communication channels and patterns
    const patternsResult = await session.run(`
      MATCH (user:User {id: $userId})-[:OWNS]->(msg:ChatMessage)
      WHERE toLower(msg.content) CONTAINS toLower($contactName)
      AND msg.timestamp > datetime() - duration({days: 30}) // Last 30 days
      
      WITH msg,
           CASE 
             WHEN msg.channel = 'email' THEN 'email'
             WHEN msg.channel = 'sms' THEN 'text' 
             WHEN msg.channel = 'chat' THEN 'chat'
             ELSE 'other'
           END as normalized_channel
      
      RETURN normalized_channel,
             count(*) as usage_count,
             avg(msg.importance_score) as avg_importance,
             collect(DISTINCT msg.intent) as intents,
             avg(
               CASE msg.sentiment
                 WHEN 'positive' THEN 1.0
                 WHEN 'neutral' THEN 0.5
                 WHEN 'negative' THEN 0.0
                 ELSE 0.5
               END
             ) as avg_sentiment,
             max(msg.timestamp) as last_interaction,
             min(msg.timestamp) as first_interaction
      ORDER BY usage_count DESC
    `, { userId, contactName });

    // Analyze response patterns and relationship indicators
    const relationshipResult = await session.run(`
      MATCH (user:User {id: $userId})-[:OWNS]->(msg:ChatMessage)
      WHERE toLower(msg.content) CONTAINS toLower($contactName)
      
      // Find concepts that frequently appear with this contact
      OPTIONAL MATCH (msg)-[:MENTIONS]->(concept:Concept)
      WHERE concept.activation_strength > 0.5
      
      WITH concept,
           count(DISTINCT msg) as co_occurrence_count,
           avg(concept.activation_strength) as avg_activation,
           collect(DISTINCT msg.intent) as contexts
      WHERE co_occurrence_count >= 2
      
      RETURN concept.name,
             co_occurrence_count,
             avg_activation,
             contexts,
             CASE 
               WHEN concept.name IN ['work', 'business', 'meeting', 'project'] THEN 'professional'
               WHEN concept.name IN ['family', 'personal', 'friend'] THEN 'personal' 
               WHEN concept.name IN ['urgent', 'asap', 'important'] THEN 'urgent'
               ELSE 'neutral'
             END as relationship_indicator
      ORDER BY co_occurrence_count DESC
      LIMIT 10
    `, { userId, contactName });

    return this.processCommunicationPatterns(patternsResult, relationshipResult);
    
  } finally {
    await session.close();
  }
}
```

#### 3. Contact Confidence Boosting Algorithm
```typescript
export class ContactConfidenceBooster {
  calculateEnhancedConfidence(
    baseConfidence: number,
    temporalContext: TemporalContactContext,
    communicationPatterns: CommunicationPatterns,
    brainMemoryContext: BrainMemoryContext
  ): EnhancedConfidenceResult {
    
    let enhancedConfidence = baseConfidence;
    const boostFactors: ConfidenceBoost[] = [];
    
    // 1. Recent Communication Boost (Past Week)
    if (temporalContext.past_week.interaction_count > 0) {
      const recentBoost = Math.min(temporalContext.past_week.interaction_count * 0.1, 0.3);
      enhancedConfidence += recentBoost;
      boostFactors.push({
        type: 'recent_communication',
        boost: recentBoost,
        reasoning: `Recent interactions: ${temporalContext.past_week.interaction_count} in past week`
      });
    }
    
    // 2. Current Week Activity Boost
    if (temporalContext.current_week.active_conversations > 0) {
      const currentBoost = Math.min(temporalContext.current_week.active_conversations * 0.15, 0.25);
      enhancedConfidence += currentBoost;
      boostFactors.push({
        type: 'current_activity',
        boost: currentBoost, 
        reasoning: `Active conversations this week: ${temporalContext.current_week.active_conversations}`
      });
    }
    
    // 3. Communication Channel Alignment Boost
    const preferredChannel = communicationPatterns.preferred_channels[0];
    if (preferredChannel && this.channelAlignmentScore(preferredChannel, brainMemoryContext) > 0.7) {
      const channelBoost = 0.2;
      enhancedConfidence += channelBoost;
      boostFactors.push({
        type: 'channel_alignment',
        boost: channelBoost,
        reasoning: `Communication typically via ${preferredChannel.channel}`
      });
    }
    
    // 4. Relationship Context Boost
    if (communicationPatterns.relationship_indicators.context_match > 0.8) {
      const relationshipBoost = 0.25;
      enhancedConfidence += relationshipBoost;
      boostFactors.push({
        type: 'relationship_context',
        boost: relationshipBoost,
        reasoning: `Strong relationship context match: ${communicationPatterns.relationship_indicators.primary_context}`
      });
    }
    
    // 5. Semantic Memory Activation Boost
    const semanticBoost = this.calculateSemanticBoost(brainMemoryContext.semantic_memory);
    if (semanticBoost > 0) {
      enhancedConfidence += semanticBoost;
      boostFactors.push({
        type: 'semantic_activation',
        boost: semanticBoost,
        reasoning: `Strong semantic associations in memory`
      });
    }
    
    // 6. Future Context Boost (scheduled interactions)
    if (temporalContext.future_week.scheduled_interactions.length > 0) {
      const futureBoost = 0.15;
      enhancedConfidence += futureBoost;
      boostFactors.push({
        type: 'future_context',
        boost: futureBoost,
        reasoning: `Upcoming interactions scheduled`
      });
    }
    
    // Cap at 0.95 (leave room for uncertainty)
    enhancedConfidence = Math.min(enhancedConfidence, 0.95);
    
    return {
      original_confidence: baseConfidence,
      enhanced_confidence: enhancedConfidence,
      total_boost: enhancedConfidence - baseConfidence,
      boost_factors: boostFactors,
      confidence_explanation: this.generateConfidenceExplanation(boostFactors)
    };
  }
}
```

#### 4. Communication Style Analysis for Email Personalization
```typescript
async analyzePersonalizedCommunicationStyle(
  userId: string,
  contactName: string,
  brainMemoryContext: BrainMemoryContext
): Promise<PersonalizedCommunicationStyle> {
  
  // Extract communication style from brain memory patterns
  const session = this.neo4jDriver.session();
  
  try {
    const styleResult = await session.run(`
      MATCH (user:User {id: $userId})-[:OWNS]->(msg:ChatMessage)
      WHERE toLower(msg.content) CONTAINS toLower($contactName)
      AND msg.timestamp > datetime() - duration({days: 60})
      
      WITH msg,
           // Analyze formality indicators
           CASE 
             WHEN msg.content CONTAINS 'Hi ' OR msg.content CONTAINS 'Hey ' THEN 'casual'
             WHEN msg.content CONTAINS 'Dear ' OR msg.content CONTAINS 'Hello ' THEN 'formal'
             ELSE 'neutral'
           END as greeting_style,
           
           // Analyze message length patterns
           size(split(msg.content, ' ')) as word_count,
           
           // Extract sentiment and tone
           msg.sentiment as message_sentiment
      
      RETURN greeting_style,
             avg(word_count) as avg_message_length,
             collect(DISTINCT message_sentiment) as sentiment_patterns,
             count(*) as total_messages,
             
             // Communication timing patterns
             avg(hour(msg.timestamp)) as preferred_time,
             collect(DISTINCT dayOfWeek(msg.timestamp)) as communication_days
      
      ORDER BY total_messages DESC
      LIMIT 1
    `, { userId, contactName });

    const communicationStyle = this.processCommunicationStyle(styleResult);
    
    return {
      formality_level: communicationStyle.formality,
      preferred_greeting: communicationStyle.greeting,
      typical_message_length: communicationStyle.length_preference,
      tone_indicators: communicationStyle.tone,
      timing_preferences: communicationStyle.timing,
      personalization_suggestions: this.generatePersonalizationSuggestions(communicationStyle, brainMemoryContext)
    };
    
  } finally {
    await session.close();
  }
}
```

## Enhanced Implementation Flow with Brain Memory Context

### Phase 1: ActionPlanner Receives Message with Brain Memory Context
**Input**: Any message with contact reference + Brain Memory Context
**Enhancement**: Leverage temporal and communication context from Neo4j

```typescript
// ActionPlanner.createPlan() - Enhanced with Brain Memory
async createPlan(message: string, entities?: CachedEntity[], userUUID?: string): Promise<ActionPlan> {
  // Step 1: Get brain memory context for this user/conversation
  const brainMemoryContext = await this.brainMemoryService.getBrainMemoryContext(
    userUUID, 
    'chat', // or appropriate channel
    message
  );
  
  // Step 2: Create initial plan (determines action type)
  const initialPlan = await this.createPlanWithLLM(message, entities);
  
  // Step 3: Extract entities (including PERSON entities)
  const extractedEntities = await this.entityManager.resolveEntities(message, context, userUUID);
  
  // Step 4: Enhanced RDF contact resolution with brain memory context
  const resolvedEntities = await this.resolveEntitiesWithBrainMemory(
    extractedEntities, 
    message, 
    userUUID,
    brainMemoryContext // NEW: Pass brain memory context
  );
  
  // Step 5: Patch action steps with resolved contacts
  const updatedSteps = this.patchEntityPlaceholders(initialPlan.steps, resolvedEntities);
  
  return { ...initialPlan, steps: updatedSteps };
}
```

### Phase 2: Enhanced RDF Message Analysis with Brain Memory
**Input**: Full message + Brain Memory Context
**RDF Task**: Analyze with temporal and relationship context

```typescript
// Enhanced RDF Prompt with Brain Memory Context
const enhancedMessageAnalysisPrompt = `
Analyze this message for contact resolution: "${message}"

BRAIN MEMORY CONTEXT:
- Recent conversations: ${brainMemoryContext.working_memory.recent_messages.length}
- Active concepts: ${brainMemoryContext.semantic_memory.activated_concepts.map(c => c.concept.concept_name).join(', ')}
- Memory strength: ${brainMemoryContext.consolidation_metadata.memory_strength}
- Episodic connections: ${brainMemoryContext.episodic_memory.conversation_threads.length}

TEMPORAL CONTEXT:
- Past week communication patterns: ${temporalContext.past_week.summary}
- Current week activity: ${temporalContext.current_week.summary}
- Future scheduled interactions: ${temporalContext.future_week.summary}

Extract:
1. Primary contact reference and relationship context
2. Communication intent aligned with historical patterns
3. Urgency/formality based on relationship history
4. Temporal context that supports contact identification
5. Confidence boosters from recent interactions

Return analysis with brain memory-enhanced confidence scores.
`;
```

### Phase 3: Brain Memory-Enhanced Contact Name Expansion
**Input**: Contact name + message context + brain memory insights
**RDF Task**: Generate variations using memory patterns

```typescript
// Enhanced Contact Expansion with Brain Memory
const brainMemoryContactExpansionPrompt = `
Analyze the name "${contactName}" with brain memory context:

MESSAGE: "${originalMessage}"
ACTION: ${messageAnalysis.action_intent}
RELATIONSHIP: ${messageAnalysis.relationship_context}

BRAIN MEMORY INSIGHTS:
- Recent mentions of similar names: ${brainMemoryInsights.recent_mentions}
- Semantic associations: ${brainMemoryInsights.semantic_associations}
- Communication patterns: ${communicationPatterns.preferred_style}
- Relationship indicators: ${communicationPatterns.relationship_indicators}

TEMPORAL EVIDENCE:
- Past week interactions: ${temporalContext.past_week.interaction_count}
- Communication frequency: ${temporalContext.frequency_pattern}
- Last interaction: ${temporalContext.last_interaction}

Generate name variations considering:
1. Memory-based name associations (how this person is typically referenced)
2. Cultural/linguistic patterns from conversation history
3. Relationship-specific nicknames or formal versions
4. Temporal context (recent vs historical name usage)
5. Brain memory consolidation patterns

Boost confidence for variations that align with memory patterns.
`;
```

### Phase 4: Brain Memory-Enhanced Contact Resolution
**Input**: All found contacts + brain memory context + temporal patterns
**RDF Task**: Resolve using comprehensive context

```typescript
// Enhanced Contact Resolution with Brain Memory
const brainMemoryContactResolutionPrompt = `
Given this comprehensive context for contact resolution:

ORIGINAL MESSAGE: "${originalMessage}"
ACTION INTENT: ${messageAnalysis.action_intent}
FOUND CONTACTS: ${JSON.stringify(foundContacts)}

BRAIN MEMORY CONTEXT:
- Working memory: ${brainMemoryContext.working_memory.recent_messages.length} recent messages
- Episodic memory: ${brainMemoryContext.episodic_memory.conversation_threads.length} related conversations
- Semantic memory: ${brainMemoryContext.semantic_memory.activated_concepts.length} active concepts
- Memory consolidation score: ${brainMemoryContext.consolidation_metadata.consolidation_score}

TEMPORAL COMMUNICATION ANALYSIS:
- Past week interactions: ${temporalContext.past_week}
- Current week activity: ${temporalContext.current_week}
- Future scheduled interactions: ${temporalContext.future_week}

COMMUNICATION PATTERNS:
- Preferred channels: ${communicationPatterns.preferred_channels}
- Interaction frequency: ${communicationPatterns.interaction_frequency}
- Response patterns: ${communicationPatterns.response_patterns}
- Relationship context: ${communicationPatterns.relationship_indicators}

Determine the intended contact considering:
1. Name similarity + brain memory associations
2. Communication channel alignment with historical patterns
3. Temporal context (recent communication boosts confidence)
4. Relationship context from memory consolidation
5. Contact method availability for intended action
6. Memory strength and episodic connections

Provide confidence score enhanced by brain memory evidence.
`;
```

### Phase 5: Personalized Communication Generation
**Input**: Resolved contact + communication style analysis
**Enhancement**: Generate personalized communication based on historical patterns

```typescript
async generatePersonalizedCommunication(
  resolvedContact: Contact,
  actionType: string,
  originalMessage: string,
  communicationStyle: PersonalizedCommunicationStyle,
  brainMemoryContext: BrainMemoryContext
): Promise<PersonalizedCommunication> {
  
  const personalizationPrompt = `
  Generate ${actionType} communication for:
  
  CONTACT: ${resolvedContact.name} (${resolvedContact.email})
  ORIGINAL REQUEST: "${originalMessage}"
  
  PERSONALIZATION CONTEXT:
  - Communication style: ${communicationStyle.formality_level}
  - Preferred greeting: ${communicationStyle.preferred_greeting}
  - Typical message length: ${communicationStyle.typical_message_length}
  - Tone indicators: ${communicationStyle.tone_indicators}
  - Recent conversation topics: ${brainMemoryContext.semantic_memory.activated_concepts.slice(0, 3).map(c => c.concept.concept_name)}
  
  HISTORICAL CONTEXT:
  - Last interaction sentiment: ${temporalContext.last_interaction_sentiment}
  - Relationship context: ${communicationPatterns.relationship_indicators.primary_context}
  - Communication frequency: ${communicationPatterns.interaction_frequency}
  
  Generate personalized communication that:
  1. Matches historical communication style with this contact
  2. Uses appropriate formality level based on relationship
  3. References relevant context from recent conversations
  4. Aligns with typical interaction patterns
  5. Considers temporal context (urgent vs routine)
  
  Return subject line and body content that feels natural and personalized.
  `;
  
  // Process with RDF and return personalized content
}
```

## Correct Order of Operations

### System Flow Architecture
```
User Message → ActionPlanner → Entity Extraction → Brain Memory Context → RDF Contact Resolution → Action Execution
     ↓              ↓                 ↓                    ↓                         ↓                    ↓
"Text Eden      Create Plan      Extract "Eden"        Get Brain Memory       Resolve to           Execute
about dinner"   with steps       as PERSON entity        + Temporal Context     Eden Martinez        TextStepExecutor
                                                       + Communication         (personal contact)    with phone number
                                                       Patterns
```

### Key Integration Points

#### 1. Brain Memory Context Retrieval
```typescript
// In ActionPlanner.resolveEntitiesWithBrainMemory()
private async resolveEntitiesWithBrainMemory(
  entities: CachedEntity[], 
  originalMessage: string, 
  userUUID: string,
  brainMemoryContext: BrainMemoryContext
): Promise<CachedEntity[]> {
  
  for (const entity of entities) {
    if (entity.type === EntityType.PERSON) {
      // Get temporal and communication context from Neo4j
      const temporalContext = await this.brainMemoryContactEnhancer.getTemporalContactContext(userUUID, entity.value);
      const communicationPatterns = await this.brainMemoryContactEnhancer.getCommunicationPatterns(userUUID, entity.value);
      
      // Enhanced RDF resolution with brain memory context
      const rdfResult = await this.smartContactResolver.resolveContactWithBrainMemory(
        entity.value,
        originalMessage,
        userUUID,
        brainMemoryContext,
        temporalContext,
        communicationPatterns
      );
      
      // Apply confidence boosting based on brain memory evidence
      const enhancedConfidence = this.contactConfidenceBooster.calculateEnhancedConfidence(
        rdfResult.confidence,
        temporalContext,
        communicationPatterns,
        brainMemoryContext
      );
      
      if (enhancedConfidence.enhanced_confidence >= 0.8) {
        // High confidence with brain memory boost - use automatically
        resolvedEntities.push(this.createResolvedEntity(entity, rdfResult.contact, enhancedConfidence));
      } else if (rdfResult.alternatives && rdfResult.alternatives.length > 0) {
        // Create smart intervention with brain memory context
        resolvedEntities.push(this.createBrainMemoryEnhancedIntervention(entity, rdfResult.alternatives, temporalContext));
      }
    }
  }
}
```

#### 2. Enhanced Intervention with Brain Memory
```typescript
private createBrainMemoryEnhancedIntervention(
  entity: CachedEntity, 
  alternatives: ContactAlternative[],
  temporalContext: TemporalContactContext
): CachedEntity {
  
  const interventionMessage = `
I found ${alternatives.length} possible matches for "${entity.value}":

${alternatives.map((alt, i) => {
  const recentInteraction = temporalContext.past_week.interactions.find(interaction => 
    interaction.contact_reference.includes(alt.name.toLowerCase())
  );
  
  const recentContext = recentInteraction 
    ? ` (last contacted ${this.formatTimeAgo(recentInteraction.timestamp)} about ${recentInteraction.topic})`
    : '';
    
  return `${i+1}. ${alt.name} (${alt.email})${recentContext} - ${alt.reasoning}`;
}).join('\n')}

Based on your recent communication patterns and message context, I think you meant #1. 
Reply with a number to confirm, or provide the exact email/phone.
  `;
  
  return {
    ...entity,
    type: EntityType.UNKNOWN,
    smartSuggestions: alternatives,
    interventionMessage,
    brainMemoryContext: temporalContext
  };
}
```

This enhanced system leverages your existing Neo4j brain memory infrastructure to provide:

1. **Temporal Context**: Past/present/future week communication analysis
2. **Communication Patterns**: Preferred channels, frequency, relationship context
3. **Confidence Boosting**: Recent interaction patterns boost resolution confidence
4. **Personalized Communication**: Generate emails/texts that match historical style
5. **Smart Interventions**: Context-aware choices when resolution is ambiguous
6. **Learning Integration**: Feed user corrections back into the brain memory system

The result is a contact resolution system that becomes more accurate over time and generates more natural, personalized communications.

## Implementation Flow

### Phase 1: Message Semantic Analysis
**Input**: "Shoot an email to Eden about the meeting"
**RDF Task**: Analyze the full message for context and intent

```typescript
// RDF Prompt for Message Analysis
const messageAnalysisPrompt = `
Analyze this message for contact resolution context: "${message}"

Extract:
1. Primary contact reference (the person mentioned)
2. Communication intent (email, call, text, etc.)
3. Relationship context clues (work, family, friend indicators)
4. Urgency/formality indicators
5. Additional context that might help identify the specific person

Return semantic analysis with confidence scores.
`;
```

**Output**: 
```json
{
  "primary_contact": "Eden",
  "intent": "send_email",
  "context_clues": ["meeting", "professional"],
  "formality": "business",
  "urgency": "normal",
  "additional_context": "work-related communication"
}
```

### Phase 2: Contact Name Semantic Expansion
**Input**: Contact name "Eden" + message context
**RDF Task**: Generate intelligent variations and semantic alternatives

```typescript
// RDF Prompt for Contact Expansion
const contactExpansionPrompt = `
Analyze the name "${contactName}" in this context:
- Message: "${originalMessage}"
- Action: ${messageAnalysis.action_intent}
- Relationship: ${messageAnalysis.relationship_context}
- Formality: ${messageAnalysis.formality}

Generate ALL possible variations this person could be referred to:
1. Phonetic variations and similar-sounding names
2. Cultural/linguistic alternatives (different languages/origins)
3. Common nicknames and diminutives  
4. Formal vs informal versions
5. Potential spelling variations or typos
6. Gender-neutral variations if applicable

Consider the context: ${messageAnalysis.formality}, ${messageAnalysis.relationship_context}

Return a comprehensive list with confidence scores for each variation.
`;
```

**Output**:
```json
{
  "variations": [
    {"name": "Eden", "confidence": 1.0, "type": "exact"},
    {"name": "Edan", "confidence": 0.8, "type": "phonetic"},
    {"name": "Aiden", "confidence": 0.7, "type": "similar"},
    {"name": "Adan", "confidence": 0.6, "type": "phonetic"},
    {"name": "Ethan", "confidence": 0.5, "type": "similar_sound"}
  ],
  "context_priority": "business_context_suggests_formal_name"
}
```

### Phase 3: Multi-Query Contact Retrieval
**Input**: RDF-generated variations
**Action**: Query Google Contacts with OR logic

```typescript
export class RDFContactResolver {
  async searchContactsWithVariations(variations: NameVariation[]): Promise<Contact[]> {
    const allContacts: Contact[] = [];
    
    // Execute parallel searches for all variations
    const searchPromises = variations.map(async (variation) => {
      const contacts = await this.searchGoogleContacts(variation.name);
      return contacts.map(contact => ({
        ...contact,
        matchedVariation: variation,
        searchConfidence: variation.confidence
      }));
    });
    
    const results = await Promise.all(searchPromises);
    return results.flat();
  }
}
```

### Phase 4: Contextual Contact Resolution
**Input**: All found contacts + original message context
**RDF Task**: Intelligently determine the intended contact

```typescript
// RDF Prompt for Contact Resolution
const contactResolutionPrompt = `
Given this context:
- Original message: "${originalMessage}"
- Message analysis: ${messageContext}
- Found contacts: ${JSON.stringify(foundContacts)}

Determine which contact the user most likely intended:

Consider:
1. Name similarity to original term (exact match priority)
2. Context alignment (work email for business context)
3. Recent communication patterns (if available)
4. Contact completeness (has email vs phone only)
5. Relationship indicators in contact data

Provide reasoning and confidence score for top matches.
`;
```

**Output**:
```json
{
  "resolved_contact": {
    "contact": {
      "name": "Eden Chen",
      "email": "eden.chen@company.com",
      "title": "Product Manager"
    },
    "confidence": 0.95,
    "reasoning": "Exact name match 'Eden', business email aligns with meeting context, has complete contact info"
  },
  "alternatives": [
    {
      "contact": {"name": "Edan Rodriguez", "email": "edan.r@personal.com"},
      "confidence": 0.3,
      "reasoning": "Phonetic match but personal email doesn't fit business context"
    }
  ]
}
```

### Phase 5: Smart Intervention Logic
**When confidence < 0.8**: Present intelligent choices to user

```typescript
const interventionMessage = `
I found ${alternatives.length} possible matches for "${originalName}":

${alternatives.map((alt, i) => 
  `${i+1}. ${alt.contact.name} (${alt.contact.email}) - ${alt.reasoning}`
).join('\n')}

Based on your message about "${messageContext.topic}", I think you meant #1. Reply with a number to confirm, or provide the exact email address.
`;
```

## Implementation Architecture

### Core Components

#### 1. RDFContactAnalyzer
```typescript
export class RDFContactAnalyzer {
  async analyzeMessage(message: string): Promise<MessageAnalysis>
  async expandContactName(name: string, context: MessageAnalysis): Promise<NameVariation[]>
  async resolveContact(contacts: Contact[], context: MessageAnalysis): Promise<ContactResolution>
}
```

#### 2. Enhanced SmartContactResolver
```typescript
export class SmartContactResolver {
  private rdfAnalyzer: RDFContactAnalyzer;
  
  async resolveContactRDF(
    searchTerm: string,
    message: string,
    userId: string
  ): Promise<SmartContactResult> {
    // Phase 1: Analyze message semantics
    const messageAnalysis = await this.rdfAnalyzer.analyzeMessage(message);
    
    // Phase 2: Expand contact name with RDF
    const variations = await this.rdfAnalyzer.expandContactName(searchTerm, messageAnalysis);
    
    // Phase 3: Multi-query search
    const allContacts = await this.searchContactsWithVariations(variations);
    
    // Phase 4: RDF-based resolution
    const resolution = await this.rdfAnalyzer.resolveContact(allContacts, messageAnalysis);
    
    return this.formatResult(resolution);
  }
}
```

#### 3. Enhanced Action Planner Integration
```typescript
// In ActionPlanner.ts
private async resolveEntitiesWithRDF(entities: CachedEntity[], message: string, userUUID: string): Promise<CachedEntity[]> {
  const resolvedEntities: CachedEntity[] = [];
  
  for (const entity of entities) {
    if (entity.type === EntityType.PERSON) {
      // Use new RDF-driven resolution
      const rdfResult = await this.smartContactResolver.resolveContactRDF(
        entity.value,
        message, // Pass full message for context
        userUUID
      );
      
      if (rdfResult.success && rdfResult.confidence >= 0.8) {
        // High confidence - use automatically
        resolvedEntities.push(this.createResolvedEntity(entity, rdfResult.contact));
      } else if (rdfResult.alternatives && rdfResult.alternatives.length > 0) {
        // Multiple options - create intervention
        resolvedEntities.push(this.createEntityWithChoices(entity, rdfResult.alternatives));
      } else {
        // No matches - request manual input
        resolvedEntities.push(this.createUnresolvedEntity(entity));
      }
    }
  }
  
  return resolvedEntities;
}
```

## Advanced Features

### 1. Learning from User Corrections
When user corrects RDF suggestions, feed back into the system:

```typescript
async learnFromCorrection(
  originalName: string,
  chosenContact: Contact,
  rejectedSuggestions: Contact[],
  messageContext: MessageAnalysis
) {
  const learningPrompt = `
  User corrected contact resolution:
  - They said: "${originalName}"
  - Context: ${messageContext}
  - They chose: ${chosenContact.name} (${chosenContact.email})
  - They rejected: ${rejectedSuggestions.map(s => s.name).join(', ')}
  
  What patterns can we learn for future resolution?
  `;
  
  // Store learning for future improvements
}
```

### 2. Contextual Memory Integration
```typescript
// Integrate with existing brain memory system
const memoryContext = await this.brainMemoryService.getContactMemory(userId, contactName);
const enhancedContext = {
  ...messageAnalysis,
  recentInteractions: memoryContext.recent_communications,
  relationship_history: memoryContext.relationship_indicators
};
```

### 3. Multi-Language Support
```typescript
const multiLingualPrompt = `
The user said "${contactName}" - analyze this in multiple languages:
1. English variations and nicknames
2. Spanish variations (if applicable)
3. Other cultural adaptations
4. Consider the user's language preferences: ${userProfile.languages}
`;
```

## Testing Strategy

### 1. RDF Quality Tests
```typescript
describe('RDF Contact Resolution', () => {
  test('should correctly expand common names', async () => {
    const variations = await rdfAnalyzer.expandContactName('Eden', businessContext);
    expect(variations).toInclude(['Eden', 'Edan', 'Aiden']);
    expect(variations[0].confidence).toBeGreaterThan(0.8);
  });
  
  test('should resolve contacts with business context', async () => {
    const resolution = await resolver.resolveContactRDF('Eden', 'Send Eden the quarterly report', userId);
    expect(resolution.contact.email).toContain('@company.com');
  });
});
```

### 2. Integration Tests with Real Contacts
```typescript
test('should handle real-world scenarios', async () => {
  // Test with actual Google Contacts data
  const result = await resolver.resolveContactRDF('Mike', 'Call Mike about the project', realUserId);
  expect(result.success).toBe(true);
});
```

## Performance Optimizations

### 1. Caching Strategy
```typescript
// Cache RDF analysis results
const cacheKey = `rdf_expansion:${contactName}:${contextHash}`;
const cached = await redis.get(cacheKey);
if (cached) return JSON.parse(cached);
```

### 2. Parallel Processing
```typescript
// Run RDF analysis and contact search in parallel
const [messageAnalysis, basicSearchResults] = await Promise.all([
  this.rdfAnalyzer.analyzeMessage(message),
  this.searchGoogleContacts(originalName)
]);
```

### 3. Confidence Thresholds
```typescript
const CONFIDENCE_THRESHOLDS = {
  AUTO_RESOLVE: 0.85,    // Use automatically
  PRESENT_OPTIONS: 0.4,   // Show user choices
  REQUEST_MANUAL: 0.0     // Ask for manual input
};
```

## Migration Plan

### Phase 1: Implement Core RDF Components
- [ ] Create RDFContactAnalyzer class
- [ ] Update SmartContactResolver with RDF methods
- [ ] Add message context analysis

### Phase 2: Enhanced Contact Search
- [ ] Implement multi-query search logic
- [ ] Add parallel contact retrieval
- [ ] Create contact resolution engine

### Phase 3: Integration with ActionPlanner
- [ ] Update entity resolution pipeline
- [ ] Add RDF-driven intervention logic
- [ ] Enhance error handling and fallbacks

### Phase 4: Advanced Features
- [ ] Add learning from corrections
- [ ] Implement contextual memory integration
- [ ] Add multi-language support

This RDF-driven approach will create a much more intelligent and flexible contact resolution system that learns and improves over time while providing accurate results even for ambiguous names.
