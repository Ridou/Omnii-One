---
description: 
globs: 
alwaysApply: false
---
# RDF Reasoning Microservice Test Implementation Plan (TDD)

## üéØ **Test-Driven Development Strategy**

This comprehensive test plan ensures **100% test coverage** for the RDF reasoning microservice integration with the Omnii brain memory system. Following TDD principles, we'll implement tests first, then build functionality to pass these tests.

**üß† BRAIN MEMORY TEST COVERAGE:**
- **Schema Validation Tests** - Zod schemas for brain-enhanced RDF integration
- **RDF Service Core Tests** - Python FastAPI service functionality
- **Brain RDF Client Tests** - TypeScript client with ProductionBrainService patterns
- **Brain Memory Integration Tests** - Enhanced conversation manager methods
- **Performance & Production Tests** - Railway deployment and monitoring

## üî¨ **Unit Tests - Brain-Enhanced RDF Schemas**

### **Schema Validation Tests**

```typescript
// apps/omnii_mcp/tests/rdf/unit/rdf-schemas.test.ts
import { describe, test, expect, beforeAll } from 'bun:test';
import {
  BrainRDFTripleSchema,
  BrainRDFQuerySchema,
  BrainConceptEvolutionSchema,
  BrainRDFQueryResultSchema,
  BrainConceptEvolutionResultSchema,
  BrainMemoryRDFBridgeSchema
} from '../../../src/types/rdf-schemas';
import { BRAIN_MEMORY_CONSTANTS } from '../../../src/types/brain-memory-schemas';

describe('Brain-Enhanced RDF Schemas', () => {
  
  test('BrainRDFTripleSchema validates brain memory integration', () => {
    const validTriple = {
      subject: 'https://omnii.ai/concept#test',
      predicate: 'https://omnii.ai/ontology#mentions',
      object: 'test concept',
      confidence: 0.85,
      source_message_id: '123e4567-e89b-12d3-a456-426614174000',
      temporal_context: 'current_week',
      memory_strength: 0.75
    };

    const result = BrainRDFTripleSchema.safeParse(validTriple);
    expect(result.success).toBe(true);
    expect(result.data?.confidence).toBe(0.85);
    expect(result.data?.temporal_context).toBe('current_week');
  });

  test('BrainRDFTripleSchema rejects invalid temporal context', () => {
    const invalidTriple = {
      subject: 'test',
      predicate: 'https://omnii.ai/ontology#mentions',
      object: 'test',
      temporal_context: 'invalid_week' // Invalid enum value
    };

    const result = BrainRDFTripleSchema.safeParse(invalidTriple);
    expect(result.success).toBe(false);
  });

  test('BrainRDFQuerySchema with brain context validation', () => {
    const validQuery = {
      query: 'SELECT * WHERE { ?s ?p ?o }',
      query_type: 'SELECT',
      reasoning: true,
      brain_context: {
        user_id: '123e4567-e89b-12d3-a456-426614174000',
        channel: 'sms',
        memory_window_hours: BRAIN_MEMORY_CONSTANTS.EPISODIC_MEMORY_WINDOW_HOURS,
        include_working_memory: true,
        include_episodic_memory: true,
        include_semantic_memory: true,
        temporal_reasoning: true
      },
      concept_evolution: {
        enable_evolution: true,
        confidence_threshold: 0.7,
        max_evolutions: 3
      }
    };

    const result = BrainRDFQuerySchema.safeParse(validQuery);
    expect(result.success).toBe(true);
    expect(result.data?.brain_context?.temporal_reasoning).toBe(true);
    expect(result.data?.concept_evolution?.max_evolutions).toBe(3);
  });

  test('BrainConceptEvolutionSchema with brain memory context', () => {
    const validEvolution = {
      concept_id: '123e4567-e89b-12d3-a456-426614174000',
      concept_name: 'test concept',
      current_properties: {
        activation_strength: 0.6,
        mention_count: 5,
        semantic_weight: 0.7
      },
      new_information: [{
        subject: 'test',
        predicate: 'https://omnii.ai/ontology#test',
        object: 'value',
        confidence: 0.8
      }],
      evidence_sources: [{
        message_id: '123e4567-e89b-12d3-a456-426614174000',
        conversation_thread: 'thread_1',
        temporal_context: 'current_week',
        memory_strength: 0.8,
        channel: 'sms'
      }],
      brain_memory_context: {
        working_memory_references: 5,
        episodic_memory_connections: 3,
        semantic_network_strength: 0.7,
        temporal_distribution: {
          previous_week: 0.2,
          current_week: 0.6,
          next_week: 0.2
        }
      }
    };

    const result = BrainConceptEvolutionSchema.safeParse(validEvolution);
    expect(result.success).toBe(true);
    expect(result.data?.brain_memory_context.temporal_distribution.current_week).toBe(0.6);
  });

  test('BrainMemoryRDFBridgeSchema validates analysis requests', () => {
    const validBridge = {
      brain_memory_context: {
        user_id: '123e4567-e89b-12d3-a456-426614174000',
        retrieval_timestamp: new Date().toISOString(),
        memory_strength: 0.75,
        working_memory_size: 7,
        episodic_threads: 3,
        active_concepts: 5
      },
      rdf_analysis_request: {
        analysis_type: 'semantic_reasoning',
        focus_concepts: ['concept1', 'concept2'],
        time_window_filter: 'current_week',
        reasoning_depth: 'intermediate'
      },
      expected_outputs: {
        concept_updates: true,
        semantic_insights: true,
        temporal_patterns: true,
        memory_consolidation_recommendations: false
      }
    };

    const result = BrainMemoryRDFBridgeSchema.safeParse(validBridge);
    expect(result.success).toBe(true);
    expect(result.data?.rdf_analysis_request.analysis_type).toBe('semantic_reasoning');
  });
});
```

## üêç **Python RDF Service Tests**

### **Core RDF Service Tests**

```python
# rdf-service/tests/test_rdf_service.py
import pytest
import asyncio
from fastapi.testclient import TestClient
from app.main import app, rdf_service
import json
from datetime import datetime

client = TestClient(app)

class TestRDFServiceCore:
    
    def test_health_check_endpoint(self):
        """Test health check returns proper brain integration status"""
        response = client.get("/health")
        assert response.status_code == 200
        data = response.json()
        assert "status" in data
        assert "timestamp" in data
        assert "graph_size" in data
        assert "cache_size" in data
        assert data["status"] == "healthy"

    def test_basic_sparql_query_execution(self):
        """Test basic SPARQL query execution without brain context"""
        query_data = {
            "query": "SELECT * WHERE { ?s ?p ?o } LIMIT 5",
            "query_type": "SELECT",
            "reasoning": False,
            "limit": 5
        }
        
        response = client.post("/query", json=query_data)
        assert response.status_code == 200
        data = response.json()
        assert data["success"] == True
        assert "results" in data
        assert "execution_time_ms" in data
        assert "reasoning_applied" in data
        assert data["reasoning_applied"] == False

    def test_brain_enhanced_sparql_query(self):
        """Test SPARQL query with brain memory context"""
        query_data = {
            "query": """
                PREFIX omnii: <https://omnii.ai/ontology#>
                SELECT ?concept ?confidence WHERE {
                    ?concept rdf:type omnii:Concept .
                    ?concept omnii:hasConfidence ?confidence .
                    FILTER(?confidence > 0.5)
                }
            """,
            "query_type": "SELECT",
            "reasoning": True,
            "brain_context": {
                "user_id": "123e4567-e89b-12d3-a456-426614174000",
                "channel": "sms",
                "memory_window_hours": 168,
                "temporal_reasoning": True
            }
        }
        
        response = client.post("/query", json=query_data)
        assert response.status_code == 200
        data = response.json()
        assert data["success"] == True
        assert data["reasoning_applied"] == True

    def test_concept_evolution_endpoint(self):
        """Test concept evolution with brain memory integration"""
        evolution_data = {
            "concept_id": "123e4567-e89b-12d3-a456-426614174000",
            "concept_name": "test_concept",
            "current_properties": {
                "activation_strength": 0.6,
                "mention_count": 3,
                "semantic_weight": 0.7
            },
            "brain_memory_context": {
                "working_memory_references": 5,
                "episodic_memory_connections": 2,
                "semantic_network_strength": 0.8,
                "temporal_distribution": {
                    "previous_week": 0.2,
                    "current_week": 0.6,
                    "next_week": 0.2
                }
            }
        }
        
        response = client.post("/evolve-concept", json=evolution_data)
        assert response.status_code == 200
        data = response.json()
        assert "success" in data
        assert "confidence_score" in data
        assert "brain_memory_updates" in data

    def test_rdf_import_validation(self):
        """Test RDF data import with validation"""
        rdf_data = {
            "data": """
                @prefix omnii: <https://omnii.ai/ontology#> .
                @prefix ex: <http://example.org/> .
                
                ex:concept1 a omnii:Concept ;
                    omnii:hasConfidence 0.85 ;
                    omnii:hasLabel "test concept" .
            """,
            "format": "turtle",
            "validation": True
        }
        
        response = client.post("/import-rdf", json=rdf_data)
        assert response.status_code == 200
        data = response.json()
        assert data["success"] == True
        assert "triples_imported" in data

    def test_query_caching_mechanism(self):
        """Test Redis-style query caching"""
        query_data = {
            "query": "SELECT * WHERE { ?s ?p ?o } LIMIT 3",
            "query_type": "SELECT"
        }
        
        # First request - should cache
        response1 = client.post("/query", json=query_data)
        assert response1.status_code == 200
        
        # Second request - should hit cache
        response2 = client.post("/query", json=query_data)
        assert response2.status_code == 200
        
        # Should have same query_hash
        assert response1.json()["query_hash"] == response2.json()["query_hash"]

    def test_reasoning_engine_integration(self):
        """Test OWL-RL reasoning integration"""
        # First import some data with relationships
        rdf_data = {
            "data": """
                @prefix omnii: <https://omnii.ai/ontology#> .
                @prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
                
                omnii:Concept rdfs:subClassOf omnii:Entity .
                ex:concept1 a omnii:Concept .
            """,
            "format": "turtle"
        }
        client.post("/import-rdf", json=rdf_data)
        
        # Query with reasoning enabled
        query_data = {
            "query": "SELECT ?s WHERE { ?s a omnii:Entity }",
            "query_type": "SELECT",
            "reasoning": True
        }
        
        response = client.post("/query", json=query_data)
        assert response.status_code == 200
        data = response.json()
        assert data["reasoning_applied"] == True
        # Should infer that concept1 is also an Entity due to subclass relationship

class TestRDFServiceErrorHandling:
    
    def test_invalid_sparql_query(self):
        """Test handling of invalid SPARQL syntax"""
        query_data = {
            "query": "INVALID SPARQL SYNTAX",
            "query_type": "SELECT"
        }
        
        response = client.post("/query", json=query_data)
        assert response.status_code == 200
        data = response.json()
        assert data["success"] == False
        assert "error" in data

    def test_query_timeout_handling(self):
        """Test query timeout mechanism"""
        # Very complex query that should timeout
        query_data = {
            "query": """
                SELECT * WHERE {
                    ?s1 ?p1 ?o1 .
                    ?s2 ?p2 ?o2 .
                    ?s3 ?p3 ?o3 .
                    FILTER(?s1 != ?s2 && ?s2 != ?s3)
                }
            """,
            "query_type": "SELECT",
            "timeout": 1  # 1 second timeout
        }
        
        response = client.post("/query", json=query_data)
        assert response.status_code == 200
        # Should either succeed quickly or fail with timeout

    def test_malformed_rdf_import(self):
        """Test malformed RDF data import"""
        rdf_data = {
            "data": "INVALID RDF DATA",
            "format": "turtle",
            "validation": True
        }
        
        response = client.post("/import-rdf", json=rdf_data)
        assert response.status_code == 200
        data = response.json()
        assert data["success"] == False
        assert "error" in data
```

## üß† **Brain RDF Client Tests**

### **TypeScript Client Tests**

```typescript
// apps/omnii_mcp/tests/rdf/unit/brain-rdf-client.test.ts
import { describe, test, expect, beforeAll, afterAll, mock } from 'bun:test';
import { BrainRDFClient } from '../../../src/services/integrations/brain-rdf-client';
import {
  BrainRDFQuery,
  BrainConceptEvolution,
  BrainMemoryRDFBridge
} from '../../../src/types/rdf-schemas';
import { BrainMemoryContext, BRAIN_MEMORY_CONSTANTS } from '../../../src/types/brain-memory-schemas';

// Mock fetch globally
global.fetch = mock(() => Promise.resolve({
  ok: true,
  json: () => Promise.resolve({ success: true, results: [] }),
  status: 200,
  statusText: 'OK'
}));

describe('BrainRDFClient', () => {
  
  let brainRDFClient: BrainRDFClient;
  let mockBrainMemoryContext: BrainMemoryContext;

  beforeAll(() => {
    brainRDFClient = new BrainRDFClient();
    
    mockBrainMemoryContext = {
      working_memory: {
        recent_messages: [],
        time_window_messages: [],
        recently_modified_messages: [],
        active_concepts: ['concept1', 'concept2'],
        current_intent: 'test_intent',
        time_window_stats: {
          previous_week_count: 5,
          current_week_count: 10,
          next_week_count: 2,
          recently_modified_count: 1
        }
      },
      episodic_memory: {
        conversation_threads: [],
        related_episodes: []
      },
      semantic_memory: {
        activated_concepts: [],
        concept_associations: []
      },
      consolidation_metadata: {
        retrieval_timestamp: new Date().toISOString(),
        memory_strength: 0.75,
        context_channels: ['sms'],
        memory_age_hours: 24,
        consolidation_score: 0.6,
        working_memory_limit: 7,
        episodic_window_hours: 168,
        semantic_activation_threshold: 0.3
      }
    };
  });

  test('executeQuery with brain context integration', async () => {
    const query: BrainRDFQuery = {
      query: 'SELECT ?concept WHERE { ?concept a omnii:Concept }',
      query_type: 'SELECT',
      reasoning: true,
      brain_context: {
        user_id: '123e4567-e89b-12d3-a456-426614174000',
        channel: 'sms',
        memory_window_hours: BRAIN_MEMORY_CONSTANTS.EPISODIC_MEMORY_WINDOW_HOURS,
        include_working_memory: true,
        include_episodic_memory: true,
        include_semantic_memory: true,
        temporal_reasoning: true
      }
    };

    const result = await brainRDFClient.executeQuery(query);
    expect(result.success).toBe(true);
    expect(result.reasoning_applied).toBe(true);
  });

  test('evolveConceptFromBrainMemory integration', async () => {
    const evolution: BrainConceptEvolution = {
      concept_id: '123e4567-e89b-12d3-a456-426614174000',
      concept_name: 'test_concept',
      current_properties: {
        activation_strength: 0.6,
        mention_count: 3,
        semantic_weight: 0.7
      },
      new_information: [{
        subject: 'test',
        predicate: 'https://omnii.ai/ontology#test',
        object: 'value',
        confidence: 0.8
      }],
      evidence_sources: [{
        message_id: '123e4567-e89b-12d3-a456-426614174000',
        conversation_thread: 'thread_1',
        temporal_context: 'current_week',
        memory_strength: 0.8,
        channel: 'sms'
      }],
      brain_memory_context: {
        working_memory_references: 5,
        episodic_memory_connections: 3,
        semantic_network_strength: 0.7,
        temporal_distribution: {
          previous_week: 0.2,
          current_week: 0.6,
          next_week: 0.2
        }
      }
    };

    const result = await brainRDFClient.evolveConceptFromBrainMemory(evolution, mockBrainMemoryContext);
    expect(result.concept_id).toBe(evolution.concept_id);
  });

  test('analyzeBrainMemoryContext with RDF insights', async () => {
    const bridge: BrainMemoryRDFBridge = {
      brain_memory_context: {
        user_id: '123e4567-e89b-12d3-a456-426614174000',
        retrieval_timestamp: new Date().toISOString(),
        memory_strength: 0.75,
        working_memory_size: 7,
        episodic_threads: 3,
        active_concepts: 5
      },
      rdf_analysis_request: {
        analysis_type: 'semantic_reasoning',
        focus_concepts: ['concept1', 'concept2'],
        time_window_filter: 'current_week',
        reasoning_depth: 'intermediate'
      },
      expected_outputs: {
        concept_updates: true,
        semantic_insights: true,
        temporal_patterns: true,
        memory_consolidation_recommendations: true
      }
    };

    const result = await brainRDFClient.analyzeBrainMemoryContext(bridge, mockBrainMemoryContext);
    expect(result.success).toBe(true);
    expect(Array.isArray(result.concept_insights)).toBe(true);
    expect(Array.isArray(result.temporal_patterns)).toBe(true);
  });

  test('service unavailable graceful degradation', async () => {
    // Mock service as unavailable
    const unavailableClient = new BrainRDFClient();
    (unavailableClient as any).isAvailable = false;

    const query: BrainRDFQuery = {
      query: 'SELECT * WHERE { ?s ?p ?o }',
      query_type: 'SELECT'
    };

    const result = await unavailableClient.executeQuery(query);
    expect(result.success).toBe(false);
    expect(result.error).toContain('unavailable');
  });

  test('Redis caching key generation', () => {
    const query: BrainRDFQuery = {
      query: 'SELECT * WHERE { ?s ?p ?o }',
      query_type: 'SELECT',
      reasoning: true,
      brain_context: {
        user_id: '123e4567-e89b-12d3-a456-426614174000',
        channel: 'sms',
        memory_window_hours: 168
      }
    };

    const cacheKey = (brainRDFClient as any).getCacheKey(query);
    expect(cacheKey).toContain('brain_rdf');
    expect(cacheKey).toContain('SELECT');
    expect(cacheKey).toContain('true'); // reasoning
    expect(cacheKey).toContain('123e4567-e89b-12d3-a456-426614174000');
  });

  test('health check functionality', async () => {
    const health = await brainRDFClient.healthCheck();
    expect(health).toHaveProperty('status');
    expect(health).toHaveProperty('healthy');
    expect(health).toHaveProperty('brain_integration');
  });

  test('service metrics collection', async () => {
    const metrics = await brainRDFClient.getServiceMetrics();
    expect(metrics).toHaveProperty('status');
    expect(metrics).toHaveProperty('availability');
    expect(metrics).toHaveProperty('response_time_ms');
    expect(metrics).toHaveProperty('brain_integration_active');
    expect(typeof metrics.response_time_ms).toBe('number');
  });
});

describe('BrainRDFClient Error Handling', () => {
  
  test('network timeout handling', async () => {
    // Mock fetch to timeout
    global.fetch = mock(() => new Promise((_, reject) => {
      setTimeout(() => reject(new Error('timeout')), 100);
    }));

    const client = new BrainRDFClient();
    const query: BrainRDFQuery = {
      query: 'SELECT * WHERE { ?s ?p ?o }',
      query_type: 'SELECT'
    };

    const result = await client.executeQuery(query);
    expect(result.success).toBe(false);
    expect(result.error).toBeTruthy();
  });

  test('HTTP error status handling', async () => {
    global.fetch = mock(() => Promise.resolve({
      ok: false,
      status: 500,
      statusText: 'Internal Server Error'
    }));

    const client = new BrainRDFClient();
    const query: BrainRDFQuery = {
      query: 'SELECT * WHERE { ?s ?p ?o }',
      query_type: 'SELECT'
    };

    const result = await client.executeQuery(query);
    expect(result.success).toBe(false);
    expect(result.error).toContain('500');
  });

  test('invalid schema validation handling', async () => {
    const client = new BrainRDFClient();
    
    // Invalid query missing required fields
    const invalidQuery = {
      query_type: 'SELECT'
      // Missing required 'query' field
    } as any;

    await expect(client.executeQuery(invalidQuery)).rejects.toThrow();
  });
});
```

## üîó **Brain Conversation Manager RDF Integration Tests**

### **Enhanced Brain Memory Tests**

```typescript
// apps/omnii_mcp/tests/rdf/integration/brain-conversation-manager-rdf.test.ts
import { describe, test, expect, beforeAll, afterAll, mock } from 'bun:test';
import { BrainConversationManager } from '../../../src/services/brain-conversation-manager';
import { BrainMemoryContext } from '../../../src/types/brain-memory-schemas';
import { brainRDFClient } from '../../../src/services/integrations/brain-rdf-client';
import neo4j from 'neo4j-driver';

describe('BrainConversationManager RDF Integration', () => {
  
  let brainManager: BrainConversationManager;
  let mockSession: any;
  let mockBrainMemoryContext: BrainMemoryContext;

  beforeAll(async () => {
    // Mock Neo4j session
    mockSession = {
      run: mock(() => Promise.resolve({
        records: [{
          get: mock(() => ({
            properties: {
              id: 'test-concept-id',
              name: 'test concept',
              activation_strength: 0.6,
              mention_count: 3,
              semantic_weight: 0.7
            }
          }))
        }]
      })),
      close: mock(() => Promise.resolve())
    };

    brainManager = new BrainConversationManager();
    
    mockBrainMemoryContext = {
      working_memory: {
        recent_messages: [
          {
            id: 'msg1',
            content: 'test message',
            timestamp: new Date().toISOString(),
            channel: 'sms',
            source_identifier: '+1234567890'
          }
        ],
        time_window_messages: [],
        recently_modified_messages: [],
        active_concepts: ['concept1', 'concept2'],
        current_intent: 'test',
        time_window_stats: {
          previous_week_count: 5,
          current_week_count: 10,
          next_week_count: 2,
          recently_modified_count: 1
        }
      },
      episodic_memory: {
        conversation_threads: [],
        related_episodes: []
      },
      semantic_memory: {
        activated_concepts: [],
        concept_associations: []
      },
      consolidation_metadata: {
        retrieval_timestamp: new Date().toISOString(),
        memory_strength: 0.75,
        context_channels: ['sms'],
        memory_age_hours: 24,
        consolidation_score: 0.6,
        working_memory_limit: 7,
        episodic_window_hours: 168,
        semantic_activation_threshold: 0.3
      }
    };
  });

  test('extractAndLinkConceptsWithRDF enhances basic concept extraction', async () => {
    // Mock RDF service availability
    const mockIsServiceAvailable = mock(() => true);
    brainRDFClient.isServiceAvailable = mockIsServiceAvailable;

    // Mock RDF query execution
    const mockExecuteQuery = mock(() => Promise.resolve({
      success: true,
      results: [
        {
          label: { value: 'enhanced_concept' },
          confidence: { value: '0.85' },
          related_concept: { value: 'related_concept' }
        }
      ],
      reasoning_applied: true
    }));
    brainRDFClient.executeQuery = mockExecuteQuery;

    await brainManager.extractAndLinkConceptsWithRDF(
      mockSession,
      'test-message-id',
      'test content about concepts',
      'test-user-id',
      mockBrainMemoryContext
    );

    expect(mockIsServiceAvailable).toHaveBeenCalled();
    expect(mockExecuteQuery).toHaveBeenCalled();
    expect(mockSession.run).toHaveBeenCalled();
  });

  test('triggerConceptEvolution with brain memory readiness criteria', async () => {
    // Mock concept evolution readiness
    const mockEvaluateReadiness = mock(() => true);
    (brainManager as any).evaluateConceptEvolutionReadiness = mockEvaluateReadiness;

    // Mock RDF concept evolution
    const mockEvolveConcept = mock(() => Promise.resolve({
      success: true,
      evolution_applied: true,
      confidence_score: 0.85,
      changes_detected: [
        {
          property: 'activation_strength',
          old_value: '0.6',
          new_value: '0.75',
          evidence_strength: 0.8
        }
      ],
      brain_memory_updates: {
        neo4j_concept_updated: true,
        related_concepts_affected: [],
        memory_consolidation_triggered: false,
        time_window_impacts: {
          previous_week: false,
          current_week: true,
          next_week: false
        }
      }
    }));
    brainRDFClient.evolveConceptFromBrainMemory = mockEvolveConcept;

    await (brainManager as any).triggerConceptEvolution(
      'test concept',
      'test-user-id',
      'test-message-id',
      mockBrainMemoryContext
    );

    expect(mockEvaluateReadiness).toHaveBeenCalled();
    expect(mockEvolveConcept).toHaveBeenCalled();
  });

  test('getBrainMemoryContextWithRDF enhances base context', async () => {
    // Mock base context retrieval
    const mockGetBrainMemoryContext = mock(() => Promise.resolve(mockBrainMemoryContext));
    brainManager.getBrainMemoryContext = mockGetBrainMemoryContext;

    // Mock RDF analysis
    const mockAnalyzeBrainMemory = mock(() => Promise.resolve({
      success: true,
      concept_insights: [
        {
          concept_id: 'concept1',
          insight_type: 'semantic_connection',
          confidence: 0.8,
          description: 'Strong semantic connection detected'
        }
      ],
      temporal_patterns: [],
      semantic_connections: [],
      consolidation_recommendations: []
    }));
    brainRDFClient.analyzeBrainMemoryContext = mockAnalyzeBrainMemory;

    const enhancedContext = await brainManager.getBrainMemoryContextWithRDF(
      'test-user-id',
      'test message',
      'sms',
      '+1234567890'
    );

    expect(mockGetBrainMemoryContext).toHaveBeenCalled();
    expect(mockAnalyzeBrainMemory).toHaveBeenCalled();
    expect(enhancedContext).toHaveProperty('rdf_enhancements');
  });

  test('evaluateConceptEvolutionReadiness follows brain memory patterns', () => {
    const concept = {
      name: 'test concept',
      activation_strength: 0.6,
      mention_count: 3,
      semantic_weight: 0.7
    };

    const isReady = (brainManager as any).evaluateConceptEvolutionReadiness(
      concept,
      2, // active memories
      mockBrainMemoryContext
    );

    expect(typeof isReady).toBe('boolean');
  });

  test('calculateTemporalDistribution uses brain memory time windows', () => {
    const distribution = (brainManager as any).calculateTemporalDistribution(mockBrainMemoryContext);
    
    expect(distribution).toHaveProperty('previous_week');
    expect(distribution).toHaveProperty('current_week');
    expect(distribution).toHaveProperty('next_week');
    expect(distribution.previous_week + distribution.current_week + distribution.next_week).toBeCloseTo(1, 1);
  });

  test('applyEvolutionToNeo4j updates concept properties', async () => {
    const evolutionResult = {
      concept_id: 'test-concept-id',
      changes_detected: [
        {
          property: 'activation_strength',
          new_value: '0.8',
          evidence_strength: 0.9
        }
      ],
      brain_memory_updates: {
        related_concepts_affected: ['related-concept-id']
      }
    };

    await (brainManager as any).applyEvolutionToNeo4j(mockSession, evolutionResult);
    
    expect(mockSession.run).toHaveBeenCalledWith(
      expect.stringContaining('SET concept.activation_strength'),
      expect.objectContaining({
        conceptId: 'test-concept-id',
        newValue: '0.8'
      })
    );
  });

  test('graceful degradation when RDF service unavailable', async () => {
    // Mock service as unavailable
    const mockIsServiceAvailable = mock(() => false);
    brainRDFClient.isServiceAvailable = mockIsServiceAvailable;

    await brainManager.extractAndLinkConceptsWithRDF(
      mockSession,
      'test-message-id',
      'test content',
      'test-user-id',
      mockBrainMemoryContext
    );

    // Should still proceed with basic concept extraction
    expect(mockSession.run).toHaveBeenCalled();
  });
});
```

## ‚ö° **Performance & Production Tests**

### **Load Testing & Monitoring**

```typescript
// apps/omnii_mcp/tests/rdf/performance/rdf-performance.test.ts
import { describe, test, expect, beforeAll } from 'bun:test';
import { BrainRDFClient } from '../../../src/services/integrations/brain-rdf-client';
import { BrainRDFQuery } from '../../../src/types/rdf-schemas';
import { BRAIN_MEMORY_CONSTANTS } from '../../../src/types/brain-memory-schemas';

describe('RDF Performance Tests', () => {
  
  let brainRDFClient: BrainRDFClient;

  beforeAll(() => {
    brainRDFClient = new BrainRDFClient();
  });

  test('query execution performance within timeout limits', async () => {
    const startTime = Date.now();
    
    const query: BrainRDFQuery = {
      query: 'SELECT * WHERE { ?s ?p ?o } LIMIT 10',
      query_type: 'SELECT',
      timeout: 5000 // 5 second timeout
    };

    const result = await brainRDFClient.executeQuery(query);
    const executionTime = Date.now() - startTime;
    
    expect(executionTime).toBeLessThan(5000);
    expect(result.execution_time_ms).toBeGreaterThan(0);
  });

  test('concurrent query handling', async () => {
    const queries = Array.from({ length: 10 }, (_, i) => ({
      query: `SELECT * WHERE { ?s ?p ?o } LIMIT ${i + 1}`,
      query_type: 'SELECT' as const
    }));

    const startTime = Date.now();
    const results = await Promise.all(
      queries.map(query => brainRDFClient.executeQuery(query))
    );
    const totalTime = Date.now() - startTime;

    expect(results).toHaveLength(10);
    expect(results.every(r => r.success !== undefined)).toBe(true);
    expect(totalTime).toBeLessThan(30000); // Should complete within 30 seconds
  });

  test('cache performance optimization', async () => {
    const query: BrainRDFQuery = {
      query: 'SELECT * WHERE { ?s ?p ?o } LIMIT 5',
      query_type: 'SELECT'
    };

    // First query - should hit service
    const start1 = Date.now();
    const result1 = await brainRDFClient.executeQuery(query);
    const time1 = Date.now() - start1;

    // Second identical query - should hit cache
    const start2 = Date.now();
    const result2 = await brainRDFClient.executeQuery(query);
    const time2 = Date.now() - start2;

    expect(result1.query_hash).toBe(result2.query_hash);
    expect(time2).toBeLessThan(time1); // Cache should be faster
  });

  test('memory usage monitoring during concept evolution', async () => {
    const initialMemory = process.memoryUsage();
    
    // Simulate multiple concept evolutions
    const evolutions = Array.from({ length: 5 }, (_, i) => ({
      concept_id: `concept-${i}`,
      concept_name: `test concept ${i}`,
      current_properties: {
        activation_strength: 0.5 + (i * 0.1),
        mention_count: i + 1,
        semantic_weight: 0.6
      },
      new_information: [],
      evidence_sources: [],
      brain_memory_context: {
        working_memory_references: 5,
        episodic_memory_connections: 3,
        semantic_network_strength: 0.7,
        temporal_distribution: {
          previous_week: 0.3,
          current_week: 0.5,
          next_week: 0.2
        }
      }
    }));

    await Promise.all(
      evolutions.map(evolution => 
        brainRDFClient.evolveConceptFromBrainMemory(evolution)
      )
    );

    const finalMemory = process.memoryUsage();
    const memoryIncrease = finalMemory.heapUsed - initialMemory.heapUsed;
    
    // Memory increase should be reasonable (less than 50MB)
    expect(memoryIncrease).toBeLessThan(50 * 1024 * 1024);
  });

  test('brain memory context retrieval performance', async () => {
    const startTime = Date.now();
    
    // Simulate complex brain memory context
    const mockContext = {
      working_memory: {
        recent_messages: Array.from({ length: 20 }, (_, i) => ({
          id: `msg-${i}`,
          content: `message ${i}`,
          timestamp: new Date().toISOString(),
          channel: 'sms',
          source_identifier: '+1234567890'
        })),
        time_window_messages: [],
        recently_modified_messages: [],
        active_concepts: Array.from({ length: 15 }, (_, i) => `concept-${i}`),
        current_intent: 'test',
        time_window_stats: {
          previous_week_count: 50,
          current_week_count: 75,
          next_week_count: 25,
          recently_modified_count: 5
        }
      },
      episodic_memory: { conversation_threads: [], related_episodes: [] },
      semantic_memory: { activated_concepts: [], concept_associations: [] },
      consolidation_metadata: {
        retrieval_timestamp: new Date().toISOString(),
        memory_strength: 0.8,
        context_channels: ['sms'],
        memory_age_hours: 48,
        consolidation_score: 0.7,
        working_memory_limit: 7,
        episodic_window_hours: 168,
        semantic_activation_threshold: 0.3
      }
    };

    const bridge = {
      brain_memory_context: {
        user_id: '123e4567-e89b-12d3-a456-426614174000',
        retrieval_timestamp: new Date().toISOString(),
        memory_strength: 0.8,
        working_memory_size: 20,
        episodic_threads: 10,
        active_concepts: 15
      },
      rdf_analysis_request: {
        analysis_type: 'semantic_reasoning' as const,
        reasoning_depth: 'deep' as const
      },
      expected_outputs: {
        concept_updates: true,
        semantic_insights: true,
        temporal_patterns: true,
        memory_consolidation_recommendations: true
      }
    };

    const result = await brainRDFClient.analyzeBrainMemoryContext(bridge, mockContext);
    const executionTime = Date.now() - startTime;
    
    expect(executionTime).toBeLessThan(10000); // Should complete within 10 seconds
    expect(result).toHaveProperty('success');
  });
});

describe('RDF Production Monitoring Tests', () => {
  
  test('health check response time', async () => {
    const client = new BrainRDFClient();
    const startTime = Date.now();
    
    const health = await client.healthCheck();
    const responseTime = Date.now() - startTime;
    
    expect(responseTime).toBeLessThan(5000); // Health check should be fast
    expect(health).toHaveProperty('status');
    expect(health).toHaveProperty('healthy');
  });

  test('service metrics collection accuracy', async () => {
    const client = new BrainRDFClient();
    const metrics = await client.getServiceMetrics();
    
    expect(metrics.status).toMatch(/^(healthy|degraded|unhealthy)$/);
    expect(typeof metrics.availability).toBe('boolean');
    expect(typeof metrics.response_time_ms).toBe('number');
    expect(typeof metrics.brain_integration_active).toBe('boolean');
    expect(metrics.response_time_ms).toBeGreaterThan(0);
  });

  test('error rate monitoring', async () => {
    const client = new BrainRDFClient();
    const testQueries = 10;
    let successCount = 0;
    let errorCount = 0;

    for (let i = 0; i < testQueries; i++) {
      try {
        const result = await client.executeQuery({
          query: `SELECT * WHERE { ?s ?p ?o } LIMIT ${i + 1}`,
          query_type: 'SELECT'
        });
        
        if (result.success) {
          successCount++;
        } else {
          errorCount++;
        }
      } catch (error) {
        errorCount++;
      }
    }

    const errorRate = errorCount / testQueries;
    expect(errorRate).toBeLessThan(0.1); // Less than 10% error rate
  });

  test('Railway deployment environment validation', () => {
    // Validate environment variables
    const requiredEnvVars = [
      'RDF_SERVICE_URL',
      'REDIS_URL',
      'NEO4J_URI'
    ];

    // In test environment, these might be mock values
    requiredEnvVars.forEach(envVar => {
      expect(process.env[envVar] || 'mock-value').toBeTruthy();
    });
  });

  test('Redis caching integration health', async () => {
    // This would test actual Redis integration in real environment
    const client = new BrainRDFClient();
    
    const query: BrainRDFQuery = {
      query: 'SELECT * WHERE { ?s ?p ?o } LIMIT 1',
      query_type: 'SELECT'
    };

    // Execute query twice to test caching
    await client.executeQuery(query);
    const cachedResult = await client.executeQuery(query);
    
    expect(cachedResult).toHaveProperty('query_hash');
  });
});
```

## üß™ **Test Execution Strategy**

### **Test Suite Organization**

```typescript
// apps/omnii_mcp/tests/rdf/test-runner.ts
import { describe, test } from 'bun:test';

// Test execution order for TDD
describe('RDF Implementation Test Suite', () => {
  
  describe('1. Schema Validation (Foundation)', () => {
    test('Run schema tests first to validate types');
  });

  describe('2. Core RDF Service (Python)', () => {
    test('Run Python service tests');
  });

  describe('3. Brain RDF Client (TypeScript)', () => {
    test('Run client integration tests');
  });

  describe('4. Brain Memory Integration', () => {
    test('Run enhanced conversation manager tests');
  });

  describe('5. Performance & Production', () => {
    test('Run performance and monitoring tests');
  });
});
```

### **Test Coverage Requirements**

**Target: 100% Test Coverage**
- ‚úÖ **Unit Tests**: All schema validation, service methods, client functions
- ‚úÖ **Integration Tests**: Neo4j + RDF integration, Redis caching, brain memory enhancement
- ‚úÖ **Performance Tests**: Query execution, concept evolution, memory context retrieval
- ‚úÖ **Error Handling**: Service unavailable, timeouts, invalid data, network failures
- ‚úÖ **Production Tests**: Health checks, monitoring, Railway deployment validation

### **TDD Implementation Sequence**

1. **Write Schema Tests** ‚Üí Implement Zod schemas
2. **Write Service Tests** ‚Üí Implement Python FastAPI service
3. **Write Client Tests** ‚Üí Implement BrainRDFClient
4. **Write Integration Tests** ‚Üí Implement brain memory enhancements
5. **Write Performance Tests** ‚Üí Optimize and deploy

This comprehensive test plan ensures **100% coverage** of the RDF reasoning microservice while following TDD principles and maintaining integration with your sophisticated brain memory system.
