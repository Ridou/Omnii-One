---
phase: 04-data-ingestion-pipeline
plan: 06
type: execute
wave: 4
depends_on: ["04-05"]
files_modified:
  - apps/omnii_mcp/src/ingestion/jobs/sync-scheduler.ts
  - apps/omnii_mcp/src/ingestion/jobs/workers.ts
  - apps/omnii_mcp/src/ingestion/jobs/index.ts
  - apps/omnii_mcp/src/app.ts
autonomous: true

must_haves:
  truths:
    - "Background sync job runs on configurable schedule (default: every 15 minutes)"
    - "Sync jobs have jitter to prevent thundering herd"
    - "Rate limit errors pause job scheduling temporarily"
    - "Failed jobs retry with exponential backoff"
    - "Worker processes jobs from Redis queue"
  artifacts:
    - path: "apps/omnii_mcp/src/ingestion/jobs/sync-scheduler.ts"
      provides: "Job scheduler for cron-based sync"
      exports: ["startSyncScheduler", "stopSyncScheduler"]
    - path: "apps/omnii_mcp/src/ingestion/jobs/workers.ts"
      provides: "BullMQ workers for processing sync jobs"
      exports: ["startIngestionWorkers", "stopIngestionWorkers"]
    - path: "apps/omnii_mcp/src/ingestion/jobs/index.ts"
      provides: "Barrel export for jobs module"
  key_links:
    - from: "apps/omnii_mcp/src/ingestion/jobs/sync-scheduler.ts"
      to: "apps/omnii_mcp/src/ingestion/jobs/queue.ts"
      via: "createIngestionQueue import"
      pattern: "createIngestionQueue"
    - from: "apps/omnii_mcp/src/ingestion/jobs/workers.ts"
      to: "apps/omnii_mcp/src/ingestion/sources/google-calendar.ts"
      via: "ingestCalendarEvents import"
      pattern: "ingestCalendarEvents"
---

<objective>
Implement BullMQ background job scheduling for automated calendar sync

Purpose: Enable automatic background sync with rate limiting, jitter, and retry logic
Output: Job scheduler and workers that process sync jobs reliably via Redis queue
</objective>

<execution_context>
@/Users/santino/.claude/get-shit-done/workflows/execute-plan.md
@/Users/santino/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-data-ingestion-pipeline/04-RESEARCH.md
@apps/omnii_mcp/src/ingestion/jobs/queue.ts
@apps/omnii_mcp/src/ingestion/sources/google-calendar.ts
@apps/omnii_mcp/src/ingestion/sync-state.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create job scheduler for calendar sync</name>
  <files>apps/omnii_mcp/src/ingestion/jobs/sync-scheduler.ts</files>
  <action>
Create BullMQ job scheduler for automated calendar sync.

Create `apps/omnii_mcp/src/ingestion/jobs/sync-scheduler.ts`:

```typescript
/**
 * Sync Job Scheduler
 *
 * Uses BullMQ Job Schedulers API (v5.16.0+) for cron-based sync scheduling.
 * Adds jitter to prevent thundering herd on Google APIs.
 */

import { Queue } from "bullmq";
import { createIngestionQueue, getRedisConnection } from "./queue";
import { getSyncStateService, type SyncSource } from "../sync-state";

/**
 * Job data structure for sync jobs
 */
export interface SyncJobData {
  source: SyncSource;
  userId?: string; // If set, sync only this user. If null, sync all users.
}

// Queue instance
let syncQueue: Queue<SyncJobData> | null = null;

// Track scheduled jobs for cleanup
const scheduledJobs = new Set<string>();

/**
 * Get or create the sync queue
 */
function getSyncQueue(): Queue<SyncJobData> {
  if (!syncQueue) {
    syncQueue = createIngestionQueue("data-sync") as Queue<SyncJobData>;
  }
  return syncQueue;
}

/**
 * Add a sync job to the queue with jitter
 *
 * @param source - Which service to sync
 * @param userId - Optional user ID (null = all users)
 * @param delayMs - Optional delay in milliseconds
 */
export async function enqueueSyncJob(
  source: SyncSource,
  userId?: string,
  delayMs?: number
): Promise<string> {
  const queue = getSyncQueue();

  // Add jitter to prevent thundering herd (0-5 seconds)
  const jitter = Math.floor(Math.random() * 5000);
  const totalDelay = (delayMs || 0) + jitter;

  const job = await queue.add(
    `sync-${source}`,
    { source, userId },
    {
      delay: totalDelay,
      attempts: 3,
      backoff: {
        type: "exponential",
        delay: 1000, // Start with 1 second
      },
      removeOnComplete: 100,
      removeOnFail: 500,
    }
  );

  console.log(
    `Enqueued sync job ${job.id} for ${source}${userId ? ` (user: ${userId})` : ""} with ${totalDelay}ms delay`
  );

  return job.id ?? "";
}

/**
 * Schedule recurring sync jobs using BullMQ repeatable jobs
 *
 * Note: BullMQ 5.16.0+ has Job Schedulers API, but we use repeatable jobs
 * for broader compatibility. Upgrade to Job Schedulers when BullMQ 6.x is stable.
 */
export async function startSyncScheduler(
  cronPattern: string = "*/15 * * * *" // Every 15 minutes by default
): Promise<void> {
  const queue = getSyncQueue();

  // Remove any existing repeatable jobs for clean restart
  const existingJobs = await queue.getRepeatableJobs();
  for (const job of existingJobs) {
    if (job.name.startsWith("scheduled-sync-")) {
      await queue.removeRepeatableByKey(job.key);
      console.log(`Removed existing scheduled job: ${job.name}`);
    }
  }

  // Schedule calendar sync
  const calendarJob = await queue.add(
    "scheduled-sync-calendar",
    { source: "google_calendar" as SyncSource },
    {
      repeat: {
        pattern: cronPattern,
      },
      attempts: 3,
      backoff: {
        type: "exponential",
        delay: 1000,
      },
    }
  );

  scheduledJobs.add("scheduled-sync-calendar");
  console.log(`Scheduled calendar sync with pattern: ${cronPattern}`);

  // Future: Add other sources here
  // scheduledJobs.add("scheduled-sync-tasks");
  // scheduledJobs.add("scheduled-sync-gmail");
  // scheduledJobs.add("scheduled-sync-contacts");
}

/**
 * Stop the sync scheduler and remove repeatable jobs
 */
export async function stopSyncScheduler(): Promise<void> {
  const queue = getSyncQueue();

  const jobs = await queue.getRepeatableJobs();
  for (const job of jobs) {
    if (scheduledJobs.has(job.name)) {
      await queue.removeRepeatableByKey(job.key);
      scheduledJobs.delete(job.name);
      console.log(`Stopped scheduled job: ${job.name}`);
    }
  }
}

/**
 * Get status of scheduled jobs
 */
export async function getSchedulerStatus(): Promise<{
  scheduled: string[];
  queue: {
    waiting: number;
    active: number;
    completed: number;
    failed: number;
  };
}> {
  const queue = getSyncQueue();
  const [waiting, active, completed, failed] = await Promise.all([
    queue.getWaitingCount(),
    queue.getActiveCount(),
    queue.getCompletedCount(),
    queue.getFailedCount(),
  ]);

  return {
    scheduled: Array.from(scheduledJobs),
    queue: { waiting, active, completed, failed },
  };
}

/**
 * Enqueue sync for all users with connected accounts
 *
 * Called by the scheduled job worker to fan out to per-user sync jobs.
 */
export async function enqueueAllUserSyncs(source: SyncSource): Promise<number> {
  const syncStateService = getSyncStateService();

  // Get users that need sync (haven't synced in last 15 minutes)
  const userIds = await syncStateService.getUsersNeedingSync(source, 15);

  // Enqueue sync job for each user with staggered delays
  for (let i = 0; i < userIds.length; i++) {
    // Stagger jobs: first user immediately, then 1s apart + jitter
    const baseDelay = i * 1000;
    await enqueueSyncJob(source, userIds[i], baseDelay);
  }

  console.log(`Enqueued ${userIds.length} user sync jobs for ${source}`);
  return userIds.length;
}
```
  </action>
  <verify>
File exists at apps/omnii_mcp/src/ingestion/jobs/sync-scheduler.ts.
TypeScript compiles: `cd apps/omnii_mcp && bunx tsc --noEmit src/ingestion/jobs/sync-scheduler.ts`
  </verify>
  <done>Job scheduler created with cron scheduling and jitter for thundering herd prevention</done>
</task>

<task type="auto">
  <name>Task 2: Create BullMQ workers for processing sync jobs</name>
  <files>apps/omnii_mcp/src/ingestion/jobs/workers.ts</files>
  <action>
Create BullMQ workers to process sync jobs.

Create `apps/omnii_mcp/src/ingestion/jobs/workers.ts`:

```typescript
/**
 * Ingestion Workers
 *
 * BullMQ workers that process sync jobs from the queue.
 * Handles per-user sync with rate limiting and error recovery.
 */

import { Worker, Job } from "bullmq";
import { getRedisConnection } from "./queue";
import { enqueueAllUserSyncs, type SyncJobData } from "./sync-scheduler";
import { ingestCalendarEvents, type CalendarSyncResult } from "../sources/google-calendar";
import { getSyncStateService } from "../sync-state";

// Worker instances for cleanup
let syncWorker: Worker<SyncJobData> | null = null;

/**
 * Process a sync job
 */
async function processSyncJob(job: Job<SyncJobData>): Promise<{
  success: boolean;
  usersProcessed?: number;
  result?: CalendarSyncResult;
}> {
  const { source, userId } = job.data;

  console.log(`Processing sync job ${job.id}: source=${source}, userId=${userId || "all"}`);

  // If no userId, this is a scheduled job - fan out to all users
  if (!userId) {
    const usersEnqueued = await enqueueAllUserSyncs(source);
    return { success: true, usersProcessed: usersEnqueued };
  }

  // Process single user sync
  try {
    // Get user's Neo4j client
    // Dynamic import to avoid circular dependencies
    const { createClientForUser } = await import("../../services/neo4j/http-client");
    const client = await createClientForUser(userId);

    if (!client) {
      console.warn(`User ${userId} has no Neo4j database, skipping sync`);
      return { success: true }; // Not an error, just skip
    }

    // Run the appropriate sync based on source
    let result: CalendarSyncResult;

    switch (source) {
      case "google_calendar":
        result = await ingestCalendarEvents(userId, client);
        break;

      // Future sources will be added here
      // case "google_tasks":
      //   result = await ingestTasks(userId, client);
      //   break;
      // case "google_gmail":
      //   result = await ingestGmail(userId, client);
      //   break;
      // case "google_contacts":
      //   result = await ingestContacts(userId, client);
      //   break;

      default:
        throw new Error(`Unsupported sync source: ${source}`);
    }

    console.log(
      `Sync complete for user ${userId}: ${result.eventsCreated} events, ${result.contactsCreated} contacts`
    );

    return { success: result.success, result };

  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    console.error(`Sync failed for user ${userId}:`, errorMessage);

    // Mark sync as failed
    const syncStateService = getSyncStateService();
    await syncStateService.markSyncFailed(userId, source, errorMessage);

    // Re-throw to trigger BullMQ retry
    throw error;
  }
}

/**
 * Start the ingestion workers
 *
 * @param concurrency - Number of concurrent jobs (default: 3)
 */
export async function startIngestionWorkers(concurrency: number = 3): Promise<void> {
  if (syncWorker) {
    console.warn("Ingestion workers already running");
    return;
  }

  const connection = getRedisConnection();

  syncWorker = new Worker<SyncJobData>(
    "data-sync",
    processSyncJob,
    {
      connection,
      concurrency,
      limiter: {
        max: 10, // Max 10 jobs per duration
        duration: 60000, // Per minute (respects Google API quota)
      },
    }
  );

  // Event handlers for monitoring
  syncWorker.on("completed", (job, result) => {
    console.log(`Job ${job.id} completed:`, JSON.stringify(result).slice(0, 200));
  });

  syncWorker.on("failed", (job, error) => {
    console.error(`Job ${job?.id} failed:`, error.message);
  });

  syncWorker.on("error", (error) => {
    console.error("Worker error:", error);
  });

  syncWorker.on("stalled", (jobId) => {
    console.warn(`Job ${jobId} stalled`);
  });

  console.log(`Ingestion worker started with concurrency ${concurrency}`);
}

/**
 * Stop the ingestion workers gracefully
 */
export async function stopIngestionWorkers(): Promise<void> {
  if (syncWorker) {
    await syncWorker.close();
    syncWorker = null;
    console.log("Ingestion worker stopped");
  }
}

/**
 * Get worker status
 */
export function getWorkerStatus(): {
  running: boolean;
  concurrency?: number;
} {
  if (!syncWorker) {
    return { running: false };
  }

  return {
    running: true,
    concurrency: syncWorker.opts.concurrency,
  };
}
```
  </action>
  <verify>
File exists at apps/omnii_mcp/src/ingestion/jobs/workers.ts.
TypeScript compiles: `cd apps/omnii_mcp && bunx tsc --noEmit src/ingestion/jobs/workers.ts`
  </verify>
  <done>BullMQ workers process sync jobs with rate limiting and error handling</done>
</task>

<task type="auto">
  <name>Task 3: Create jobs barrel export and wire into app startup</name>
  <files>apps/omnii_mcp/src/ingestion/jobs/index.ts, apps/omnii_mcp/src/app.ts</files>
  <action>
Create jobs barrel export and optionally start workers on app startup.

1. Create `apps/omnii_mcp/src/ingestion/jobs/index.ts`:

```typescript
/**
 * Ingestion Jobs Module
 *
 * BullMQ-based background job processing for data sync.
 */

export { getRedisConnection, createIngestionQueue } from "./queue";

export {
  enqueueSyncJob,
  startSyncScheduler,
  stopSyncScheduler,
  getSchedulerStatus,
  enqueueAllUserSyncs,
  type SyncJobData,
} from "./sync-scheduler";

export {
  startIngestionWorkers,
  stopIngestionWorkers,
  getWorkerStatus,
} from "./workers";
```

2. In `apps/omnii_mcp/src/app.ts`, add optional background job startup.

Find the section where the server starts (typically at the end with `app.listen()`) and add:

```typescript
// Optional: Start background ingestion workers
// Only start if Redis is available and not in test mode
if (process.env.OMNII_REDIS_URL && process.env.NODE_ENV !== "test") {
  import("./ingestion/jobs")
    .then(async ({ startIngestionWorkers, startSyncScheduler }) => {
      try {
        await startIngestionWorkers(3);
        await startSyncScheduler("*/15 * * * *"); // Every 15 minutes
        console.log("Background ingestion workers started");
      } catch (error) {
        console.warn("Failed to start ingestion workers:", error);
        // Non-fatal - app continues without background sync
      }
    })
    .catch((err) => {
      console.warn("Ingestion module not available:", err);
    });
}
```

Add graceful shutdown handling if not present:

```typescript
// Graceful shutdown
process.on("SIGTERM", async () => {
  console.log("SIGTERM received, shutting down...");
  try {
    const { stopIngestionWorkers, stopSyncScheduler } = await import("./ingestion/jobs");
    await stopSyncScheduler();
    await stopIngestionWorkers();
  } catch {
    // Module may not be loaded
  }
  process.exit(0);
});
```

Note: These additions should be placed after the app is created but the startup logic should be conditional on Redis availability.
  </action>
  <verify>
jobs/index.ts exists and compiles.
App.ts compiles: `cd apps/omnii_mcp && bunx tsc --noEmit src/app.ts`
  </verify>
  <done>Jobs module exported, workers optionally start with app when Redis available</done>
</task>

</tasks>

<verification>
1. Scheduler compiles: `cd apps/omnii_mcp && bunx tsc --noEmit src/ingestion/jobs/sync-scheduler.ts`
2. Workers compile: `cd apps/omnii_mcp && bunx tsc --noEmit src/ingestion/jobs/workers.ts`
3. Jobs index compiles: `cd apps/omnii_mcp && bunx tsc --noEmit src/ingestion/jobs/index.ts`
4. App compiles with workers: `cd apps/omnii_mcp && bunx tsc --noEmit src/app.ts`
</verification>

<success_criteria>
- Sync scheduler creates repeatable jobs with configurable cron pattern
- Jobs have jitter (0-5 seconds) to prevent thundering herd
- Workers process jobs with concurrency limit (default: 3)
- Rate limiter respects Google API quota (max 10 jobs/minute)
- Failed jobs retry with exponential backoff
- Workers start optionally when Redis is available
- Graceful shutdown stops workers cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/04-data-ingestion-pipeline/04-06-SUMMARY.md`
</output>
