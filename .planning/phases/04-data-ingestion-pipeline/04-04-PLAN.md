---
phase: 04-data-ingestion-pipeline
plan: 04
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - apps/omnii_mcp/src/routes/ingestion/index.ts
  - apps/omnii_mcp/src/app.ts
autonomous: true

user_setup:
  - service: composio
    why: "Google OAuth integration requires Composio dashboard configuration"
    dashboard_config:
      - task: "Create Google Calendar auth config"
        location: "Composio Dashboard -> Integrations -> Google Calendar -> Configure"
      - task: "Note the auth config ID for OAuth initiation"
        location: "Composio Dashboard -> Integrations -> Google Calendar -> Auth Config ID"

must_haves:
  truths:
    - "User can initiate Google OAuth flow via POST /api/ingestion/connect"
    - "User receives redirect URL to authorize Google account"
    - "OAuth callback stores connection status in Composio"
    - "User can check connection status via GET /api/ingestion/status"
  artifacts:
    - path: "apps/omnii_mcp/src/routes/ingestion/index.ts"
      provides: "OAuth initiation and status endpoints"
      exports: ["ingestionRoutes"]
    - path: "apps/omnii_mcp/src/app.ts"
      provides: "Ingestion routes mounted on /api/ingestion"
      contains: "ingestionRoutes"
  key_links:
    - from: "apps/omnii_mcp/src/routes/ingestion/index.ts"
      to: "apps/omnii_mcp/src/ingestion/composio-client.ts"
      via: "getComposioClient import"
      pattern: "getComposioClient"
    - from: "apps/omnii_mcp/src/app.ts"
      to: "apps/omnii_mcp/src/routes/ingestion/index.ts"
      via: "route registration"
      pattern: "ingestionRoutes"
---

<objective>
Create Google OAuth connection routes using Composio for account linking

Purpose: Enable users to connect their Google account for data ingestion via Composio's OAuth abstraction
Output: HTTP endpoints for OAuth initiation, callback handling, and connection status
</objective>

<execution_context>
@/Users/santino/.claude/get-shit-done/workflows/execute-plan.md
@/Users/santino/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-data-ingestion-pipeline/04-RESEARCH.md
@apps/omnii_mcp/src/app.ts
@apps/omnii_mcp/src/routes/auth.ts
@apps/omnii_mcp/src/ingestion/composio-client.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ingestion routes for OAuth flow</name>
  <files>apps/omnii_mcp/src/routes/ingestion/index.ts</files>
  <action>
Create Elysia routes for Google OAuth connection via Composio.

Create `apps/omnii_mcp/src/routes/ingestion/index.ts`:

```typescript
/**
 * Data Ingestion Routes
 *
 * Handles Google OAuth connection and data sync operations.
 * Uses Composio for OAuth abstraction and credential management.
 */

import { Elysia, t } from "elysia";
import { getComposioClient } from "../../ingestion/composio-client";
import { getSyncStateService, type SyncSource } from "../../ingestion/sync-state";

/**
 * Google service to Composio integration mapping
 */
const GOOGLE_INTEGRATIONS: Record<string, string> = {
  calendar: "googlecalendar",
  tasks: "googletasks",
  gmail: "gmail",
  contacts: "googlecontacts",
};

/**
 * Ingestion routes for OAuth and sync management
 */
export const ingestionRoutes = new Elysia({ prefix: "/ingestion" })
  /**
   * Initiate Google OAuth connection
   *
   * POST /api/ingestion/connect
   * Body: { service: "calendar" | "tasks" | "gmail" | "contacts", redirectUrl?: string }
   *
   * Returns redirect URL for user to authorize Google account.
   * After authorization, Composio stores credentials securely.
   */
  .post(
    "/connect",
    async ({ body, set }) => {
      const { service, userId, redirectUrl } = body;

      const integration = GOOGLE_INTEGRATIONS[service];
      if (!integration) {
        set.status = 400;
        return {
          error: "Invalid service",
          validServices: Object.keys(GOOGLE_INTEGRATIONS),
        };
      }

      try {
        const composio = getComposioClient();

        // Initiate OAuth connection via Composio
        // The entityId should be the user's ID for per-user connections
        const connectionRequest = await composio.getEntity(userId).initiateConnection({
          appName: integration,
          redirectUrl: redirectUrl || `${process.env.MCP_BASE_URL}/api/ingestion/callback`,
        });

        return {
          success: true,
          redirectUrl: connectionRequest.redirectUrl,
          connectionId: connectionRequest.connectionId,
          message: `Redirect user to authorize ${service} access`,
        };
      } catch (error) {
        set.status = 500;
        return {
          error: "Failed to initiate OAuth connection",
          details: error instanceof Error ? error.message : String(error),
        };
      }
    },
    {
      body: t.Object({
        service: t.Union([
          t.Literal("calendar"),
          t.Literal("tasks"),
          t.Literal("gmail"),
          t.Literal("contacts"),
        ]),
        userId: t.String({ minLength: 1 }),
        redirectUrl: t.Optional(t.String()),
      }),
    }
  )

  /**
   * OAuth callback handler
   *
   * GET /api/ingestion/callback
   *
   * Composio redirects here after user authorizes.
   * We verify the connection and redirect to success page.
   */
  .get(
    "/callback",
    async ({ query, set }) => {
      // Composio handles token exchange automatically
      // We just need to acknowledge and redirect user
      const { connection_id, status } = query;

      if (status === "success" && connection_id) {
        // Redirect to success page or return success response
        set.redirect = `${process.env.MCP_BASE_URL || ""}/connection-success?id=${connection_id}`;
        return;
      }

      // Handle failure
      set.redirect = `${process.env.MCP_BASE_URL || ""}/connection-failed?error=${query.error || "unknown"}`;
    },
    {
      query: t.Object({
        connection_id: t.Optional(t.String()),
        status: t.Optional(t.String()),
        error: t.Optional(t.String()),
      }),
    }
  )

  /**
   * Check connection status for a user
   *
   * GET /api/ingestion/status/:userId
   *
   * Returns which Google services are connected for the user.
   */
  .get(
    "/status/:userId",
    async ({ params, set }) => {
      const { userId } = params;

      try {
        const composio = getComposioClient();
        const entity = composio.getEntity(userId);

        // Check connection status for each Google service
        const connections = await Promise.all(
          Object.entries(GOOGLE_INTEGRATIONS).map(async ([service, integration]) => {
            try {
              const connection = await entity.getConnection({ app: integration });
              return {
                service,
                connected: connection?.status === "ACTIVE",
                connectionId: connection?.id,
              };
            } catch {
              return {
                service,
                connected: false,
                connectionId: null,
              };
            }
          })
        );

        // Also get sync state for connected services
        const syncStateService = getSyncStateService();
        const syncStates = await Promise.all(
          connections
            .filter((c) => c.connected)
            .map(async (c) => {
              const source = `google_${c.service}` as SyncSource;
              const state = await syncStateService.getState(userId, source);
              return {
                service: c.service,
                lastSync: state?.last_successful_sync_at,
                status: state?.status || "never_synced",
                itemsSynced: state?.items_synced || 0,
              };
            })
        );

        return {
          userId,
          connections,
          syncStatus: syncStates,
        };
      } catch (error) {
        set.status = 500;
        return {
          error: "Failed to get connection status",
          details: error instanceof Error ? error.message : String(error),
        };
      }
    },
    {
      params: t.Object({
        userId: t.String({ minLength: 1 }),
      }),
    }
  )

  /**
   * Disconnect a Google service
   *
   * DELETE /api/ingestion/disconnect
   *
   * Removes OAuth connection for a specific service.
   */
  .delete(
    "/disconnect",
    async ({ body, set }) => {
      const { service, userId } = body;

      const integration = GOOGLE_INTEGRATIONS[service];
      if (!integration) {
        set.status = 400;
        return {
          error: "Invalid service",
          validServices: Object.keys(GOOGLE_INTEGRATIONS),
        };
      }

      try {
        const composio = getComposioClient();
        const entity = composio.getEntity(userId);

        // Get and delete the connection
        const connection = await entity.getConnection({ app: integration });
        if (connection) {
          await composio.connectedAccounts.delete({ connectedAccountId: connection.id });
        }

        return {
          success: true,
          message: `${service} disconnected successfully`,
        };
      } catch (error) {
        set.status = 500;
        return {
          error: "Failed to disconnect service",
          details: error instanceof Error ? error.message : String(error),
        };
      }
    },
    {
      body: t.Object({
        service: t.Union([
          t.Literal("calendar"),
          t.Literal("tasks"),
          t.Literal("gmail"),
          t.Literal("contacts"),
        ]),
        userId: t.String({ minLength: 1 }),
      }),
    }
  );
```
  </action>
  <verify>
File exists at apps/omnii_mcp/src/routes/ingestion/index.ts.
TypeScript compiles: `cd apps/omnii_mcp && bunx tsc --noEmit src/routes/ingestion/index.ts`
  </verify>
  <done>Ingestion routes provide OAuth connect, callback, status, and disconnect endpoints</done>
</task>

<task type="auto">
  <name>Task 2: Mount ingestion routes in app</name>
  <files>apps/omnii_mcp/src/app.ts</files>
  <action>
Update the main Elysia app to mount ingestion routes.

In `apps/omnii_mcp/src/app.ts`:

1. Add import at top of file:
```typescript
import { ingestionRoutes } from "./routes/ingestion";
```

2. Mount the routes under /api prefix. Find where other routes are registered (look for `.use()` calls with route imports) and add:
```typescript
.use(ingestionRoutes)
```

The routes will be available at /api/ingestion/* due to the prefix in the Elysia constructor.

Note: Check existing route registration pattern in the file to match the style.
  </action>
  <verify>
TypeScript compiles: `cd apps/omnii_mcp && bunx tsc --noEmit src/app.ts`
Grep for ingestionRoutes in app.ts confirms import and use.
  </verify>
  <done>Ingestion routes mounted at /api/ingestion in main app</done>
</task>

</tasks>

<verification>
1. Routes compile: `cd apps/omnii_mcp && bunx tsc --noEmit src/routes/ingestion/index.ts`
2. App compiles with routes: `cd apps/omnii_mcp && bunx tsc --noEmit src/app.ts`
3. Routes are registered: grep for "ingestionRoutes" in app.ts
</verification>

<success_criteria>
- POST /api/ingestion/connect initiates OAuth with Composio
- GET /api/ingestion/callback handles OAuth redirect
- GET /api/ingestion/status/:userId returns connection state
- DELETE /api/ingestion/disconnect removes connection
- Routes properly integrated with Composio client
- All endpoints type-safe with Elysia validation
</success_criteria>

<output>
After completion, create `.planning/phases/04-data-ingestion-pipeline/04-04-SUMMARY.md`
</output>
