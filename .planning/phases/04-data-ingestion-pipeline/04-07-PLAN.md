---
phase: 04-data-ingestion-pipeline
plan: 07
type: execute
wave: 5
depends_on: ["04-06"]
files_modified:
  - apps/omnii_mcp/src/ingestion/sources/google-tasks.ts
  - apps/omnii_mcp/src/ingestion/sources/google-gmail.ts
  - apps/omnii_mcp/src/ingestion/sources/google-contacts.ts
  - apps/omnii_mcp/src/ingestion/sources/index.ts
  - apps/omnii_mcp/src/ingestion/jobs/workers.ts
  - apps/omnii_mcp/src/routes/ingestion/index.ts
autonomous: true

must_haves:
  truths:
    - "Google Tasks sync to graph with task list organization"
    - "Gmail messages sync to graph with sender/recipient extraction"
    - "Google Contacts sync to graph with relationship inference"
    - "All sources use incremental sync (not full refresh)"
    - "Manual sync endpoints available for each source"
  artifacts:
    - path: "apps/omnii_mcp/src/ingestion/sources/google-tasks.ts"
      provides: "Tasks ingestion with updatedMin filtering"
      exports: ["TasksIngestionService", "ingestTasks"]
    - path: "apps/omnii_mcp/src/ingestion/sources/google-gmail.ts"
      provides: "Gmail ingestion with historyId-based sync"
      exports: ["GmailIngestionService", "ingestGmail"]
    - path: "apps/omnii_mcp/src/ingestion/sources/google-contacts.ts"
      provides: "Contacts ingestion with syncToken"
      exports: ["ContactsIngestionService", "ingestContacts"]
  key_links:
    - from: "apps/omnii_mcp/src/ingestion/jobs/workers.ts"
      to: "apps/omnii_mcp/src/ingestion/sources/*.ts"
      via: "Dynamic import based on source type"
      pattern: "ingestTasks|ingestGmail|ingestContacts"
---

<objective>
Implement remaining Google service ingestion: Tasks, Gmail, and Contacts

Purpose: Complete the data ingestion pipeline with all four Google services for comprehensive personal context
Output: Three additional ingestion services following the established Calendar pattern
</objective>

<execution_context>
@/Users/santino/.claude/get-shit-done/workflows/execute-plan.md
@/Users/santino/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-data-ingestion-pipeline/04-RESEARCH.md
@apps/omnii_mcp/src/ingestion/sources/google-calendar.ts
@apps/omnii_mcp/src/ingestion/validators/schemas.ts
@apps/omnii_mcp/src/graph/schema/nodes.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Google Tasks ingestion service</name>
  <files>apps/omnii_mcp/src/ingestion/sources/google-tasks.ts</files>
  <action>
Create Tasks ingestion service following the Calendar pattern but using updatedMin for incremental sync.

Create `apps/omnii_mcp/src/ingestion/sources/google-tasks.ts`:

```typescript
/**
 * Google Tasks Ingestion Service
 *
 * Syncs Google Tasks to the knowledge graph with:
 * - Incremental sync using updatedMin timestamp
 * - Quality gate validation with GoogleTaskSchema
 * - Task stored as Entity nodes with entity_type='task'
 */

import { backOff } from "exponential-backoff";
import { getComposioClient } from "../composio-client";
import { getSyncStateService, type SyncSource } from "../sync-state";
import { GoogleTaskSchema, GoogleTaskListSchema, type GoogleTask, validateIngestionData } from "../validators";
import { createNode, createRelationship } from "../../graph/operations/crud";
import { NodeLabel, type EntityNode } from "../../graph/schema/nodes";
import { RelationshipType } from "../../graph/schema/relationships";
import type { Neo4jHTTPClient } from "../../services/neo4j/http-client";

const SYNC_SOURCE: SyncSource = "google_tasks";

export interface TasksSyncResult {
  success: boolean;
  tasksProcessed: number;
  tasksCreated: number;
  tasksSkipped: number;
  errors: string[];
  nextUpdatedMin?: string;
}

export class TasksIngestionService {
  private composio = getComposioClient();
  private syncStateService = getSyncStateService();

  async syncTasks(
    userId: string,
    client: Neo4jHTTPClient,
    forceFullSync: boolean = false
  ): Promise<TasksSyncResult> {
    const result: TasksSyncResult = {
      success: false,
      tasksProcessed: 0,
      tasksCreated: 0,
      tasksSkipped: 0,
      errors: [],
    };

    try {
      await this.syncStateService.markSyncStarted(userId, SYNC_SOURCE);

      const syncState = await this.syncStateService.getState(userId, SYNC_SOURCE);
      const updatedMin = forceFullSync ? null : syncState?.updated_min;

      // First, get all task lists
      const taskLists = await this.fetchTaskLists(userId);

      // Then fetch tasks from each list
      for (const list of taskLists) {
        const listValidation = validateIngestionData(GoogleTaskListSchema, list, "tasklist");
        if (!listValidation.success) {
          result.errors.push(...listValidation.errors);
          continue;
        }

        const tasks = await this.fetchTasks(userId, listValidation.data.id, updatedMin);

        for (const rawTask of tasks) {
          result.tasksProcessed++;

          const validation = validateIngestionData(GoogleTaskSchema, rawTask, "task");
          if (!validation.success) {
            result.errors.push(...validation.errors);
            result.tasksSkipped++;
            continue;
          }

          const task = validation.data;

          // Skip completed tasks older than 30 days
          if (task.status === "completed" && task.completed) {
            const completedDate = new Date(task.completed);
            const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
            if (completedDate < thirtyDaysAgo) {
              result.tasksSkipped++;
              continue;
            }
          }

          const created = await this.upsertTaskNode(userId, client, task, listValidation.data.title);
          if (created) result.tasksCreated++;
        }
      }

      // Store current timestamp for next incremental sync
      const newUpdatedMin = new Date().toISOString();
      await this.syncStateService.markSyncCompleted(userId, SYNC_SOURCE, {
        updatedMin: newUpdatedMin,
        itemsSynced: result.tasksCreated,
      });

      result.success = true;
      result.nextUpdatedMin = newUpdatedMin;

    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      await this.syncStateService.markSyncFailed(userId, SYNC_SOURCE, errorMessage);
      result.errors.push(errorMessage);
    }

    return result;
  }

  private async fetchTaskLists(userId: string): Promise<unknown[]> {
    const entity = this.composio.getEntity(userId);

    const response = await backOff(
      async () => entity.execute({
        actionName: "googletasks_list_tasklists",
        params: { maxResults: 100 },
      }),
      { numOfAttempts: 5, maxDelay: 30000, jitter: "full" }
    );

    return (response.data as { items?: unknown[] })?.items || [];
  }

  private async fetchTasks(
    userId: string,
    taskListId: string,
    updatedMin: string | null
  ): Promise<unknown[]> {
    const entity = this.composio.getEntity(userId);
    const allTasks: unknown[] = [];
    let pageToken: string | undefined;

    do {
      const response = await backOff(
        async () => entity.execute({
          actionName: "googletasks_list_tasks",
          params: {
            tasklist: taskListId,
            maxResults: 100,
            showCompleted: true,
            showHidden: true,
            ...(updatedMin ? { updatedMin } : {}),
            ...(pageToken ? { pageToken } : {}),
          },
        }),
        { numOfAttempts: 5, maxDelay: 30000, jitter: "full" }
      );

      const data = response.data as { items?: unknown[]; nextPageToken?: string };
      if (data.items) allTasks.push(...data.items);
      pageToken = data.nextPageToken;

    } while (pageToken);

    return allTasks;
  }

  private async upsertTaskNode(
    userId: string,
    client: Neo4jHTTPClient,
    task: GoogleTask,
    listTitle: string
  ): Promise<boolean> {
    // Check if task exists
    const existing = await this.findTaskByGoogleId(client, task.id);
    if (existing) return false;

    // Store tasks as Entity nodes with entity_type='task'
    await createNode<EntityNode>(client, NodeLabel.Entity, {
      name: task.title,
      type: "thing", // EntityType
      properties: {
        entity_type: "task",
        google_task_id: task.id,
        source: "google_tasks",
        list_name: listTitle,
        status: task.status,
        due: task.due,
        notes: task.notes,
        completed: task.completed,
      },
    } as Omit<EntityNode, "id" | "createdAt">);

    return true;
  }

  private async findTaskByGoogleId(
    client: Neo4jHTTPClient,
    googleTaskId: string
  ): Promise<EntityNode | null> {
    const cypher = `
      MATCH (e:Entity)
      WHERE e.properties.google_task_id = $googleTaskId
      RETURN properties(e) AS props
      LIMIT 1
    `;
    const result = await client.query(cypher, { googleTaskId });
    return result.data?.values?.[0]?.[0] as EntityNode | null;
  }
}

let _tasksService: TasksIngestionService | null = null;

export function getTasksIngestionService(): TasksIngestionService {
  if (!_tasksService) _tasksService = new TasksIngestionService();
  return _tasksService;
}

export async function ingestTasks(
  userId: string,
  client: Neo4jHTTPClient,
  forceFullSync: boolean = false
): Promise<TasksSyncResult> {
  return getTasksIngestionService().syncTasks(userId, client, forceFullSync);
}
```
  </action>
  <verify>
File exists at apps/omnii_mcp/src/ingestion/sources/google-tasks.ts.
TypeScript compiles: `cd apps/omnii_mcp && bunx tsc --noEmit src/ingestion/sources/google-tasks.ts`
  </verify>
  <done>Tasks ingestion service created with updatedMin incremental sync</done>
</task>

<task type="auto">
  <name>Task 2: Create Gmail and Contacts ingestion services</name>
  <files>apps/omnii_mcp/src/ingestion/sources/google-gmail.ts, apps/omnii_mcp/src/ingestion/sources/google-contacts.ts</files>
  <action>
Create Gmail ingestion (historyId-based) and Contacts ingestion (syncToken-based).

1. Create `apps/omnii_mcp/src/ingestion/sources/google-gmail.ts`:

```typescript
/**
 * Gmail Ingestion Service
 *
 * Syncs Gmail messages to the knowledge graph with:
 * - Incremental sync using historyId
 * - Quality gate validation with GmailMessageSchema
 * - Sender/recipient extraction as Contact nodes
 */

import { backOff } from "exponential-backoff";
import { getComposioClient } from "../composio-client";
import { getSyncStateService, type SyncSource } from "../sync-state";
import { GmailMessageSchema, type GmailMessage, validateIngestionData } from "../validators";
import { createNode, createRelationship } from "../../graph/operations/crud";
import { NodeLabel, type EntityNode, type ContactNode } from "../../graph/schema/nodes";
import { RelationshipType } from "../../graph/schema/relationships";
import type { Neo4jHTTPClient } from "../../services/neo4j/http-client";

const SYNC_SOURCE: SyncSource = "google_gmail";

export interface GmailSyncResult {
  success: boolean;
  messagesProcessed: number;
  messagesCreated: number;
  messagesSkipped: number;
  contactsCreated: number;
  errors: string[];
  latestHistoryId?: string;
}

export class GmailIngestionService {
  private composio = getComposioClient();
  private syncStateService = getSyncStateService();

  async syncMessages(
    userId: string,
    client: Neo4jHTTPClient,
    forceFullSync: boolean = false
  ): Promise<GmailSyncResult> {
    const result: GmailSyncResult = {
      success: false,
      messagesProcessed: 0,
      messagesCreated: 0,
      messagesSkipped: 0,
      contactsCreated: 0,
      errors: [],
    };

    try {
      await this.syncStateService.markSyncStarted(userId, SYNC_SOURCE);

      const syncState = await this.syncStateService.getState(userId, SYNC_SOURCE);
      const historyId = forceFullSync ? null : syncState?.history_id;

      let messages: unknown[];
      let latestHistoryId: string | undefined;

      if (historyId) {
        // Incremental sync using history
        const historyResult = await this.fetchHistory(userId, historyId);
        messages = historyResult.messages;
        latestHistoryId = historyResult.latestHistoryId;

        // Handle 404 - historyId expired (>1 week old)
        if (!messages.length && !latestHistoryId) {
          await this.syncStateService.clearSyncToken(userId, SYNC_SOURCE);
          return this.syncMessages(userId, client, true);
        }
      } else {
        // Full sync - get recent messages (last 90 days)
        const fullResult = await this.fetchRecentMessages(userId);
        messages = fullResult.messages;
        latestHistoryId = fullResult.latestHistoryId;
      }

      for (const rawMessage of messages) {
        result.messagesProcessed++;

        const validation = validateIngestionData(GmailMessageSchema, rawMessage, "gmail");
        if (!validation.success) {
          result.errors.push(...validation.errors);
          result.messagesSkipped++;
          continue;
        }

        const message = validation.data;
        const created = await this.upsertMessageNode(userId, client, message);
        if (created) {
          result.messagesCreated++;
          const contacts = await this.extractEmailContacts(userId, client, message);
          result.contactsCreated += contacts;
        }
      }

      await this.syncStateService.markSyncCompleted(userId, SYNC_SOURCE, {
        historyId: latestHistoryId,
        itemsSynced: result.messagesCreated,
      });

      result.success = true;
      result.latestHistoryId = latestHistoryId;

    } catch (error) {
      // Handle 404 - historyId outside available range
      if (this.is404Error(error)) {
        await this.syncStateService.clearSyncToken(userId, SYNC_SOURCE);
        return this.syncMessages(userId, client, true);
      }

      const errorMessage = error instanceof Error ? error.message : String(error);
      await this.syncStateService.markSyncFailed(userId, SYNC_SOURCE, errorMessage);
      result.errors.push(errorMessage);
    }

    return result;
  }

  private async fetchHistory(
    userId: string,
    startHistoryId: string
  ): Promise<{ messages: unknown[]; latestHistoryId?: string }> {
    const entity = this.composio.getEntity(userId);

    const response = await backOff(
      async () => entity.execute({
        actionName: "gmail_list_history",
        params: {
          userId: "me",
          startHistoryId,
          historyTypes: ["messageAdded"],
        },
      }),
      { numOfAttempts: 5, maxDelay: 30000, jitter: "full" }
    );

    const data = response.data as { history?: { messagesAdded?: { message: unknown }[] }[]; historyId?: string };
    const messages = data.history?.flatMap((h) =>
      h.messagesAdded?.map((m) => m.message) || []
    ) || [];

    return { messages, latestHistoryId: data.historyId };
  }

  private async fetchRecentMessages(
    userId: string
  ): Promise<{ messages: unknown[]; latestHistoryId?: string }> {
    const entity = this.composio.getEntity(userId);
    const allMessages: unknown[] = [];
    let pageToken: string | undefined;
    let latestHistoryId: string | undefined;

    // Fetch message list (IDs only)
    do {
      const response = await backOff(
        async () => entity.execute({
          actionName: "gmail_list_messages",
          params: {
            userId: "me",
            maxResults: 100,
            q: "newer_than:90d", // Last 90 days
            ...(pageToken ? { pageToken } : {}),
          },
        }),
        { numOfAttempts: 5, maxDelay: 30000, jitter: "full" }
      );

      const data = response.data as { messages?: { id: string; historyId?: string }[]; nextPageToken?: string };
      if (data.messages) {
        // Get first message's historyId for tracking
        if (!latestHistoryId && data.messages[0]?.historyId) {
          latestHistoryId = data.messages[0].historyId;
        }

        // Fetch full message details in batches
        for (const msg of data.messages) {
          const fullMsg = await this.fetchMessageDetails(userId, msg.id);
          if (fullMsg) allMessages.push(fullMsg);
        }
      }
      pageToken = data.nextPageToken;

      // Limit to 500 messages for initial sync
      if (allMessages.length >= 500) break;

    } while (pageToken);

    return { messages: allMessages, latestHistoryId };
  }

  private async fetchMessageDetails(userId: string, messageId: string): Promise<unknown> {
    const entity = this.composio.getEntity(userId);

    const response = await backOff(
      async () => entity.execute({
        actionName: "gmail_get_message",
        params: { userId: "me", id: messageId, format: "metadata" },
      }),
      { numOfAttempts: 3, maxDelay: 10000, jitter: "full" }
    );

    return response.data;
  }

  private async upsertMessageNode(
    userId: string,
    client: Neo4jHTTPClient,
    message: GmailMessage
  ): Promise<boolean> {
    const existing = await this.findMessageByGmailId(client, message.id);
    if (existing) return false;

    // Extract subject from headers
    const subject = message.payload?.headers?.find((h) => h.name.toLowerCase() === "subject")?.value || "No Subject";

    await createNode<EntityNode>(client, NodeLabel.Entity, {
      name: subject,
      type: "thing",
      properties: {
        entity_type: "email",
        gmail_message_id: message.id,
        gmail_thread_id: message.threadId,
        source: "google_gmail",
        snippet: message.snippet,
        labels: message.labelIds,
        internal_date: message.internalDate,
      },
    } as Omit<EntityNode, "id" | "createdAt">);

    return true;
  }

  private async findMessageByGmailId(client: Neo4jHTTPClient, gmailId: string): Promise<EntityNode | null> {
    const cypher = `
      MATCH (e:Entity)
      WHERE e.properties.gmail_message_id = $gmailId
      RETURN properties(e) AS props
      LIMIT 1
    `;
    const result = await client.query(cypher, { gmailId });
    return result.data?.values?.[0]?.[0] as EntityNode | null;
  }

  private async extractEmailContacts(
    userId: string,
    client: Neo4jHTTPClient,
    message: GmailMessage
  ): Promise<number> {
    let created = 0;
    const headers = message.payload?.headers || [];

    for (const header of headers) {
      if (["from", "to", "cc"].includes(header.name.toLowerCase())) {
        const emails = this.parseEmailAddresses(header.value);
        for (const { email, name } of emails) {
          const contactCreated = await this.ensureContact(client, email, name);
          if (contactCreated) created++;
        }
      }
    }

    return created;
  }

  private parseEmailAddresses(value: string): { email: string; name?: string }[] {
    const results: { email: string; name?: string }[] = [];
    const regex = /(?:"?([^"<]+)"?\s*)?<([^>]+)>|([^\s,]+@[^\s,]+)/g;
    let match;

    while ((match = regex.exec(value)) !== null) {
      const name = match[1]?.trim();
      const email = (match[2] || match[3])?.toLowerCase();
      if (email) results.push({ email, name });
    }

    return results;
  }

  private async ensureContact(client: Neo4jHTTPClient, email: string, name?: string): Promise<boolean> {
    const cypher = `
      MATCH (c:Contact {email: $email})
      RETURN properties(c) AS props
      LIMIT 1
    `;
    const result = await client.query(cypher, { email });
    if (result.data?.values?.length) return false;

    await createNode<ContactNode>(client, NodeLabel.Contact, {
      name: name || email.split("@")[0],
      email,
    } as Omit<ContactNode, "id" | "createdAt">);

    return true;
  }

  private is404Error(error: unknown): boolean {
    return (error as { response?: { status?: number } })?.response?.status === 404;
  }
}

let _gmailService: GmailIngestionService | null = null;

export function getGmailIngestionService(): GmailIngestionService {
  if (!_gmailService) _gmailService = new GmailIngestionService();
  return _gmailService;
}

export async function ingestGmail(
  userId: string,
  client: Neo4jHTTPClient,
  forceFullSync: boolean = false
): Promise<GmailSyncResult> {
  return getGmailIngestionService().syncMessages(userId, client, forceFullSync);
}
```

2. Create `apps/omnii_mcp/src/ingestion/sources/google-contacts.ts`:

```typescript
/**
 * Google Contacts Ingestion Service
 *
 * Syncs Google Contacts to the knowledge graph with:
 * - Incremental sync using syncToken
 * - Quality gate validation with GoogleContactSchema
 * - 410 error handling for expired sync tokens
 */

import { backOff } from "exponential-backoff";
import { getComposioClient } from "../composio-client";
import { getSyncStateService, type SyncSource } from "../sync-state";
import { GoogleContactSchema, type GoogleContact, validateIngestionData } from "../validators";
import { createNode, updateNode } from "../../graph/operations/crud";
import { NodeLabel, type ContactNode } from "../../graph/schema/nodes";
import type { Neo4jHTTPClient } from "../../services/neo4j/http-client";

const SYNC_SOURCE: SyncSource = "google_contacts";

export interface ContactsSyncResult {
  success: boolean;
  contactsProcessed: number;
  contactsCreated: number;
  contactsUpdated: number;
  contactsSkipped: number;
  errors: string[];
  nextSyncToken?: string;
}

export class ContactsIngestionService {
  private composio = getComposioClient();
  private syncStateService = getSyncStateService();

  async syncContacts(
    userId: string,
    client: Neo4jHTTPClient,
    forceFullSync: boolean = false
  ): Promise<ContactsSyncResult> {
    const result: ContactsSyncResult = {
      success: false,
      contactsProcessed: 0,
      contactsCreated: 0,
      contactsUpdated: 0,
      contactsSkipped: 0,
      errors: [],
    };

    try {
      await this.syncStateService.markSyncStarted(userId, SYNC_SOURCE);

      const syncState = await this.syncStateService.getState(userId, SYNC_SOURCE);
      const syncToken = forceFullSync ? null : syncState?.sync_token;

      const { contacts, nextSyncToken } = await this.fetchContacts(userId, syncToken);

      for (const rawContact of contacts) {
        result.contactsProcessed++;

        const validation = validateIngestionData(GoogleContactSchema, rawContact, "contact");
        if (!validation.success) {
          result.errors.push(...validation.errors);
          result.contactsSkipped++;
          continue;
        }

        const contact = validation.data;
        const { created, updated } = await this.upsertContactNode(userId, client, contact);
        if (created) result.contactsCreated++;
        if (updated) result.contactsUpdated++;
      }

      await this.syncStateService.markSyncCompleted(userId, SYNC_SOURCE, {
        syncToken: nextSyncToken,
        itemsSynced: result.contactsCreated + result.contactsUpdated,
      });

      result.success = true;
      result.nextSyncToken = nextSyncToken;

    } catch (error) {
      // Handle 410 Gone - sync token expired
      if (this.is410Error(error)) {
        await this.syncStateService.clearSyncToken(userId, SYNC_SOURCE);
        return this.syncContacts(userId, client, true);
      }

      const errorMessage = error instanceof Error ? error.message : String(error);
      await this.syncStateService.markSyncFailed(userId, SYNC_SOURCE, errorMessage);
      result.errors.push(errorMessage);
    }

    return result;
  }

  private async fetchContacts(
    userId: string,
    syncToken: string | null
  ): Promise<{ contacts: unknown[]; nextSyncToken?: string }> {
    const entity = this.composio.getEntity(userId);
    const allContacts: unknown[] = [];
    let pageToken: string | undefined;
    let nextSyncToken: string | undefined;

    do {
      const response = await backOff(
        async () => entity.execute({
          actionName: "googlecontacts_list_connections",
          params: {
            resourceName: "people/me",
            personFields: "names,emailAddresses,phoneNumbers,organizations,photos,birthdays",
            pageSize: 100,
            ...(syncToken ? { syncToken, requestSyncToken: true } : { requestSyncToken: true }),
            ...(pageToken ? { pageToken } : {}),
          },
        }),
        { numOfAttempts: 5, maxDelay: 30000, jitter: "full" }
      );

      const data = response.data as {
        connections?: unknown[];
        nextPageToken?: string;
        nextSyncToken?: string;
      };

      if (data.connections) allContacts.push(...data.connections);
      pageToken = data.nextPageToken;
      nextSyncToken = data.nextSyncToken;

    } while (pageToken);

    return { contacts: allContacts, nextSyncToken };
  }

  private async upsertContactNode(
    userId: string,
    client: Neo4jHTTPClient,
    contact: GoogleContact
  ): Promise<{ created: boolean; updated: boolean }> {
    const primaryEmail = contact.emailAddresses?.[0]?.value?.toLowerCase();
    const primaryName = contact.names?.[0];

    // Try to find existing contact by Google resource name or email
    const existing = await this.findContact(client, contact.resourceName, primaryEmail);

    const contactData = {
      name: primaryName?.displayName ||
            `${primaryName?.givenName || ""} ${primaryName?.familyName || ""}`.trim() ||
            primaryEmail ||
            "Unknown Contact",
      email: primaryEmail,
      phone: contact.phoneNumbers?.[0]?.value,
      organization: contact.organizations?.[0]?.name,
    };

    if (existing) {
      await updateNode<ContactNode>(client, existing.id, contactData);
      return { created: false, updated: true };
    }

    await createNode<ContactNode>(client, NodeLabel.Contact, {
      ...contactData,
      properties: {
        google_resource_name: contact.resourceName,
        source: "google_contacts",
      },
    } as Omit<ContactNode, "id" | "createdAt">);

    return { created: true, updated: false };
  }

  private async findContact(
    client: Neo4jHTTPClient,
    resourceName: string,
    email?: string
  ): Promise<ContactNode | null> {
    // First try by Google resource name
    let cypher = `
      MATCH (c:Contact)
      WHERE c.properties.google_resource_name = $resourceName
      RETURN properties(c) AS props, c.id AS id
      LIMIT 1
    `;
    let result = await client.query(cypher, { resourceName });

    if (result.data?.values?.length) {
      const props = result.data.values[0][0] as ContactNode;
      return { ...props, id: result.data.values[0][1] as string };
    }

    // Fallback to email match
    if (email) {
      cypher = `
        MATCH (c:Contact {email: $email})
        RETURN properties(c) AS props, c.id AS id
        LIMIT 1
      `;
      result = await client.query(cypher, { email });

      if (result.data?.values?.length) {
        const props = result.data.values[0][0] as ContactNode;
        return { ...props, id: result.data.values[0][1] as string };
      }
    }

    return null;
  }

  private is410Error(error: unknown): boolean {
    return (error as { response?: { status?: number } })?.response?.status === 410;
  }
}

let _contactsService: ContactsIngestionService | null = null;

export function getContactsIngestionService(): ContactsIngestionService {
  if (!_contactsService) _contactsService = new ContactsIngestionService();
  return _contactsService;
}

export async function ingestContacts(
  userId: string,
  client: Neo4jHTTPClient,
  forceFullSync: boolean = false
): Promise<ContactsSyncResult> {
  return getContactsIngestionService().syncContacts(userId, client, forceFullSync);
}
```
  </action>
  <verify>
Both files exist and compile.
Gmail: `cd apps/omnii_mcp && bunx tsc --noEmit src/ingestion/sources/google-gmail.ts`
Contacts: `cd apps/omnii_mcp && bunx tsc --noEmit src/ingestion/sources/google-contacts.ts`
  </verify>
  <done>Gmail and Contacts ingestion services created with incremental sync</done>
</task>

<task type="auto">
  <name>Task 3: Update sources index, workers, and routes</name>
  <files>apps/omnii_mcp/src/ingestion/sources/index.ts, apps/omnii_mcp/src/ingestion/jobs/workers.ts, apps/omnii_mcp/src/routes/ingestion/index.ts</files>
  <action>
Update exports, workers, and routes to include all sources.

1. Update `apps/omnii_mcp/src/ingestion/sources/index.ts`:

```typescript
/**
 * Ingestion Sources
 *
 * Per-source data ingestion services.
 */

// Calendar
export {
  CalendarIngestionService,
  getCalendarIngestionService,
  ingestCalendarEvents,
  type CalendarSyncResult,
} from "./google-calendar";

// Tasks
export {
  TasksIngestionService,
  getTasksIngestionService,
  ingestTasks,
  type TasksSyncResult,
} from "./google-tasks";

// Gmail
export {
  GmailIngestionService,
  getGmailIngestionService,
  ingestGmail,
  type GmailSyncResult,
} from "./google-gmail";

// Contacts
export {
  ContactsIngestionService,
  getContactsIngestionService,
  ingestContacts,
  type ContactsSyncResult,
} from "./google-contacts";
```

2. Update workers in `apps/omnii_mcp/src/ingestion/jobs/workers.ts` to handle all sources. Update the switch statement in processSyncJob:

```typescript
switch (source) {
  case "google_calendar":
    result = await ingestCalendarEvents(userId, client);
    break;

  case "google_tasks": {
    const { ingestTasks } = await import("../sources/google-tasks");
    const taskResult = await ingestTasks(userId, client);
    result = {
      success: taskResult.success,
      eventsProcessed: taskResult.tasksProcessed,
      eventsCreated: taskResult.tasksCreated,
      eventsSkipped: taskResult.tasksSkipped,
      contactsCreated: 0,
      errors: taskResult.errors,
    };
    break;
  }

  case "google_gmail": {
    const { ingestGmail } = await import("../sources/google-gmail");
    const gmailResult = await ingestGmail(userId, client);
    result = {
      success: gmailResult.success,
      eventsProcessed: gmailResult.messagesProcessed,
      eventsCreated: gmailResult.messagesCreated,
      eventsSkipped: gmailResult.messagesSkipped,
      contactsCreated: gmailResult.contactsCreated,
      errors: gmailResult.errors,
    };
    break;
  }

  case "google_contacts": {
    const { ingestContacts } = await import("../sources/google-contacts");
    const contactResult = await ingestContacts(userId, client);
    result = {
      success: contactResult.success,
      eventsProcessed: contactResult.contactsProcessed,
      eventsCreated: contactResult.contactsCreated,
      eventsSkipped: contactResult.contactsSkipped,
      contactsCreated: 0,
      errors: contactResult.errors,
    };
    break;
  }

  default:
    throw new Error(`Unsupported sync source: ${source}`);
}
```

3. Add sync endpoints for tasks, gmail, contacts in `apps/omnii_mcp/src/routes/ingestion/index.ts`:

```typescript
  .post(
    "/sync/tasks",
    async ({ body, set }) => {
      const { userId, forceFullSync } = body;
      try {
        const { ingestTasks } = await import("../../ingestion/sources/google-tasks");
        const { createClientForUser } = await import("../../services/neo4j/http-client");
        const client = await createClientForUser(userId);
        if (!client) {
          set.status = 400;
          return { error: "User database not provisioned" };
        }
        return await ingestTasks(userId, client, forceFullSync || false);
      } catch (error) {
        set.status = 500;
        return { error: "Sync failed", details: error instanceof Error ? error.message : String(error) };
      }
    },
    { body: t.Object({ userId: t.String({ minLength: 1 }), forceFullSync: t.Optional(t.Boolean()) }) }
  )

  .post(
    "/sync/gmail",
    async ({ body, set }) => {
      const { userId, forceFullSync } = body;
      try {
        const { ingestGmail } = await import("../../ingestion/sources/google-gmail");
        const { createClientForUser } = await import("../../services/neo4j/http-client");
        const client = await createClientForUser(userId);
        if (!client) {
          set.status = 400;
          return { error: "User database not provisioned" };
        }
        return await ingestGmail(userId, client, forceFullSync || false);
      } catch (error) {
        set.status = 500;
        return { error: "Sync failed", details: error instanceof Error ? error.message : String(error) };
      }
    },
    { body: t.Object({ userId: t.String({ minLength: 1 }), forceFullSync: t.Optional(t.Boolean()) }) }
  )

  .post(
    "/sync/contacts",
    async ({ body, set }) => {
      const { userId, forceFullSync } = body;
      try {
        const { ingestContacts } = await import("../../ingestion/sources/google-contacts");
        const { createClientForUser } = await import("../../services/neo4j/http-client");
        const client = await createClientForUser(userId);
        if (!client) {
          set.status = 400;
          return { error: "User database not provisioned" };
        }
        return await ingestContacts(userId, client, forceFullSync || false);
      } catch (error) {
        set.status = 500;
        return { error: "Sync failed", details: error instanceof Error ? error.message : String(error) };
      }
    },
    { body: t.Object({ userId: t.String({ minLength: 1 }), forceFullSync: t.Optional(t.Boolean()) }) }
  )
```
  </action>
  <verify>
All files compile:
- Sources index: `cd apps/omnii_mcp && bunx tsc --noEmit src/ingestion/sources/index.ts`
- Workers: `cd apps/omnii_mcp && bunx tsc --noEmit src/ingestion/jobs/workers.ts`
- Routes: `cd apps/omnii_mcp && bunx tsc --noEmit src/routes/ingestion/index.ts`
  </verify>
  <done>All sources exported, workers handle all sources, manual sync endpoints for all services</done>
</task>

</tasks>

<verification>
1. All source files compile individually
2. Sources index exports all services
3. Workers can process all source types
4. Routes provide sync endpoints for all 4 services
</verification>

<success_criteria>
- Tasks ingestion uses updatedMin for incremental sync
- Gmail ingestion uses historyId with 404 fallback to full sync
- Contacts ingestion uses syncToken with 410 fallback to full sync
- All sources validated against schemas before insertion
- Workers handle all source types in switch statement
- Manual sync endpoints available for testing each source
- All files compile without TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/04-data-ingestion-pipeline/04-07-SUMMARY.md`
</output>
