---
phase: 04-data-ingestion-pipeline
plan: 05
type: execute
wave: 3
depends_on: ["04-02", "04-03", "04-04"]
files_modified:
  - apps/omnii_mcp/src/ingestion/sources/google-calendar.ts
  - apps/omnii_mcp/src/ingestion/sources/index.ts
  - apps/omnii_mcp/src/routes/ingestion/index.ts
autonomous: true

must_haves:
  truths:
    - "Calendar events are fetched from Google via Composio"
    - "Events are validated against CalendarEventSchema before graph insertion"
    - "Valid events are inserted as Event nodes in Neo4j"
    - "Sync token is stored for incremental sync on next run"
    - "410 errors trigger full sync by clearing sync token"
    - "Attendees are extracted as Contact nodes with relationships"
  artifacts:
    - path: "apps/omnii_mcp/src/ingestion/sources/google-calendar.ts"
      provides: "Calendar ingestion service with incremental sync"
      exports: ["CalendarIngestionService", "ingestCalendarEvents"]
    - path: "apps/omnii_mcp/src/ingestion/sources/index.ts"
      provides: "Barrel export for ingestion sources"
  key_links:
    - from: "apps/omnii_mcp/src/ingestion/sources/google-calendar.ts"
      to: "apps/omnii_mcp/src/ingestion/validators/schemas.ts"
      via: "CalendarEventSchema import"
      pattern: "CalendarEventSchema"
    - from: "apps/omnii_mcp/src/ingestion/sources/google-calendar.ts"
      to: "apps/omnii_mcp/src/graph/operations/crud.ts"
      via: "createNode import"
      pattern: "createNode"
    - from: "apps/omnii_mcp/src/ingestion/sources/google-calendar.ts"
      to: "apps/omnii_mcp/src/ingestion/sync-state.ts"
      via: "getSyncStateService import"
      pattern: "getSyncStateService"
---

<objective>
Implement Google Calendar ingestion service with incremental sync and quality gates

Purpose: Sync calendar events to knowledge graph, enabling AI to answer "What meetings do I have?" queries with real data
Output: CalendarIngestionService that fetches events via Composio, validates, and inserts into Neo4j as Event nodes
</objective>

<execution_context>
@/Users/santino/.claude/get-shit-done/workflows/execute-plan.md
@/Users/santino/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-data-ingestion-pipeline/04-RESEARCH.md
@apps/omnii_mcp/src/graph/schema/nodes.ts
@apps/omnii_mcp/src/graph/operations/crud.ts
@apps/omnii_mcp/src/ingestion/composio-client.ts
@apps/omnii_mcp/src/ingestion/sync-state.ts
@apps/omnii_mcp/src/ingestion/validators/schemas.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CalendarIngestionService</name>
  <files>apps/omnii_mcp/src/ingestion/sources/google-calendar.ts</files>
  <action>
Create the Calendar ingestion service that:
1. Fetches calendar events via Composio
2. Validates each event against CalendarEventSchema
3. Inserts valid events as Event nodes in Neo4j
4. Extracts attendees as Contact nodes with ATTENDED_BY relationships
5. Handles incremental sync with sync tokens
6. Handles 410 errors by falling back to full sync

Create `apps/omnii_mcp/src/ingestion/sources/google-calendar.ts`:

```typescript
/**
 * Google Calendar Ingestion Service
 *
 * Syncs calendar events to the knowledge graph with:
 * - Incremental sync using sync tokens
 * - Quality gate validation with CalendarEventSchema
 * - Attendee extraction as Contact nodes
 * - 410 error handling with fallback to full sync
 */

import { backOff } from "exponential-backoff";
import { getComposioClient } from "../composio-client";
import { getSyncStateService, type SyncSource } from "../sync-state";
import { CalendarEventSchema, type CalendarEvent, validateIngestionData } from "../validators";
import { createNode, createRelationship, getNodesByLabel } from "../../graph/operations/crud";
import { NodeLabel, type EventNode, type ContactNode } from "../../graph/schema/nodes";
import { RelationshipType } from "../../graph/schema/relationships";
import type { Neo4jHTTPClient } from "../../services/neo4j/http-client";

const SYNC_SOURCE: SyncSource = "google_calendar";

/**
 * Result of a calendar sync operation
 */
export interface CalendarSyncResult {
  success: boolean;
  eventsProcessed: number;
  eventsCreated: number;
  eventsSkipped: number;
  contactsCreated: number;
  errors: string[];
  nextSyncToken?: string;
}

/**
 * CalendarIngestionService handles syncing Google Calendar events to Neo4j
 */
export class CalendarIngestionService {
  private composio = getComposioClient();
  private syncStateService = getSyncStateService();

  /**
   * Sync calendar events for a user
   *
   * @param userId - User ID for Composio entity and Neo4j client lookup
   * @param client - Neo4j HTTP client for the user's database
   * @param forceFullSync - Force full sync ignoring sync token
   */
  async syncEvents(
    userId: string,
    client: Neo4jHTTPClient,
    forceFullSync: boolean = false
  ): Promise<CalendarSyncResult> {
    const result: CalendarSyncResult = {
      success: false,
      eventsProcessed: 0,
      eventsCreated: 0,
      eventsSkipped: 0,
      contactsCreated: 0,
      errors: [],
    };

    try {
      // Mark sync as started
      await this.syncStateService.markSyncStarted(userId, SYNC_SOURCE);

      // Get current sync state
      const syncState = await this.syncStateService.getState(userId, SYNC_SOURCE);
      const syncToken = forceFullSync ? null : syncState?.sync_token;

      // Fetch events with incremental sync
      const { events, nextSyncToken } = await this.fetchCalendarEvents(
        userId,
        syncToken
      );

      // Process each event
      for (const rawEvent of events) {
        result.eventsProcessed++;

        // Validate against schema (quality gate)
        const validation = validateIngestionData(
          CalendarEventSchema,
          rawEvent,
          "calendar"
        );

        if (!validation.success) {
          result.errors.push(...validation.errors);
          result.eventsSkipped++;
          continue;
        }

        const event = validation.data;

        // Skip cancelled events (they're returned for sync consistency)
        if (event.status === "cancelled") {
          result.eventsSkipped++;
          continue;
        }

        // Insert or update event in graph
        const created = await this.upsertEventNode(userId, client, event);
        if (created) {
          result.eventsCreated++;
        }

        // Extract attendees as contacts
        if (event.attendees && event.attendees.length > 0) {
          const contactsCreated = await this.extractAttendees(
            userId,
            client,
            event
          );
          result.contactsCreated += contactsCreated;
        }
      }

      // Mark sync as completed
      await this.syncStateService.markSyncCompleted(userId, SYNC_SOURCE, {
        syncToken: nextSyncToken,
        itemsSynced: result.eventsCreated,
      });

      result.success = true;
      result.nextSyncToken = nextSyncToken;

    } catch (error) {
      // Handle 410 Gone - sync token expired
      if (this.is410Error(error)) {
        console.log(`Sync token expired for user ${userId}, triggering full sync`);
        await this.syncStateService.clearSyncToken(userId, SYNC_SOURCE);
        // Retry with full sync
        return this.syncEvents(userId, client, true);
      }

      // Handle rate limiting
      if (this.is429Error(error)) {
        await this.syncStateService.markRateLimited(userId, SYNC_SOURCE);
        result.errors.push("Rate limited by Google API, will retry later");
        return result;
      }

      // General error
      const errorMessage = error instanceof Error ? error.message : String(error);
      await this.syncStateService.markSyncFailed(userId, SYNC_SOURCE, errorMessage);
      result.errors.push(errorMessage);
    }

    return result;
  }

  /**
   * Fetch calendar events from Google via Composio
   */
  private async fetchCalendarEvents(
    userId: string,
    syncToken: string | null
  ): Promise<{ events: unknown[]; nextSyncToken?: string }> {
    const entity = this.composio.getEntity(userId);
    const allEvents: unknown[] = [];
    let pageToken: string | undefined;
    let nextSyncToken: string | undefined;

    do {
      const response = await backOff(
        async () => {
          // Execute Google Calendar list events action
          const result = await entity.execute({
            actionName: "googlecalendar_list_events",
            params: {
              calendarId: "primary",
              maxResults: 250,
              ...(syncToken ? { syncToken } : { timeMin: this.getTimeMin() }),
              ...(pageToken ? { pageToken } : {}),
            },
          });

          return result;
        },
        {
          numOfAttempts: 5,
          maxDelay: 30000,
          jitter: "full",
          retry: (error: unknown) => {
            // Retry on 5xx and 429, not on 4xx (except 429)
            const status = (error as { response?: { status?: number } })?.response?.status;
            if (status === 429) return true;
            if (status && status >= 500) return true;
            return false;
          },
        }
      );

      // Extract events and pagination info
      const data = result.data as {
        items?: unknown[];
        nextPageToken?: string;
        nextSyncToken?: string;
      };

      if (data.items) {
        allEvents.push(...data.items);
      }

      pageToken = data.nextPageToken;
      nextSyncToken = data.nextSyncToken;

    } while (pageToken);

    return { events: allEvents, nextSyncToken };
  }

  /**
   * Insert or update an event in the graph
   */
  private async upsertEventNode(
    userId: string,
    client: Neo4jHTTPClient,
    event: CalendarEvent
  ): Promise<boolean> {
    // Check if event already exists by Google event ID
    const existingEvents = await this.findEventByGoogleId(client, event.id);

    if (existingEvents.length > 0) {
      // Event exists - could update here if needed
      // For now, skip (incremental sync handles updates via deletion + recreation)
      return false;
    }

    // Determine start/end times
    const startTime = event.start.dateTime || `${event.start.date}T00:00:00Z`;
    const endTime = event.end?.dateTime || event.end?.date
      ? (event.end.dateTime || `${event.end.date}T23:59:59Z`)
      : undefined;

    // Create Event node
    await createNode<EventNode>(client, NodeLabel.Event, {
      name: event.summary,
      startTime,
      endTime,
      location: event.location,
      description: event.description,
      // Store Google ID for deduplication
      properties: {
        google_event_id: event.id,
        source: "google_calendar",
        recurring_event_id: event.recurringEventId,
      },
    } as Omit<EventNode, "id" | "createdAt">);

    return true;
  }

  /**
   * Find event by Google event ID
   */
  private async findEventByGoogleId(
    client: Neo4jHTTPClient,
    googleEventId: string
  ): Promise<EventNode[]> {
    const cypher = `
      MATCH (e:Event)
      WHERE e.properties.google_event_id = $googleEventId
      RETURN properties(e) AS props
    `;

    const result = await client.query(cypher, { googleEventId });

    if (!result.data?.values?.length) {
      return [];
    }

    return result.data.values.map((row) => row[0] as EventNode);
  }

  /**
   * Extract attendees and create Contact nodes with relationships
   */
  private async extractAttendees(
    userId: string,
    client: Neo4jHTTPClient,
    event: CalendarEvent
  ): Promise<number> {
    if (!event.attendees) return 0;

    let contactsCreated = 0;

    for (const attendee of event.attendees) {
      // Skip self (the user's own email)
      if (attendee.self) continue;

      // Check if contact already exists
      const existing = await this.findContactByEmail(client, attendee.email);

      let contactId: string;

      if (existing) {
        contactId = existing.id;
      } else {
        // Create new contact
        const contact = await createNode<ContactNode>(
          client,
          NodeLabel.Contact,
          {
            name: attendee.displayName || attendee.email.split("@")[0],
            email: attendee.email,
            // Organization can be inferred from email domain
            organization: this.inferOrganization(attendee.email),
          } as Omit<ContactNode, "id" | "createdAt">
        );
        contactId = contact.id;
        contactsCreated++;
      }

      // Find the event node to create relationship
      const eventNodes = await this.findEventByGoogleId(client, event.id);
      if (eventNodes.length > 0) {
        // Create ATTENDED_BY relationship (Event -> Contact)
        await createRelationship(
          client,
          eventNodes[0].id,
          contactId,
          RelationshipType.ATTENDED_BY,
          { response_status: attendee.responseStatus }
        );
      }
    }

    return contactsCreated;
  }

  /**
   * Find contact by email
   */
  private async findContactByEmail(
    client: Neo4jHTTPClient,
    email: string
  ): Promise<ContactNode | null> {
    const cypher = `
      MATCH (c:Contact {email: $email})
      RETURN properties(c) AS props
      LIMIT 1
    `;

    const result = await client.query(cypher, { email: email.toLowerCase() });

    if (!result.data?.values?.length) {
      return null;
    }

    return result.data.values[0][0] as ContactNode;
  }

  /**
   * Infer organization from email domain
   */
  private inferOrganization(email: string): string | undefined {
    const domain = email.split("@")[1];
    if (!domain) return undefined;

    // Skip common email providers
    const personalDomains = [
      "gmail.com", "yahoo.com", "hotmail.com", "outlook.com",
      "icloud.com", "protonmail.com", "aol.com",
    ];

    if (personalDomains.includes(domain.toLowerCase())) {
      return undefined;
    }

    // Convert domain to organization name
    return domain.split(".")[0];
  }

  /**
   * Get timeMin for initial sync (90 days ago)
   */
  private getTimeMin(): string {
    const date = new Date();
    date.setDate(date.getDate() - 90);
    return date.toISOString();
  }

  /**
   * Check if error is a 410 Gone (sync token expired)
   */
  private is410Error(error: unknown): boolean {
    const status = (error as { response?: { status?: number } })?.response?.status;
    return status === 410;
  }

  /**
   * Check if error is a 429 Rate Limit
   */
  private is429Error(error: unknown): boolean {
    const status = (error as { response?: { status?: number } })?.response?.status;
    return status === 429;
  }
}

// Singleton instance
let _calendarService: CalendarIngestionService | null = null;

export function getCalendarIngestionService(): CalendarIngestionService {
  if (!_calendarService) {
    _calendarService = new CalendarIngestionService();
  }
  return _calendarService;
}

/**
 * Convenience function for one-off calendar sync
 */
export async function ingestCalendarEvents(
  userId: string,
  client: Neo4jHTTPClient,
  forceFullSync: boolean = false
): Promise<CalendarSyncResult> {
  const service = getCalendarIngestionService();
  return service.syncEvents(userId, client, forceFullSync);
}
```
  </action>
  <verify>
File exists at apps/omnii_mcp/src/ingestion/sources/google-calendar.ts.
TypeScript compiles: `cd apps/omnii_mcp && bunx tsc --noEmit src/ingestion/sources/google-calendar.ts`
  </verify>
  <done>CalendarIngestionService syncs calendar events with incremental sync and quality gates</done>
</task>

<task type="auto">
  <name>Task 2: Create sources barrel export and update ingestion index</name>
  <files>apps/omnii_mcp/src/ingestion/sources/index.ts, apps/omnii_mcp/src/ingestion/index.ts</files>
  <action>
Create barrel export for sources and update main ingestion index.

1. Create `apps/omnii_mcp/src/ingestion/sources/index.ts`:

```typescript
/**
 * Ingestion Sources
 *
 * Per-source data ingestion services.
 * Each service handles fetching, validating, and inserting data from one Google service.
 */

export {
  CalendarIngestionService,
  getCalendarIngestionService,
  ingestCalendarEvents,
  type CalendarSyncResult,
} from "./google-calendar";
```

2. Update `apps/omnii_mcp/src/ingestion/index.ts` to include sources and validators:

```typescript
/**
 * Data Ingestion Module
 *
 * Infrastructure for ingesting external data sources into the knowledge graph.
 * - Composio client for Google OAuth and API calls
 * - BullMQ queue for background job processing
 * - Sync state for incremental sync tracking
 * - Validators for data quality gates
 * - Sources for per-service ingestion logic
 */

// Infrastructure
export { getComposioClient, type ComposioClient } from "./composio-client";
export { getRedisConnection, createIngestionQueue } from "./jobs/queue";

// Sync State
export {
  SyncStateService,
  getSyncStateService,
  type SyncSource,
  type SyncStatus,
  type SyncState,
  type SyncStateUpdate,
} from "./sync-state";

// Validators
export {
  CalendarEventSchema,
  GoogleTaskSchema,
  GoogleTaskListSchema,
  GmailMessageSchema,
  GoogleContactSchema,
  validateIngestionData,
  type CalendarEvent,
  type GoogleTask,
  type GoogleTaskList,
  type GmailMessage,
  type GoogleContact,
} from "./validators";

// Sources
export {
  CalendarIngestionService,
  getCalendarIngestionService,
  ingestCalendarEvents,
  type CalendarSyncResult,
} from "./sources";
```
  </action>
  <verify>
Both files exist.
TypeScript compiles: `cd apps/omnii_mcp && bunx tsc --noEmit src/ingestion/index.ts`
  </verify>
  <done>Sources barrel export created, ingestion module updated with all exports</done>
</task>

<task type="auto">
  <name>Task 3: Add manual sync trigger endpoint</name>
  <files>apps/omnii_mcp/src/routes/ingestion/index.ts</files>
  <action>
Add endpoint to manually trigger calendar sync (for testing and manual refresh).

Update `apps/omnii_mcp/src/routes/ingestion/index.ts` to add sync trigger:

Add this route after the existing routes:

```typescript
  /**
   * Trigger calendar sync for a user
   *
   * POST /api/ingestion/sync/calendar
   * Body: { userId: string, forceFullSync?: boolean }
   *
   * Triggers immediate calendar sync. For production, use background jobs.
   */
  .post(
    "/sync/calendar",
    async ({ body, set }) => {
      const { userId, forceFullSync } = body;

      try {
        // Import here to avoid circular dependency
        const { ingestCalendarEvents } = await import("../../ingestion/sources/google-calendar");
        const { createClientForUser } = await import("../../services/neo4j/http-client");

        // Get user's Neo4j client
        const client = await createClientForUser(userId);
        if (!client) {
          set.status = 400;
          return {
            error: "User database not provisioned",
            message: "User must have a Neo4j database before syncing",
          };
        }

        // Run sync
        const result = await ingestCalendarEvents(userId, client, forceFullSync || false);

        return {
          success: result.success,
          eventsProcessed: result.eventsProcessed,
          eventsCreated: result.eventsCreated,
          eventsSkipped: result.eventsSkipped,
          contactsCreated: result.contactsCreated,
          errors: result.errors,
        };
      } catch (error) {
        set.status = 500;
        return {
          error: "Sync failed",
          details: error instanceof Error ? error.message : String(error),
        };
      }
    },
    {
      body: t.Object({
        userId: t.String({ minLength: 1 }),
        forceFullSync: t.Optional(t.Boolean()),
      }),
    }
  )
```

Note: This endpoint is for manual/testing sync. Background jobs will be added in Plan 06.
  </action>
  <verify>
TypeScript compiles: `cd apps/omnii_mcp && bunx tsc --noEmit src/routes/ingestion/index.ts`
Endpoint added after existing routes.
  </verify>
  <done>Manual calendar sync trigger endpoint added at POST /api/ingestion/sync/calendar</done>
</task>

</tasks>

<verification>
1. CalendarIngestionService compiles: `cd apps/omnii_mcp && bunx tsc --noEmit src/ingestion/sources/google-calendar.ts`
2. Full ingestion module compiles: `cd apps/omnii_mcp && bunx tsc --noEmit src/ingestion/index.ts`
3. Routes compile with sync endpoint: `cd apps/omnii_mcp && bunx tsc --noEmit src/routes/ingestion/index.ts`
</verification>

<success_criteria>
- CalendarIngestionService fetches events via Composio with exponential backoff
- Events validated against CalendarEventSchema before insertion
- Valid events inserted as Event nodes with Google ID for deduplication
- Attendees extracted as Contact nodes with ATTENDED_BY relationships
- Sync token persisted for incremental sync
- 410 errors clear sync token and trigger full sync
- Manual sync endpoint available for testing
- All files compile without TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/04-data-ingestion-pipeline/04-05-SUMMARY.md`
</output>
