---
phase: 05-mobile-client-offline-sync
plan: 07
type: execute
wave: 4
depends_on: ["05-06"]
files_modified:
  - apps/omnii-mobile/src/components/integrations/GoogleConnectionManager.tsx
  - apps/omnii-mobile/src/hooks/useGoogleConnection.ts
  - apps/omnii-mobile/src/app/(tabs)/profile.tsx
autonomous: true

must_haves:
  truths:
    - "User can initiate Google OAuth connection from mobile"
    - "Connection status shows for each Google service"
    - "User can disconnect Google services with confirmation"
  artifacts:
    - path: "apps/omnii-mobile/src/hooks/useGoogleConnection.ts"
      provides: "Hook for Google connection state and actions"
      exports: ["useGoogleConnection"]
    - path: "apps/omnii-mobile/src/components/integrations/GoogleConnectionManager.tsx"
      provides: "UI for managing Google connections"
      min_lines: 100
  key_links:
    - from: "apps/omnii-mobile/src/hooks/useGoogleConnection.ts"
      to: "/api/ingestion/connect"
      via: "fetch to initiate OAuth"
      pattern: "api/ingestion/connect"
---

<objective>
Create Google OAuth connection management for mobile app (MOBILE-03 requirement).

Purpose: Users need to connect their Google services (Calendar, Tasks, Gmail, Contacts) from the mobile app to enable data sync. This wires to the existing MCP backend OAuth routes.

Output: Connection status display, connect/disconnect buttons, OAuth flow handling.
</objective>

<execution_context>
@/Users/santino/.claude/get-shit-done/workflows/execute-plan.md
@/Users/santino/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-data-ingestion-pipeline/04-04-SUMMARY.md
@apps/omnii_mcp/src/routes/ingestion.ts
@apps/omnii-mobile/src/lib/api/mcp.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useGoogleConnection hook</name>
  <files>apps/omnii-mobile/src/hooks/useGoogleConnection.ts</files>
  <action>
Create hook for managing Google service connections via MCP backend:

```typescript
// apps/omnii-mobile/src/hooks/useGoogleConnection.ts
import { useState, useCallback, useEffect } from 'react';
import { Linking } from 'react-native';
import * as WebBrowser from 'expo-web-browser';
import { supabase } from '~/lib/supabase';
import { env } from '~/lib/env';
import { useAuth } from '~/context/AuthContext';

// Google service types
export type GoogleService = 'calendar' | 'tasks' | 'gmail' | 'contacts';

// Connection status per service
export interface ServiceConnection {
  service: GoogleService;
  isConnected: boolean;
  lastSync?: string;
  itemsSynced?: number;
  status?: 'active' | 'syncing' | 'error' | 'pending';
  error?: string;
}

// Overall connection state
export interface GoogleConnectionState {
  isLoading: boolean;
  isConnecting: boolean;
  error: string | null;
  connections: ServiceConnection[];
  overallStatus: 'disconnected' | 'partial' | 'connected';
}

/**
 * Hook for managing Google service connections.
 *
 * Uses the MCP backend's /api/ingestion endpoints to:
 * - Initiate OAuth connection
 * - Check connection status
 * - Disconnect services
 */
export function useGoogleConnection() {
  const { user } = useAuth();
  const [state, setState] = useState<GoogleConnectionState>({
    isLoading: true,
    isConnecting: false,
    error: null,
    connections: [],
    overallStatus: 'disconnected',
  });

  // Get auth token for API calls
  const getToken = async () => {
    const { data: { session } } = await supabase.auth.getSession();
    return session?.access_token;
  };

  // Build API URL
  const apiUrl = (path: string) => `${env.MCP_BASE_URL.replace(/\/$/, '')}${path}`;

  // Fetch current connection status
  const fetchStatus = useCallback(async () => {
    if (!user?.id) return;

    setState(prev => ({ ...prev, isLoading: true, error: null }));

    try {
      const token = await getToken();
      if (!token) throw new Error('Not authenticated');

      const response = await fetch(apiUrl(`/api/ingestion/status/${user.id}`), {
        headers: { Authorization: `Bearer ${token}` },
      });

      if (!response.ok) {
        throw new Error(`Failed to fetch status: ${response.status}`);
      }

      const data = await response.json();

      // Map backend response to connection state
      const connections: ServiceConnection[] = [
        {
          service: 'calendar',
          isConnected: data.isConnected,
          lastSync: data.syncState?.calendar?.lastSyncTime,
          itemsSynced: data.syncState?.calendar?.itemsSynced,
          status: data.syncState?.calendar?.status || (data.isConnected ? 'active' : 'pending'),
        },
        {
          service: 'tasks',
          isConnected: data.isConnected,
          lastSync: data.syncState?.tasks?.lastSyncTime,
          itemsSynced: data.syncState?.tasks?.itemsSynced,
          status: data.syncState?.tasks?.status || (data.isConnected ? 'active' : 'pending'),
        },
        {
          service: 'gmail',
          isConnected: data.isConnected,
          lastSync: data.syncState?.gmail?.lastSyncTime,
          itemsSynced: data.syncState?.gmail?.itemsSynced,
          status: data.syncState?.gmail?.status || (data.isConnected ? 'active' : 'pending'),
        },
        {
          service: 'contacts',
          isConnected: data.isConnected,
          lastSync: data.syncState?.contacts?.lastSyncTime,
          itemsSynced: data.syncState?.contacts?.itemsSynced,
          status: data.syncState?.contacts?.status || (data.isConnected ? 'active' : 'pending'),
        },
      ];

      const connectedCount = connections.filter(c => c.isConnected).length;
      const overallStatus = connectedCount === 0
        ? 'disconnected'
        : connectedCount === 4
        ? 'connected'
        : 'partial';

      setState({
        isLoading: false,
        isConnecting: false,
        error: null,
        connections,
        overallStatus,
      });
    } catch (error: any) {
      console.error('[useGoogleConnection] Status fetch error:', error);
      setState(prev => ({
        ...prev,
        isLoading: false,
        error: error.message,
      }));
    }
  }, [user?.id]);

  // Initiate OAuth connection
  const connect = useCallback(async () => {
    if (!user?.id) return;

    setState(prev => ({ ...prev, isConnecting: true, error: null }));

    try {
      const token = await getToken();
      if (!token) throw new Error('Not authenticated');

      // Request OAuth URL from backend
      const response = await fetch(apiUrl('/api/ingestion/connect'), {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${token}`,
        },
        body: JSON.stringify({
          service: 'google', // Composio handles all Google services
          redirectUri: Linking.createURL('auth/google-callback'),
        }),
      });

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(errorData.error || `Connection failed: ${response.status}`);
      }

      const data = await response.json();

      if (!data.redirectUrl) {
        throw new Error('No redirect URL received');
      }

      // Open OAuth URL in browser
      const result = await WebBrowser.openAuthSessionAsync(
        data.redirectUrl,
        Linking.createURL('auth/google-callback')
      );

      if (result.type === 'success') {
        // OAuth completed, refresh status
        await fetchStatus();
      } else if (result.type === 'cancel') {
        setState(prev => ({
          ...prev,
          isConnecting: false,
          error: 'Connection cancelled',
        }));
      }
    } catch (error: any) {
      console.error('[useGoogleConnection] Connect error:', error);
      setState(prev => ({
        ...prev,
        isConnecting: false,
        error: error.message,
      }));
    }
  }, [user?.id, fetchStatus]);

  // Disconnect Google services
  const disconnect = useCallback(async () => {
    if (!user?.id) return;

    setState(prev => ({ ...prev, isLoading: true, error: null }));

    try {
      const token = await getToken();
      if (!token) throw new Error('Not authenticated');

      const response = await fetch(apiUrl('/api/ingestion/disconnect'), {
        method: 'DELETE',
        headers: { Authorization: `Bearer ${token}` },
      });

      if (!response.ok) {
        throw new Error(`Disconnect failed: ${response.status}`);
      }

      // Refresh status
      await fetchStatus();
    } catch (error: any) {
      console.error('[useGoogleConnection] Disconnect error:', error);
      setState(prev => ({
        ...prev,
        isLoading: false,
        error: error.message,
      }));
    }
  }, [user?.id, fetchStatus]);

  // Trigger manual sync for a service
  const triggerSync = useCallback(async (service: GoogleService) => {
    if (!user?.id) return;

    try {
      const token = await getToken();
      if (!token) throw new Error('Not authenticated');

      const response = await fetch(apiUrl(`/api/ingestion/sync/${service}`), {
        method: 'POST',
        headers: { Authorization: `Bearer ${token}` },
      });

      if (!response.ok) {
        throw new Error(`Sync failed: ${response.status}`);
      }

      // Refresh status after sync starts
      setTimeout(fetchStatus, 2000);
    } catch (error: any) {
      console.error(`[useGoogleConnection] Sync error (${service}):`, error);
      throw error;
    }
  }, [user?.id, fetchStatus]);

  // Fetch status on mount and when user changes
  useEffect(() => {
    if (user?.id) {
      fetchStatus();
    }
  }, [user?.id, fetchStatus]);

  return {
    ...state,
    connect,
    disconnect,
    triggerSync,
    refresh: fetchStatus,
  };
}
```
  </action>
  <verify>TypeScript compiles: `cd apps/omnii-mobile && npx tsc --noEmit`</verify>
  <done>useGoogleConnection hook manages connect/disconnect/status with loading states</done>
</task>

<task type="auto">
  <name>Task 2: Create GoogleConnectionManager UI component</name>
  <files>apps/omnii-mobile/src/components/integrations/GoogleConnectionManager.tsx</files>
  <action>
Create UI for managing Google service connections:

```typescript
// apps/omnii-mobile/src/components/integrations/GoogleConnectionManager.tsx
import { View, Text, Pressable, ActivityIndicator, Alert } from 'react-native';
import { useState, useCallback } from 'react';
import {
  Calendar,
  CheckSquare,
  Mail,
  Users,
  Check,
  X,
  RefreshCw,
  Link2,
  Unlink,
  AlertCircle,
} from 'lucide-react-native';
import {
  useGoogleConnection,
  type GoogleService,
  type ServiceConnection,
} from '~/hooks/useGoogleConnection';

// Service configuration
const SERVICE_CONFIG: Record<
  GoogleService,
  { icon: typeof Calendar; label: string; color: string }
> = {
  calendar: { icon: Calendar, label: 'Calendar', color: 'text-blue-500' },
  tasks: { icon: CheckSquare, label: 'Tasks', color: 'text-green-500' },
  gmail: { icon: Mail, label: 'Gmail', color: 'text-red-500' },
  contacts: { icon: Users, label: 'Contacts', color: 'text-purple-500' },
};

// Format last sync time
const formatLastSync = (isoString?: string): string => {
  if (!isoString) return 'Never synced';
  const date = new Date(isoString);
  const now = new Date();
  const diffMs = now.getTime() - date.getTime();
  const diffMins = Math.floor(diffMs / 60000);

  if (diffMins < 1) return 'Just now';
  if (diffMins < 60) return `${diffMins}m ago`;
  if (diffMins < 1440) return `${Math.floor(diffMins / 60)}h ago`;
  return date.toLocaleDateString();
};

// Service row component
const ServiceRow = ({
  connection,
  onSync,
  isSyncing,
}: {
  connection: ServiceConnection;
  onSync: () => void;
  isSyncing: boolean;
}) => {
  const config = SERVICE_CONFIG[connection.service];
  const Icon = config.icon;

  return (
    <View className="flex-row items-center py-3 border-b border-gray-100">
      {/* Icon */}
      <View className="w-10 h-10 rounded-full bg-gray-100 items-center justify-center">
        <Icon size={20} className={config.color} />
      </View>

      {/* Info */}
      <View className="flex-1 ml-3">
        <Text className="text-base font-medium text-gray-900">{config.label}</Text>
        <Text className="text-sm text-gray-500">
          {connection.isConnected
            ? `${connection.itemsSynced || 0} items - ${formatLastSync(connection.lastSync)}`
            : 'Not connected'}
        </Text>
      </View>

      {/* Status/Sync Button */}
      {connection.isConnected ? (
        <Pressable
          onPress={onSync}
          disabled={isSyncing}
          className="p-2"
        >
          {isSyncing ? (
            <ActivityIndicator size="small" color="#6366F1" />
          ) : (
            <RefreshCw size={20} className="text-gray-400" />
          )}
        </Pressable>
      ) : (
        <View className="w-6 h-6 rounded-full bg-gray-200 items-center justify-center">
          <X size={14} className="text-gray-400" />
        </View>
      )}
    </View>
  );
};

interface GoogleConnectionManagerProps {
  /** Show detailed view with all services */
  detailed?: boolean;
}

export const GoogleConnectionManager = ({
  detailed = true,
}: GoogleConnectionManagerProps) => {
  const {
    isLoading,
    isConnecting,
    error,
    connections,
    overallStatus,
    connect,
    disconnect,
    triggerSync,
    refresh,
  } = useGoogleConnection();

  const [syncingService, setSyncingService] = useState<GoogleService | null>(null);

  // Handle connect with error display
  const handleConnect = useCallback(async () => {
    try {
      await connect();
    } catch (err: any) {
      Alert.alert('Connection Error', err.message);
    }
  }, [connect]);

  // Handle disconnect with confirmation
  const handleDisconnect = useCallback(() => {
    Alert.alert(
      'Disconnect Google',
      'This will remove access to all Google services. Your synced data will remain.',
      [
        { text: 'Cancel', style: 'cancel' },
        {
          text: 'Disconnect',
          style: 'destructive',
          onPress: disconnect,
        },
      ]
    );
  }, [disconnect]);

  // Handle sync for a service
  const handleSync = useCallback(async (service: GoogleService) => {
    setSyncingService(service);
    try {
      await triggerSync(service);
    } catch (err: any) {
      Alert.alert('Sync Error', err.message);
    } finally {
      setSyncingService(null);
    }
  }, [triggerSync]);

  if (isLoading) {
    return (
      <View className="bg-white rounded-2xl p-6 items-center">
        <ActivityIndicator size="large" color="#6366F1" />
        <Text className="text-gray-500 mt-2">Loading connections...</Text>
      </View>
    );
  }

  return (
    <View className="bg-white rounded-2xl overflow-hidden">
      {/* Header */}
      <View className="px-4 py-4 border-b border-gray-100">
        <View className="flex-row items-center justify-between">
          <View className="flex-row items-center">
            <View className={`w-3 h-3 rounded-full mr-2 ${
              overallStatus === 'connected' ? 'bg-green-500' :
              overallStatus === 'partial' ? 'bg-yellow-500' :
              'bg-gray-300'
            }`} />
            <Text className="text-lg font-bold text-gray-900">Google Services</Text>
          </View>

          <Pressable onPress={refresh} className="p-2">
            <RefreshCw size={18} className="text-gray-400" />
          </Pressable>
        </View>

        {/* Error Message */}
        {error && (
          <View className="flex-row items-center mt-2 bg-red-50 rounded-lg px-3 py-2">
            <AlertCircle size={16} className="text-red-500 mr-2" />
            <Text className="text-sm text-red-600 flex-1">{error}</Text>
          </View>
        )}
      </View>

      {/* Services List */}
      {detailed && (
        <View className="px-4">
          {connections.map(conn => (
            <ServiceRow
              key={conn.service}
              connection={conn}
              onSync={() => handleSync(conn.service)}
              isSyncing={syncingService === conn.service}
            />
          ))}
        </View>
      )}

      {/* Action Buttons */}
      <View className="p-4">
        {overallStatus === 'disconnected' ? (
          <Pressable
            onPress={handleConnect}
            disabled={isConnecting}
            className="flex-row items-center justify-center bg-indigo-500 rounded-xl py-3 px-4"
          >
            {isConnecting ? (
              <ActivityIndicator color="white" size="small" />
            ) : (
              <>
                <Link2 size={20} className="text-white mr-2" />
                <Text className="text-white font-semibold">Connect Google Account</Text>
              </>
            )}
          </Pressable>
        ) : (
          <Pressable
            onPress={handleDisconnect}
            className="flex-row items-center justify-center border border-red-200 rounded-xl py-3 px-4"
          >
            <Unlink size={20} className="text-red-500 mr-2" />
            <Text className="text-red-500 font-medium">Disconnect</Text>
          </Pressable>
        )}
      </View>
    </View>
  );
};

export default GoogleConnectionManager;
```
  </action>
  <verify>TypeScript compiles: `cd apps/omnii-mobile && npx tsc --noEmit`</verify>
  <done>GoogleConnectionManager shows service status, connect/disconnect buttons, sync triggers</done>
</task>

<task type="auto">
  <name>Task 3: Add GoogleConnectionManager to profile screen</name>
  <files>apps/omnii-mobile/src/app/(tabs)/profile.tsx</files>
  <action>
Add the GoogleConnectionManager component to the profile screen.

1. Import the component:
```typescript
import { GoogleConnectionManager } from '~/components/integrations/GoogleConnectionManager';
```

2. Add it to the profile screen content, ideally in a "Connected Services" section:

Look for a suitable location in the existing profile screen and add:

```tsx
{/* Connected Services Section */}
<View className="mb-6">
  <Text className="text-lg font-bold text-gray-900 mb-3 px-4">
    Connected Services
  </Text>
  <GoogleConnectionManager />
</View>
```

Place this after profile info but before any logout/settings sections.

If the profile screen uses ScrollView, ensure the component is inside it.

Read the existing profile.tsx first to understand its structure and find the best insertion point.
  </action>
  <verify>
1. Profile screen shows Google connection section
2. Connect button initiates OAuth flow
3. After connection, services show as connected with sync times
  </verify>
  <done>Profile screen includes GoogleConnectionManager component</done>
</task>

</tasks>

<verification>
1. useGoogleConnection fetches status from /api/ingestion/status
2. connect() calls /api/ingestion/connect and opens OAuth URL
3. disconnect() calls /api/ingestion/disconnect with confirmation dialog
4. triggerSync() calls /api/ingestion/sync/:service
5. UI shows connection status per service with icons
6. Connect button opens OAuth browser session
7. Disconnect shows confirmation dialog before disconnecting
8. Profile screen displays the connection manager
</verification>

<success_criteria>
- User can see Google connection status on profile
- "Connect Google Account" button initiates OAuth via WebBrowser
- After OAuth, status refreshes to show connected services
- Each service shows last sync time and item count
- Individual service sync can be triggered
- Disconnect button shows confirmation dialog before removing connection
- User can confirm or cancel disconnect action
</success_criteria>

<output>
After completion, create `.planning/phases/05-mobile-client-offline-sync/05-07-SUMMARY.md`
</output>
