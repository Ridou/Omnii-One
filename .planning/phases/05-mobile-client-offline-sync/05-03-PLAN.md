---
phase: 05-mobile-client-offline-sync
plan: 03
type: execute
wave: 2
depends_on: ["05-01", "05-02"]
files_modified:
  - apps/omnii-mobile/src/lib/powersync/connector.ts
  - apps/omnii-mobile/src/context/SyncContext.tsx
  - apps/omnii-mobile/src/app/_layout.tsx
autonomous: true

must_haves:
  truths:
    - "PowerSync connects to MCP backend sync endpoint"
    - "Sync state is available via React context"
    - "App layout wraps children with SyncProvider"
  artifacts:
    - path: "apps/omnii-mobile/src/lib/powersync/connector.ts"
      provides: "Backend connector for PowerSync"
      exports: ["OmniiConnector"]
    - path: "apps/omnii-mobile/src/context/SyncContext.tsx"
      provides: "React context for sync state"
      exports: ["SyncProvider", "useSyncState"]
  key_links:
    - from: "apps/omnii-mobile/src/lib/powersync/connector.ts"
      to: "/api/powersync/sync"
      via: "fetch with auth token"
      pattern: "fetch.*powersync/sync"
    - from: "apps/omnii-mobile/src/context/SyncContext.tsx"
      to: "apps/omnii-mobile/src/lib/powersync/connector.ts"
      via: "connector instantiation"
      pattern: "new OmniiConnector"
---

<objective>
Create PowerSync backend connector and React context that manages sync lifecycle.

Purpose: PowerSync needs a connector that fetches credentials and handles uploads. The SyncContext wraps the app to provide sync state to all components.

Output: Working connector that authenticates via Supabase JWT, context providing sync state hooks.
</objective>

<execution_context>
@/Users/santino/.claude/get-shit-done/workflows/execute-plan.md
@/Users/santino/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/05-mobile-client-offline-sync/05-RESEARCH.md
@apps/omnii-mobile/src/lib/supabase.ts
@apps/omnii-mobile/src/context/AuthContext.tsx
@apps/omnii-mobile/src/lib/powersync/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PowerSync backend connector</name>
  <files>apps/omnii-mobile/src/lib/powersync/connector.ts</files>
  <action>
Create the connector that PowerSync uses to sync with the MCP backend:

```typescript
// apps/omnii-mobile/src/lib/powersync/connector.ts
import {
  AbstractPowerSyncDatabase,
  CrudEntry,
  PowerSyncBackendConnector,
  UpdateType,
} from '@powersync/react-native';
import { supabase } from '../supabase';
import Constants from 'expo-constants';

// Get MCP backend URL from config
const getMcpBaseUrl = (): string => {
  const url = Constants.expoConfig?.extra?.mcpBaseUrl ||
              process.env.EXPO_PUBLIC_MCP_BASE_URL ||
              'http://localhost:3001';
  return url.replace(/\/$/, ''); // Remove trailing slash
};

/**
 * OmniiConnector - PowerSync backend connector for MCP server
 *
 * Handles:
 * 1. fetchCredentials - Gets Supabase JWT for authentication
 * 2. uploadData - Sends local changes to backend
 *
 * The connector uses the existing Supabase auth token to authenticate
 * with the MCP backend's PowerSync endpoints.
 */
export class OmniiConnector implements PowerSyncBackendConnector {
  private baseUrl: string;

  constructor() {
    this.baseUrl = getMcpBaseUrl();
    console.log('[OmniiConnector] Initialized with base URL:', this.baseUrl);
  }

  /**
   * Get credentials for PowerSync connection.
   *
   * Uses Supabase session token for authentication.
   * PowerSync will call this periodically to refresh credentials.
   */
  async fetchCredentials(): Promise<{
    endpoint: string;
    token: string;
  }> {
    const { data: { session }, error } = await supabase.auth.getSession();

    if (error || !session?.access_token) {
      console.error('[OmniiConnector] No session for credentials:', error?.message);
      throw new Error('Not authenticated');
    }

    return {
      endpoint: `${this.baseUrl}/api/powersync`,
      token: session.access_token,
    };
  }

  /**
   * Upload local changes to the backend.
   *
   * PowerSync calls this when there are pending local changes.
   * We batch them and send to the /upload endpoint.
   */
  async uploadData(database: AbstractPowerSyncDatabase): Promise<void> {
    const transaction = await database.getNextCrudTransaction();

    if (!transaction) {
      return; // No pending changes
    }

    try {
      const { endpoint, token } = await this.fetchCredentials();

      // Group operations by table
      const changes: Record<string, Array<{ type: string; id: string; data?: any }>> = {};

      for (const op of transaction.crud) {
        const table = op.table;
        if (!changes[table]) {
          changes[table] = [];
        }

        switch (op.op) {
          case UpdateType.PUT:
            changes[table].push({
              type: 'PUT',
              id: op.id,
              data: op.opData,
            });
            break;
          case UpdateType.PATCH:
            changes[table].push({
              type: 'PUT', // Treat PATCH as upsert
              id: op.id,
              data: op.opData,
            });
            break;
          case UpdateType.DELETE:
            changes[table].push({
              type: 'DELETE',
              id: op.id,
            });
            break;
        }
      }

      // Send to backend
      const response = await fetch(`${endpoint}/upload`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`,
        },
        body: JSON.stringify({ changes }),
      });

      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`Upload failed: ${response.status} - ${errorText}`);
      }

      const result = await response.json();
      console.log('[OmniiConnector] Upload complete:', result);

      // Mark transaction as complete
      await transaction.complete();

    } catch (error) {
      console.error('[OmniiConnector] Upload error:', error);
      // Don't mark complete - PowerSync will retry
      throw error;
    }
  }

  /**
   * Fetch changes from backend (custom implementation)
   *
   * PowerSync's default streaming sync uses WebSockets.
   * Our backend uses HTTP polling, so we implement custom fetch.
   */
  async fetchChanges(
    lastSyncTimestamp: string | null
  ): Promise<{
    changes: Record<string, any[]>;
    timestamp: string;
    hasMore: boolean;
  }> {
    const { endpoint, token } = await this.fetchCredentials();

    const params = new URLSearchParams();
    if (lastSyncTimestamp) {
      params.set('since', lastSyncTimestamp);
    }

    const response = await fetch(`${endpoint}/sync?${params}`, {
      headers: {
        'Authorization': `Bearer ${token}`,
      },
    });

    if (!response.ok) {
      throw new Error(`Fetch changes failed: ${response.status}`);
    }

    return response.json();
  }
}

// Export singleton instance
let connectorInstance: OmniiConnector | null = null;

export const getConnector = (): OmniiConnector => {
  if (!connectorInstance) {
    connectorInstance = new OmniiConnector();
  }
  return connectorInstance;
};
```
  </action>
  <verify>TypeScript compiles: `cd apps/omnii-mobile && npx tsc --noEmit`</verify>
  <done>OmniiConnector implements PowerSyncBackendConnector, fetchCredentials uses Supabase JWT, uploadData sends to /upload</done>
</task>

<task type="auto">
  <name>Task 2: Create SyncContext for app-wide sync state</name>
  <files>apps/omnii-mobile/src/context/SyncContext.tsx</files>
  <action>
Create React context that manages PowerSync lifecycle and exposes sync state:

```typescript
// apps/omnii-mobile/src/context/SyncContext.tsx
import {
  createContext,
  useContext,
  useEffect,
  useState,
  useCallback,
  type ReactNode,
} from 'react';
import { PowerSyncContext } from '@powersync/react';
import { PowerSyncDatabase } from '@powersync/react-native';
import { getPowerSync, resetPowerSync } from '~/lib/powersync';
import { OmniiConnector, getConnector } from '~/lib/powersync/connector';
import { useAuth } from './AuthContext';

// Sync state types
export type SyncStatus = 'offline' | 'connecting' | 'syncing' | 'synced' | 'error';

export interface SyncState {
  isInitialized: boolean;
  isConnected: boolean;
  isSyncing: boolean;
  status: SyncStatus;
  pendingChanges: number;
  lastSyncedAt: Date | null;
  error: string | null;
}

interface SyncContextValue extends SyncState {
  // Actions
  triggerSync: () => Promise<void>;
  disconnect: () => Promise<void>;
  clearAndReconnect: () => Promise<void>;
}

const defaultSyncState: SyncState = {
  isInitialized: false,
  isConnected: false,
  isSyncing: false,
  status: 'offline',
  pendingChanges: 0,
  lastSyncedAt: null,
  error: null,
};

const SyncStateContext = createContext<SyncContextValue | null>(null);

interface SyncProviderProps {
  children: ReactNode;
}

export const SyncProvider = ({ children }: SyncProviderProps) => {
  const { user, isInitialized: authInitialized } = useAuth();
  const [db, setDb] = useState<PowerSyncDatabase | null>(null);
  const [syncState, setSyncState] = useState<SyncState>(defaultSyncState);

  // Initialize PowerSync when user is authenticated
  useEffect(() => {
    if (!authInitialized) return;

    let mounted = true;
    let database: PowerSyncDatabase | null = null;

    const initialize = async () => {
      if (!user) {
        // User logged out - cleanup
        if (db) {
          await resetPowerSync();
          setDb(null);
          setSyncState(defaultSyncState);
        }
        return;
      }

      try {
        setSyncState(prev => ({ ...prev, status: 'connecting', error: null }));

        database = getPowerSync();
        await database.init();

        if (!mounted) return;

        // Set up status listener
        database.registerListener({
          statusChanged: (status) => {
            if (!mounted) return;

            const newStatus: SyncStatus = status.dataFlowStatus.uploading || status.dataFlowStatus.downloading
              ? 'syncing'
              : status.connected
              ? 'synced'
              : 'offline';

            setSyncState(prev => ({
              ...prev,
              isConnected: status.connected,
              isSyncing: status.dataFlowStatus.uploading || status.dataFlowStatus.downloading,
              status: newStatus,
              lastSyncedAt: status.lastSyncedAt ? new Date(status.lastSyncedAt) : null,
            }));
          },
        });

        // Connect with our connector
        const connector = getConnector();
        await database.connect(connector);

        if (!mounted) return;

        setDb(database);
        setSyncState(prev => ({
          ...prev,
          isInitialized: true,
          isConnected: true,
          status: 'synced',
        }));

        console.log('[SyncProvider] PowerSync initialized and connected');

      } catch (error: any) {
        console.error('[SyncProvider] Initialization error:', error);
        if (mounted) {
          setSyncState(prev => ({
            ...prev,
            isInitialized: true,
            status: 'error',
            error: error.message,
          }));
        }
      }
    };

    initialize();

    return () => {
      mounted = false;
    };
  }, [authInitialized, user?.id]);

  // Trigger manual sync
  const triggerSync = useCallback(async () => {
    if (!db) return;

    try {
      setSyncState(prev => ({ ...prev, isSyncing: true, status: 'syncing' }));

      // PowerSync will handle the sync via connector
      // For custom HTTP sync, we'd call connector.fetchChanges() here
      const connector = getConnector();
      const lastSync = syncState.lastSyncedAt?.toISOString() || null;
      const result = await connector.fetchChanges(lastSync);

      // Apply changes to local database
      for (const [table, records] of Object.entries(result.changes)) {
        for (const record of records) {
          await db.execute(
            `INSERT OR REPLACE INTO ${table} (id, ${Object.keys(record).filter(k => k !== 'id').join(', ')})
             VALUES (?, ${Object.keys(record).filter(k => k !== 'id').map(() => '?').join(', ')})`,
            [record.id, ...Object.entries(record).filter(([k]) => k !== 'id').map(([, v]) => v)]
          );
        }
      }

      setSyncState(prev => ({
        ...prev,
        isSyncing: false,
        status: 'synced',
        lastSyncedAt: new Date(result.timestamp),
      }));

      console.log('[SyncProvider] Manual sync complete');

    } catch (error: any) {
      console.error('[SyncProvider] Sync error:', error);
      setSyncState(prev => ({
        ...prev,
        isSyncing: false,
        status: 'error',
        error: error.message,
      }));
    }
  }, [db, syncState.lastSyncedAt]);

  // Disconnect
  const disconnect = useCallback(async () => {
    if (db) {
      await db.disconnect();
      setSyncState(prev => ({ ...prev, isConnected: false, status: 'offline' }));
    }
  }, [db]);

  // Clear data and reconnect (for troubleshooting)
  const clearAndReconnect = useCallback(async () => {
    await resetPowerSync();
    setDb(null);
    setSyncState(defaultSyncState);
    // Will re-initialize on next render due to user dependency
  }, []);

  const contextValue: SyncContextValue = {
    ...syncState,
    triggerSync,
    disconnect,
    clearAndReconnect,
  };

  // Render without PowerSync context if not initialized
  if (!db) {
    return (
      <SyncStateContext.Provider value={contextValue}>
        {children}
      </SyncStateContext.Provider>
    );
  }

  // Wrap with PowerSync context when database is ready
  return (
    <PowerSyncContext.Provider value={{ db }}>
      <SyncStateContext.Provider value={contextValue}>
        {children}
      </SyncStateContext.Provider>
    </PowerSyncContext.Provider>
  );
};

// Hook to use sync state
export const useSyncState = (): SyncContextValue => {
  const context = useContext(SyncStateContext);
  if (!context) {
    throw new Error('useSyncState must be used within a SyncProvider');
  }
  return context;
};

// Convenience exports
export default SyncProvider;
```
  </action>
  <verify>TypeScript compiles: `cd apps/omnii-mobile && npx tsc --noEmit`</verify>
  <done>SyncProvider wraps PowerSyncContext, useSyncState returns sync state and actions</done>
</task>

<task type="auto">
  <name>Task 3: Wire SyncProvider into app layout</name>
  <files>apps/omnii-mobile/src/app/_layout.tsx</files>
  <action>
Update the root app layout to include SyncProvider after AuthProvider:

1. Import SyncProvider:
```typescript
import { SyncProvider } from '~/context/SyncContext';
```

2. Add SyncProvider inside AuthProvider in the providers stack:

Find the existing provider stack (likely has AuthProvider, QueryClientProvider, etc.)
and add SyncProvider INSIDE AuthProvider (it depends on auth state):

```tsx
// Example structure - adapt to existing layout:
<AuthProvider>
  <SyncProvider>
    {/* ... existing children ... */}
    <QueryClientProvider client={queryClient}>
      {/* ... Stack/navigation ... */}
    </QueryClientProvider>
  </SyncProvider>
</AuthProvider>
```

The key is:
- SyncProvider must be INSIDE AuthProvider (uses useAuth hook)
- SyncProvider should wrap the navigation/screens
- Order: AuthProvider > SyncProvider > QueryClientProvider > Navigation

Read the existing _layout.tsx first and modify the provider hierarchy appropriately.
  </action>
  <verify>
1. App builds without errors: `cd apps/omnii-mobile && npx expo start --dev-client`
2. No errors in console about missing context
  </verify>
  <done>SyncProvider in _layout.tsx, wraps children inside AuthProvider</done>
</task>

</tasks>

<verification>
1. OmniiConnector implements fetchCredentials() returning endpoint and token
2. OmniiConnector implements uploadData() sending to /upload endpoint
3. SyncProvider manages PowerSync lifecycle based on auth state
4. useSyncState() hook returns status, isConnected, isSyncing, lastSyncedAt
5. SyncProvider is in the provider hierarchy in _layout.tsx
6. App starts without provider errors
</verification>

<success_criteria>
- OmniiConnector uses Supabase JWT for authentication
- SyncProvider initializes PowerSync when user logs in
- SyncProvider cleans up when user logs out
- useSyncState() available in any component
- triggerSync() manually fetches and applies changes
- App layout has SyncProvider after AuthProvider
</success_criteria>

<output>
After completion, create `.planning/phases/05-mobile-client-offline-sync/05-03-SUMMARY.md`
</output>
