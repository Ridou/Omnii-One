---
phase: 05-mobile-client-offline-sync
plan: 06
type: execute
wave: 3
depends_on: ["05-01", "05-03"]
files_modified:
  - apps/omnii-mobile/src/lib/api/mcp.ts
  - apps/omnii-mobile/src/hooks/useMcpTools.ts
  - apps/omnii-mobile/src/lib/env.ts
autonomous: true

must_haves:
  truths:
    - "Mobile app can call MCP backend API endpoints"
    - "MCP tools are accessible via React hooks"
    - "Environment config includes MCP backend URL"
  artifacts:
    - path: "apps/omnii-mobile/src/lib/api/mcp.ts"
      provides: "MCP API client"
      exports: ["mcpClient", "callMcpTool"]
    - path: "apps/omnii-mobile/src/hooks/useMcpTools.ts"
      provides: "React hooks for MCP tools"
      exports: ["useMcpTool", "useCalendarQuery", "useContactLookup"]
  key_links:
    - from: "apps/omnii-mobile/src/lib/api/mcp.ts"
      to: "MCP backend /mcp endpoints"
      via: "fetch with JWT"
      pattern: "fetch.*mcp"
---

<objective>
Wire mobile app to MCP backend for real-time graph operations via MCP tools.

Purpose: While PowerSync provides offline data, users also need real-time queries and mutations through the MCP tools (calendar query, contact lookup, etc.). This bridges mobile to the working MCP server.

Output: API client for MCP, hooks for tool invocation, env config for backend URL.
</objective>

<execution_context>
@/Users/santino/.claude/get-shit-done/workflows/execute-plan.md
@/Users/santino/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/03-graphrag-advanced-mcp/03-03-SUMMARY.md
@apps/omnii_mcp/src/mcp/tools/index.ts
@apps/omnii-mobile/src/lib/supabase.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update environment config with MCP backend URL</name>
  <files>apps/omnii-mobile/src/lib/env.ts, apps/omnii-mobile/app.config.js</files>
  <action>
1. Update `apps/omnii-mobile/src/lib/env.ts` to include MCP backend URL:

```typescript
// Add to existing env.ts or create if not exists
import Constants from 'expo-constants';

export const env = {
  // Existing Supabase vars
  SUPABASE_URL: Constants.expoConfig?.extra?.supabaseUrl || process.env.EXPO_PUBLIC_SUPABASE_URL || '',
  SUPABASE_ANON_KEY: Constants.expoConfig?.extra?.supabaseAnonKey || process.env.EXPO_PUBLIC_SUPABASE_ANON_KEY || '',

  // MCP Backend URL
  MCP_BASE_URL: Constants.expoConfig?.extra?.mcpBaseUrl || process.env.EXPO_PUBLIC_MCP_BASE_URL || 'http://localhost:3001',

  // PowerSync URL (if using PowerSync Cloud in future)
  POWERSYNC_URL: Constants.expoConfig?.extra?.powerSyncUrl || process.env.EXPO_PUBLIC_POWERSYNC_URL || '',

  // Check if we're in development
  isDev: __DEV__,
};

// Validate required vars exist
export const validateEnv = () => {
  const required = ['SUPABASE_URL', 'SUPABASE_ANON_KEY'];
  const missing = required.filter(key => !env[key as keyof typeof env]);

  if (missing.length > 0) {
    console.warn('[Env] Missing environment variables:', missing.join(', '));
  }

  return missing.length === 0;
};
```

2. Update `apps/omnii-mobile/app.config.js` to expose the MCP URL:

Look for the `extra` section and add:
```javascript
extra: {
  // ... existing vars ...
  mcpBaseUrl: process.env.EXPO_PUBLIC_MCP_BASE_URL || 'http://localhost:3001',
}
```

3. Add to `.env.example` in apps/omnii-mobile:
```
EXPO_PUBLIC_MCP_BASE_URL=http://localhost:3001
```
  </action>
  <verify>Import `import { env } from '~/lib/env'` works and env.MCP_BASE_URL has value</verify>
  <done>env.MCP_BASE_URL accessible, app.config.js exposes mcpBaseUrl in extra</done>
</task>

<task type="auto">
  <name>Task 2: Create MCP API client</name>
  <files>apps/omnii-mobile/src/lib/api/mcp.ts</files>
  <action>
Create API client for calling MCP backend endpoints:

```typescript
// apps/omnii-mobile/src/lib/api/mcp.ts
import { supabase } from '../supabase';
import { env } from '../env';

// MCP tool response type (from backend)
interface McpToolResponse {
  content: Array<{ type: 'text'; text: string }>;
  isError?: boolean;
}

// Tool call parameters type
type ToolParams = Record<string, unknown>;

/**
 * Get the current auth token for API calls.
 */
const getAuthToken = async (): Promise<string> => {
  const { data: { session } } = await supabase.auth.getSession();

  if (!session?.access_token) {
    throw new Error('Not authenticated');
  }

  return session.access_token;
};

/**
 * Base fetch function with auth and error handling.
 */
const apiFetch = async <T>(
  endpoint: string,
  options: RequestInit = {}
): Promise<T> => {
  const token = await getAuthToken();
  const baseUrl = env.MCP_BASE_URL.replace(/\/$/, '');

  const response = await fetch(`${baseUrl}${endpoint}`, {
    ...options,
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${token}`,
      ...options.headers,
    },
  });

  if (!response.ok) {
    const errorText = await response.text();
    throw new Error(`API error ${response.status}: ${errorText}`);
  }

  return response.json();
};

/**
 * Call an MCP tool via the backend HTTP endpoint.
 *
 * @param toolName - Name of the MCP tool (e.g., 'omnii_calendar_query')
 * @param params - Tool parameters
 * @returns Parsed tool response
 */
export const callMcpTool = async <T = unknown>(
  toolName: string,
  params: ToolParams
): Promise<{ data: T | null; error: string | null }> => {
  try {
    // Use the JSON-RPC style endpoint
    const response = await apiFetch<McpToolResponse>('/mcp', {
      method: 'POST',
      body: JSON.stringify({
        jsonrpc: '2.0',
        id: Date.now(),
        method: 'tools/call',
        params: {
          name: toolName,
          arguments: params,
        },
      }),
    });

    // Extract text content from MCP response
    const textContent = response.content.find(c => c.type === 'text');

    if (response.isError || !textContent) {
      return {
        data: null,
        error: textContent?.text || 'Tool execution failed',
      };
    }

    // Parse JSON from text content
    try {
      const data = JSON.parse(textContent.text) as T;
      return { data, error: null };
    } catch {
      // Return raw text if not JSON
      return { data: textContent.text as unknown as T, error: null };
    }
  } catch (error: any) {
    console.error(`[MCP] Tool call failed (${toolName}):`, error);
    return { data: null, error: error.message };
  }
};

/**
 * List available MCP tools.
 */
export const listMcpTools = async (): Promise<{ tools: Array<{ name: string; description: string }> }> => {
  const response = await apiFetch<{
    result: { tools: Array<{ name: string; description: string; inputSchema: any }> };
  }>('/mcp', {
    method: 'POST',
    body: JSON.stringify({
      jsonrpc: '2.0',
      id: Date.now(),
      method: 'tools/list',
    }),
  });

  return { tools: response.result.tools };
};

/**
 * Check MCP backend health.
 */
export const checkMcpHealth = async (): Promise<{
  status: string;
  tools: number;
}> => {
  return apiFetch('/mcp/health');
};

/**
 * Trigger PowerSync data population from Neo4j.
 */
export const populateSyncData = async (): Promise<{
  success: boolean;
  synced: { entities: number; events: number; relationships: number };
}> => {
  return apiFetch('/api/powersync/populate', { method: 'POST' });
};

// Export typed tool callers for convenience
export const mcpTools = {
  /**
   * Query calendar events
   */
  calendarQuery: (params: {
    query?: string;
    time_range?: string;
    include_context?: boolean;
  }) => callMcpTool<{ events: any[]; total: number }>('omnii_calendar_query', params),

  /**
   * Look up contact information
   */
  contactLookup: (params: {
    query: string;
    include_interactions?: boolean;
  }) => callMcpTool<{ contacts: any[]; total: number }>('omnii_contact_lookup', params),

  /**
   * Task operations
   */
  taskOperations: (params: {
    operation: 'list' | 'get' | 'create' | 'update' | 'complete';
    task_id?: string;
    filter?: string;
    title?: string;
    due_date?: string;
  }) => callMcpTool<{ tasks: any[]; total: number }>('omnii_task_operations', params),

  /**
   * Search nodes by query
   */
  searchNodes: (params: {
    query: string;
    node_types?: string[];
    limit?: number;
  }) => callMcpTool<{ results: any[]; total: number }>('omnii_graph_search_nodes', params),

  /**
   * List entities by type
   */
  listEntities: (params: {
    entity_type?: string;
    limit?: number;
  }) => callMcpTool<{ entities: any[]; total: number }>('omnii_graph_list_entities', params),

  /**
   * Get entity context with relationships
   */
  getContext: (params: {
    entity_id: string;
    depth?: number;
  }) => callMcpTool<{ entity: any; relationships: any[] }>('omnii_graph_get_context', params),
};
```
  </action>
  <verify>TypeScript compiles: `cd apps/omnii-mobile && npx tsc --noEmit`</verify>
  <done>mcpTools exports typed functions for each MCP tool, callMcpTool handles JSON-RPC</done>
</task>

<task type="auto">
  <name>Task 3: Create React hooks for MCP tools</name>
  <files>apps/omnii-mobile/src/hooks/useMcpTools.ts</files>
  <action>
Create React hooks that wrap MCP tool calls with loading/error state:

```typescript
// apps/omnii-mobile/src/hooks/useMcpTools.ts
import { useState, useCallback } from 'react';
import { mcpTools, callMcpTool, checkMcpHealth, populateSyncData } from '~/lib/api/mcp';

// Generic hook for any MCP tool call
interface UseMcpToolResult<T> {
  data: T | null;
  isLoading: boolean;
  error: string | null;
  execute: (params?: Record<string, unknown>) => Promise<T | null>;
  reset: () => void;
}

/**
 * Generic hook for calling MCP tools with loading/error state.
 *
 * @param toolName - Name of the MCP tool
 * @param defaultParams - Default parameters to merge with execute params
 */
export function useMcpTool<T = unknown>(
  toolName: string,
  defaultParams?: Record<string, unknown>
): UseMcpToolResult<T> {
  const [data, setData] = useState<T | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const execute = useCallback(
    async (params?: Record<string, unknown>): Promise<T | null> => {
      setIsLoading(true);
      setError(null);

      try {
        const result = await callMcpTool<T>(toolName, {
          ...defaultParams,
          ...params,
        });

        if (result.error) {
          setError(result.error);
          setData(null);
          return null;
        }

        setData(result.data);
        return result.data;
      } catch (err: any) {
        setError(err.message);
        setData(null);
        return null;
      } finally {
        setIsLoading(false);
      }
    },
    [toolName, defaultParams]
  );

  const reset = useCallback(() => {
    setData(null);
    setError(null);
    setIsLoading(false);
  }, []);

  return { data, isLoading, error, execute, reset };
}

// Typed hooks for specific tools

/**
 * Hook for querying calendar events via MCP.
 */
export function useCalendarQuery() {
  const [data, setData] = useState<{ events: any[]; total: number } | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const query = useCallback(
    async (params: {
      query?: string;
      time_range?: string;
      include_context?: boolean;
    }) => {
      setIsLoading(true);
      setError(null);

      const result = await mcpTools.calendarQuery(params);

      if (result.error) {
        setError(result.error);
        setData(null);
      } else {
        setData(result.data);
      }

      setIsLoading(false);
      return result.data;
    },
    []
  );

  return { events: data?.events || [], total: data?.total || 0, isLoading, error, query };
}

/**
 * Hook for looking up contacts via MCP.
 */
export function useContactLookup() {
  const [data, setData] = useState<{ contacts: any[]; total: number } | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const lookup = useCallback(
    async (query: string, includeInteractions?: boolean) => {
      setIsLoading(true);
      setError(null);

      const result = await mcpTools.contactLookup({
        query,
        include_interactions: includeInteractions,
      });

      if (result.error) {
        setError(result.error);
        setData(null);
      } else {
        setData(result.data);
      }

      setIsLoading(false);
      return result.data;
    },
    []
  );

  return { contacts: data?.contacts || [], total: data?.total || 0, isLoading, error, lookup };
}

/**
 * Hook for task operations via MCP.
 */
export function useTaskOperations() {
  const [data, setData] = useState<{ tasks: any[]; total: number } | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const listTasks = useCallback(async (filter?: string) => {
    setIsLoading(true);
    setError(null);

    const result = await mcpTools.taskOperations({ operation: 'list', filter });

    if (result.error) {
      setError(result.error);
    } else {
      setData(result.data);
    }

    setIsLoading(false);
    return result.data;
  }, []);

  const completeTask = useCallback(async (taskId: string) => {
    setIsLoading(true);
    setError(null);

    const result = await mcpTools.taskOperations({
      operation: 'complete',
      task_id: taskId,
    });

    setIsLoading(false);
    return !result.error;
  }, []);

  return {
    tasks: data?.tasks || [],
    total: data?.total || 0,
    isLoading,
    error,
    listTasks,
    completeTask,
  };
}

/**
 * Hook for graph search via MCP.
 */
export function useGraphSearch() {
  const [results, setResults] = useState<any[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const search = useCallback(
    async (query: string, nodeTypes?: string[], limit?: number) => {
      if (!query.trim()) {
        setResults([]);
        return [];
      }

      setIsLoading(true);
      setError(null);

      const result = await mcpTools.searchNodes({
        query,
        node_types: nodeTypes,
        limit,
      });

      if (result.error) {
        setError(result.error);
        setResults([]);
      } else {
        setResults(result.data?.results || []);
      }

      setIsLoading(false);
      return result.data?.results || [];
    },
    []
  );

  return { results, isLoading, error, search };
}

/**
 * Hook for MCP backend health check.
 */
export function useMcpHealth() {
  const [health, setHealth] = useState<{ status: string; tools: number } | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const check = useCallback(async () => {
    setIsLoading(true);
    setError(null);

    try {
      const result = await checkMcpHealth();
      setHealth(result);
    } catch (err: any) {
      setError(err.message);
      setHealth(null);
    }

    setIsLoading(false);
  }, []);

  return { health, isLoading, error, check };
}

/**
 * Hook to trigger sync data population.
 */
export function useSyncPopulate() {
  const [result, setResult] = useState<{
    success: boolean;
    synced: { entities: number; events: number; relationships: number };
  } | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const populate = useCallback(async () => {
    setIsLoading(true);
    setError(null);

    try {
      const data = await populateSyncData();
      setResult(data);
    } catch (err: any) {
      setError(err.message);
      setResult(null);
    }

    setIsLoading(false);
  }, []);

  return { result, isLoading, error, populate };
}
```
  </action>
  <verify>TypeScript compiles: `cd apps/omnii-mobile && npx tsc --noEmit`</verify>
  <done>Hooks exported: useMcpTool, useCalendarQuery, useContactLookup, useTaskOperations, useGraphSearch</done>
</task>

</tasks>

<verification>
1. env.ts exports MCP_BASE_URL from environment
2. mcpTools provides typed wrappers for all 7 MCP tools
3. callMcpTool handles JSON-RPC format correctly
4. Hooks provide loading/error state with execute functions
5. populateSyncData triggers backend sync
6. All hooks use Supabase JWT for authentication
</verification>

<success_criteria>
- Mobile can call MCP tools via mcpTools.calendarQuery(), etc.
- Hooks manage loading/error state automatically
- Authentication uses existing Supabase session
- Environment config supports dev/prod MCP URLs
- TypeScript types match tool parameter schemas
</success_criteria>

<output>
After completion, create `.planning/phases/05-mobile-client-offline-sync/05-06-SUMMARY.md`
</output>
