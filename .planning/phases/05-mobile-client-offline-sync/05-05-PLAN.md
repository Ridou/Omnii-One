---
phase: 05-mobile-client-offline-sync
plan: 05
type: execute
wave: 3
depends_on: ["05-03", "05-04"]
files_modified:
  - apps/omnii-mobile/src/components/graph/EntityList.tsx
  - apps/omnii-mobile/src/components/graph/EventTimeline.tsx
  - apps/omnii-mobile/src/components/graph/RelationshipGraph.tsx
  - apps/omnii-mobile/src/components/graph/index.ts
  - apps/omnii-mobile/src/hooks/useGraphData.ts
autonomous: true

must_haves:
  truths:
    - "User can see list of synced entities by type"
    - "User can see timeline of calendar events"
    - "Graph data loads from local PowerSync database"
  artifacts:
    - path: "apps/omnii-mobile/src/components/graph/EntityList.tsx"
      provides: "Filterable entity list view"
      min_lines: 80
    - path: "apps/omnii-mobile/src/components/graph/EventTimeline.tsx"
      provides: "Chronological event display"
      min_lines: 60
    - path: "apps/omnii-mobile/src/hooks/useGraphData.ts"
      provides: "Hooks for querying PowerSync data"
      exports: ["useEntities", "useEvents", "useRelationships"]
  key_links:
    - from: "apps/omnii-mobile/src/hooks/useGraphData.ts"
      to: "PowerSync database"
      via: "usePowerSyncWatchedQuery"
      pattern: "usePowerSyncWatchedQuery"
---

<objective>
Create unified data views showing graph content from local PowerSync database (MOBILE-06 requirement).

Purpose: Users need to see their synced data in an engaging way. These components display entities, events, and relationships from the offline-capable local database.

Output: Entity list, event timeline, and relationship visualization components.
</objective>

<execution_context>
@/Users/santino/.claude/get-shit-done/workflows/execute-plan.md
@/Users/santino/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/05-mobile-client-offline-sync/05-RESEARCH.md
@apps/omnii-mobile/src/lib/powersync/schema.ts
@apps/omnii-mobile/src/context/SyncContext.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useGraphData hooks for querying local data</name>
  <files>apps/omnii-mobile/src/hooks/useGraphData.ts</files>
  <action>
Create hooks that query the local PowerSync SQLite database:

```typescript
// apps/omnii-mobile/src/hooks/useGraphData.ts
import { useMemo } from 'react';
import { usePowerSyncWatchedQuery } from '@powersync/react';
import {
  type SyncEntity,
  type SyncEvent,
  type SyncRelationship,
  parseProperties,
} from '~/lib/powersync/schema';

// Entity type filter
export type EntityType = 'task' | 'email' | 'contact' | 'concept' | 'entity' | 'all';

/**
 * Hook to query entities from local database.
 * Data updates automatically when PowerSync syncs.
 *
 * @param entityType - Filter by entity type, or 'all' for no filter
 * @param limit - Maximum results (default 100)
 * @param searchQuery - Optional name search filter
 */
export const useEntities = (
  entityType: EntityType = 'all',
  limit: number = 100,
  searchQuery?: string
) => {
  // Build query based on filters
  const query = useMemo(() => {
    let sql = 'SELECT * FROM sync_entities';
    const params: (string | number)[] = [];

    const conditions: string[] = [];

    if (entityType !== 'all') {
      conditions.push('entity_type = ?');
      params.push(entityType);
    }

    if (searchQuery?.trim()) {
      conditions.push('name LIKE ?');
      params.push(`%${searchQuery.trim()}%`);
    }

    if (conditions.length > 0) {
      sql += ' WHERE ' + conditions.join(' AND ');
    }

    sql += ' ORDER BY updated_at DESC LIMIT ?';
    params.push(limit);

    return { sql, params };
  }, [entityType, limit, searchQuery]);

  const { data, isLoading, error } = usePowerSyncWatchedQuery<SyncEntity>(
    query.sql,
    query.params
  );

  // Parse JSON properties for each entity
  const entities = useMemo(() => {
    return (data || []).map(entity => ({
      ...entity,
      parsedProperties: parseProperties(entity.properties),
    }));
  }, [data]);

  return {
    entities,
    isLoading,
    error: error?.message,
    count: entities.length,
  };
};

/**
 * Hook to query events from local database.
 * Useful for calendar/timeline views.
 *
 * @param startDate - Filter events starting after this date
 * @param endDate - Filter events ending before this date
 * @param limit - Maximum results
 */
export const useEvents = (
  startDate?: Date,
  endDate?: Date,
  limit: number = 50
) => {
  const query = useMemo(() => {
    let sql = 'SELECT * FROM sync_events';
    const params: (string | number)[] = [];
    const conditions: string[] = [];

    if (startDate) {
      conditions.push('start_time >= ?');
      params.push(startDate.toISOString());
    }

    if (endDate) {
      conditions.push('end_time <= ?');
      params.push(endDate.toISOString());
    }

    if (conditions.length > 0) {
      sql += ' WHERE ' + conditions.join(' AND ');
    }

    sql += ' ORDER BY start_time ASC LIMIT ?';
    params.push(limit);

    return { sql, params };
  }, [startDate, endDate, limit]);

  const { data, isLoading, error } = usePowerSyncWatchedQuery<SyncEvent>(
    query.sql,
    query.params
  );

  // Parse attendees JSON
  const events = useMemo(() => {
    return (data || []).map(event => ({
      ...event,
      parsedAttendees: parseProperties<string[]>(event.attendees) || [],
    }));
  }, [data]);

  return {
    events,
    isLoading,
    error: error?.message,
    count: events.length,
  };
};

/**
 * Hook to query relationships from local database.
 *
 * @param entityId - Filter relationships involving this entity
 * @param relationshipType - Filter by relationship type
 */
export const useRelationships = (
  entityId?: string,
  relationshipType?: string
) => {
  const query = useMemo(() => {
    let sql = 'SELECT * FROM sync_relationships';
    const params: string[] = [];
    const conditions: string[] = [];

    if (entityId) {
      conditions.push('(from_entity_id = ? OR to_entity_id = ?)');
      params.push(entityId, entityId);
    }

    if (relationshipType) {
      conditions.push('relationship_type = ?');
      params.push(relationshipType);
    }

    if (conditions.length > 0) {
      sql += ' WHERE ' + conditions.join(' AND ');
    }

    sql += ' ORDER BY updated_at DESC LIMIT 100';

    return { sql, params };
  }, [entityId, relationshipType]);

  const { data, isLoading, error } = usePowerSyncWatchedQuery<SyncRelationship>(
    query.sql,
    query.params
  );

  return {
    relationships: data || [],
    isLoading,
    error: error?.message,
    count: (data || []).length,
  };
};

/**
 * Hook to get a single entity by ID.
 */
export const useEntity = (entityId: string) => {
  const { data, isLoading, error } = usePowerSyncWatchedQuery<SyncEntity>(
    'SELECT * FROM sync_entities WHERE id = ? LIMIT 1',
    [entityId]
  );

  const entity = data?.[0] ? {
    ...data[0],
    parsedProperties: parseProperties(data[0].properties),
  } : null;

  return { entity, isLoading, error: error?.message };
};

/**
 * Hook to get entity count by type.
 */
export const useEntityCounts = () => {
  const { data, isLoading } = usePowerSyncWatchedQuery<{ entity_type: string; count: number }>(
    `SELECT entity_type, COUNT(*) as count
     FROM sync_entities
     GROUP BY entity_type`
  );

  const counts = useMemo(() => {
    const result: Record<string, number> = {};
    (data || []).forEach(row => {
      result[row.entity_type] = row.count;
    });
    return result;
  }, [data]);

  return { counts, isLoading };
};
```
  </action>
  <verify>TypeScript compiles: `cd apps/omnii-mobile && npx tsc --noEmit`</verify>
  <done>useEntities, useEvents, useRelationships hooks query PowerSync database with reactive updates</done>
</task>

<task type="auto">
  <name>Task 2: Create EntityList component</name>
  <files>apps/omnii-mobile/src/components/graph/EntityList.tsx</files>
  <action>
Create a filterable list showing entities:

```typescript
// apps/omnii-mobile/src/components/graph/EntityList.tsx
import { View, Text, FlatList, Pressable, TextInput, ActivityIndicator } from 'react-native';
import { useState, useCallback } from 'react';
import {
  User,
  Mail,
  CheckSquare,
  Lightbulb,
  Box,
  Search,
  ChevronRight,
} from 'lucide-react-native';
import { useEntities, type EntityType } from '~/hooks/useGraphData';

// Icon mapping for entity types
const ENTITY_ICONS: Record<string, typeof User> = {
  contact: User,
  email: Mail,
  task: CheckSquare,
  concept: Lightbulb,
  entity: Box,
};

// Color mapping for entity types
const ENTITY_COLORS: Record<string, string> = {
  contact: 'bg-blue-100 text-blue-600',
  email: 'bg-purple-100 text-purple-600',
  task: 'bg-green-100 text-green-600',
  concept: 'bg-yellow-100 text-yellow-600',
  entity: 'bg-gray-100 text-gray-600',
};

// Filter chips data
const ENTITY_FILTERS: { type: EntityType; label: string }[] = [
  { type: 'all', label: 'All' },
  { type: 'contact', label: 'Contacts' },
  { type: 'task', label: 'Tasks' },
  { type: 'email', label: 'Emails' },
  { type: 'concept', label: 'Concepts' },
];

interface EntityListProps {
  /** Pre-selected entity type filter */
  initialFilter?: EntityType;
  /** Called when entity is tapped */
  onEntityPress?: (entityId: string, entityType: string) => void;
  /** Max items to show */
  limit?: number;
}

export const EntityList = ({
  initialFilter = 'all',
  onEntityPress,
  limit = 100,
}: EntityListProps) => {
  const [filter, setFilter] = useState<EntityType>(initialFilter);
  const [search, setSearch] = useState('');

  const { entities, isLoading, error, count } = useEntities(filter, limit, search);

  // Render filter chip
  const renderFilterChip = useCallback(
    ({ type, label }: { type: EntityType; label: string }) => (
      <Pressable
        key={type}
        onPress={() => setFilter(type)}
        className={`px-4 py-2 rounded-full mr-2 ${
          filter === type ? 'bg-indigo-500' : 'bg-gray-100'
        }`}
      >
        <Text
          className={`text-sm font-medium ${
            filter === type ? 'text-white' : 'text-gray-600'
          }`}
        >
          {label}
        </Text>
      </Pressable>
    ),
    [filter]
  );

  // Render entity item
  const renderEntity = useCallback(
    ({ item }: { item: ReturnType<typeof useEntities>['entities'][0] }) => {
      const Icon = ENTITY_ICONS[item.entity_type] || Box;
      const colorClass = ENTITY_COLORS[item.entity_type] || ENTITY_COLORS.entity;
      const [bgColor, textColor] = colorClass.split(' ');

      return (
        <Pressable
          onPress={() => onEntityPress?.(item.id, item.entity_type)}
          className="flex-row items-center px-4 py-3 bg-white border-b border-gray-100"
        >
          {/* Type Icon */}
          <View className={`w-10 h-10 rounded-full items-center justify-center ${bgColor}`}>
            <Icon size={20} className={textColor} />
          </View>

          {/* Content */}
          <View className="flex-1 ml-3">
            <Text className="text-base font-medium text-gray-900" numberOfLines={1}>
              {item.name}
            </Text>
            <Text className="text-sm text-gray-500 capitalize">
              {item.entity_type}
              {item.parsedProperties.status && ` - ${item.parsedProperties.status}`}
            </Text>
          </View>

          {/* Chevron */}
          <ChevronRight size={20} className="text-gray-400" />
        </Pressable>
      );
    },
    [onEntityPress]
  );

  return (
    <View className="flex-1 bg-gray-50">
      {/* Search Bar */}
      <View className="px-4 py-3 bg-white border-b border-gray-100">
        <View className="flex-row items-center bg-gray-100 rounded-lg px-3 py-2">
          <Search size={18} className="text-gray-400" />
          <TextInput
            value={search}
            onChangeText={setSearch}
            placeholder="Search entities..."
            placeholderTextColor="#9CA3AF"
            className="flex-1 ml-2 text-base text-gray-900"
          />
        </View>
      </View>

      {/* Filter Chips */}
      <View className="px-4 py-3 bg-white border-b border-gray-200">
        <FlatList
          horizontal
          showsHorizontalScrollIndicator={false}
          data={ENTITY_FILTERS}
          renderItem={({ item }) => renderFilterChip(item)}
          keyExtractor={(item) => item.type}
        />
      </View>

      {/* Count Header */}
      <View className="px-4 py-2 bg-gray-50">
        <Text className="text-sm text-gray-500">
          {isLoading ? 'Loading...' : `${count} ${filter === 'all' ? 'entities' : filter}${count !== 1 ? 's' : ''}`}
        </Text>
      </View>

      {/* Entity List */}
      {isLoading ? (
        <View className="flex-1 items-center justify-center">
          <ActivityIndicator size="large" color="#6366F1" />
        </View>
      ) : error ? (
        <View className="flex-1 items-center justify-center px-4">
          <Text className="text-red-500 text-center">{error}</Text>
        </View>
      ) : (
        <FlatList
          data={entities}
          renderItem={renderEntity}
          keyExtractor={(item) => item.id}
          showsVerticalScrollIndicator={false}
          contentContainerStyle={{ paddingBottom: 20 }}
          ListEmptyComponent={
            <View className="py-12 items-center">
              <Text className="text-gray-400 text-center">
                No entities found.{'\n'}Sync data to see your graph content.
              </Text>
            </View>
          }
        />
      )}
    </View>
  );
};

export default EntityList;
```
  </action>
  <verify>TypeScript compiles: `cd apps/omnii-mobile && npx tsc --noEmit`</verify>
  <done>EntityList shows filterable, searchable list of entities with icons and type colors</done>
</task>

<task type="auto">
  <name>Task 3: Create EventTimeline and barrel export</name>
  <files>apps/omnii-mobile/src/components/graph/EventTimeline.tsx, apps/omnii-mobile/src/components/graph/index.ts</files>
  <action>
1. Create EventTimeline component:

```typescript
// apps/omnii-mobile/src/components/graph/EventTimeline.tsx
import { View, Text, FlatList, Pressable, ActivityIndicator } from 'react-native';
import { useCallback, useMemo } from 'react';
import { Calendar, Clock, MapPin, Users } from 'lucide-react-native';
import { useEvents } from '~/hooks/useGraphData';

// Format time for display
const formatTime = (isoString: string): string => {
  const date = new Date(isoString);
  return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
};

// Format date for section headers
const formatDate = (isoString: string): string => {
  const date = new Date(isoString);
  const today = new Date();
  const tomorrow = new Date(today);
  tomorrow.setDate(tomorrow.getDate() + 1);

  if (date.toDateString() === today.toDateString()) return 'Today';
  if (date.toDateString() === tomorrow.toDateString()) return 'Tomorrow';

  return date.toLocaleDateString([], {
    weekday: 'long',
    month: 'short',
    day: 'numeric',
  });
};

// Group events by date
type GroupedEvents = Array<{
  date: string;
  dateLabel: string;
  events: ReturnType<typeof useEvents>['events'];
}>;

interface EventTimelineProps {
  /** Start date for filtering */
  startDate?: Date;
  /** End date for filtering */
  endDate?: Date;
  /** Called when event is tapped */
  onEventPress?: (eventId: string) => void;
}

export const EventTimeline = ({
  startDate,
  endDate,
  onEventPress,
}: EventTimelineProps) => {
  // Default to 2 weeks ahead if no range specified
  const defaultStart = startDate || new Date();
  const defaultEnd = endDate || (() => {
    const d = new Date();
    d.setDate(d.getDate() + 14);
    return d;
  })();

  const { events, isLoading, error, count } = useEvents(defaultStart, defaultEnd, 100);

  // Group events by date
  const groupedEvents: GroupedEvents = useMemo(() => {
    const groups: Record<string, ReturnType<typeof useEvents>['events']> = {};

    events.forEach(event => {
      const dateKey = new Date(event.start_time).toDateString();
      if (!groups[dateKey]) {
        groups[dateKey] = [];
      }
      groups[dateKey].push(event);
    });

    return Object.entries(groups).map(([date, dayEvents]) => ({
      date,
      dateLabel: formatDate(dayEvents[0].start_time),
      events: dayEvents,
    }));
  }, [events]);

  // Render event item
  const renderEvent = useCallback(
    ({ item }: { item: ReturnType<typeof useEvents>['events'][0] }) => {
      const attendeeCount = item.parsedAttendees.length;

      return (
        <Pressable
          onPress={() => onEventPress?.(item.id)}
          className="ml-6 mb-3 bg-white rounded-xl p-4 shadow-sm border border-gray-100"
        >
          {/* Time Badge */}
          <View className="flex-row items-center mb-2">
            <View className="bg-indigo-100 rounded-full px-3 py-1">
              <Text className="text-xs font-medium text-indigo-600">
                {formatTime(item.start_time)} - {formatTime(item.end_time)}
              </Text>
            </View>
          </View>

          {/* Event Title */}
          <Text className="text-base font-semibold text-gray-900 mb-1" numberOfLines={2}>
            {item.summary}
          </Text>

          {/* Description */}
          {item.description && (
            <Text className="text-sm text-gray-500 mb-2" numberOfLines={2}>
              {item.description}
            </Text>
          )}

          {/* Meta Row */}
          <View className="flex-row items-center flex-wrap gap-3">
            {item.location && (
              <View className="flex-row items-center">
                <MapPin size={14} className="text-gray-400 mr-1" />
                <Text className="text-xs text-gray-500" numberOfLines={1}>
                  {item.location}
                </Text>
              </View>
            )}

            {attendeeCount > 0 && (
              <View className="flex-row items-center">
                <Users size={14} className="text-gray-400 mr-1" />
                <Text className="text-xs text-gray-500">
                  {attendeeCount} attendee{attendeeCount !== 1 ? 's' : ''}
                </Text>
              </View>
            )}
          </View>
        </Pressable>
      );
    },
    [onEventPress]
  );

  // Render date section
  const renderSection = useCallback(
    ({ item }: { item: GroupedEvents[0] }) => (
      <View className="mb-4">
        {/* Date Header */}
        <View className="flex-row items-center mb-3 px-4">
          <View className="w-3 h-3 rounded-full bg-indigo-500 mr-3" />
          <Text className="text-lg font-bold text-gray-900">{item.dateLabel}</Text>
          <Text className="text-sm text-gray-400 ml-2">
            ({item.events.length} event{item.events.length !== 1 ? 's' : ''})
          </Text>
        </View>

        {/* Events */}
        {item.events.map(event => (
          <View key={event.id}>
            {renderEvent({ item: event })}
          </View>
        ))}
      </View>
    ),
    [renderEvent]
  );

  if (isLoading) {
    return (
      <View className="flex-1 items-center justify-center">
        <ActivityIndicator size="large" color="#6366F1" />
      </View>
    );
  }

  if (error) {
    return (
      <View className="flex-1 items-center justify-center px-4">
        <Text className="text-red-500 text-center">{error}</Text>
      </View>
    );
  }

  return (
    <View className="flex-1 bg-gray-50">
      {/* Header */}
      <View className="px-4 py-3 bg-white border-b border-gray-100">
        <View className="flex-row items-center">
          <Calendar size={20} className="text-indigo-500 mr-2" />
          <Text className="text-lg font-bold text-gray-900">Timeline</Text>
          <Text className="text-sm text-gray-400 ml-auto">
            {count} upcoming events
          </Text>
        </View>
      </View>

      {/* Timeline */}
      <FlatList
        data={groupedEvents}
        renderItem={renderSection}
        keyExtractor={(item) => item.date}
        showsVerticalScrollIndicator={false}
        contentContainerStyle={{ paddingVertical: 16 }}
        ListEmptyComponent={
          <View className="py-12 items-center">
            <Calendar size={48} className="text-gray-300 mb-4" />
            <Text className="text-gray-400 text-center">
              No upcoming events.{'\n'}Sync your calendar to see events.
            </Text>
          </View>
        }
      />
    </View>
  );
};

export default EventTimeline;
```

2. Create barrel export:

```typescript
// apps/omnii-mobile/src/components/graph/index.ts
export { EntityList } from './EntityList';
export { EventTimeline } from './EventTimeline';
```
  </action>
  <verify>TypeScript compiles: `cd apps/omnii-mobile && npx tsc --noEmit`</verify>
  <done>EventTimeline groups events by date with visual timeline, barrel export available</done>
</task>

</tasks>

<verification>
1. useEntities hook returns entities with reactive updates
2. useEvents hook returns events within date range
3. EntityList displays filterable, searchable entity list
4. EventTimeline groups events by date with visual timeline
5. Both components handle loading, empty, and error states
6. Components use NativeWind/Tailwind classes for styling
</verification>

<success_criteria>
- Hooks query local PowerSync database (not network)
- Data updates automatically when sync completes
- EntityList shows filter chips, search, and typed icons
- EventTimeline shows grouped events with time badges
- Empty states guide user to sync data
- Components are performant with FlatList virtualization
</success_criteria>

<output>
After completion, create `.planning/phases/05-mobile-client-offline-sync/05-05-SUMMARY.md`
</output>
