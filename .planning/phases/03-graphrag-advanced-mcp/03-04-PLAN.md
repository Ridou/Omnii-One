---
phase: 03-graphrag-advanced-mcp
plan: 04
type: execute
wave: 2
depends_on: ["03-02"]
files_modified:
  - apps/omnii_mcp/src/services/graphrag/relationship-discovery.ts
  - apps/omnii_mcp/src/services/graphrag/index.ts
autonomous: true

must_haves:
  truths:
    - "System can extract entities from natural text using LLM"
    - "Extracted entities link to existing graph nodes when matches found"
    - "Relationships use specific types (EMPLOYED_BY, ATTENDED) not vague types (RELATED_TO)"
    - "Discovery process creates new nodes only when no match exists"
  artifacts:
    - path: "apps/omnii_mcp/src/services/graphrag/relationship-discovery.ts"
      provides: "Automatic entity extraction and relationship discovery"
      exports: ["discoverRelationships", "extractEntities", "RelationshipDiscoveryResult"]
  key_links:
    - from: "relationship-discovery.ts"
      to: "OpenAI API"
      via: "GPT-4o-mini for entity extraction"
      pattern: "openai.*chat.*completions"
    - from: "relationship-discovery.ts"
      to: "graph/operations/crud.ts"
      via: "createNode, createRelationship"
      pattern: "create(Node|Relationship)"
---

<objective>
Implement automatic relationship discovery between entities.

Purpose: Enable the system to extract entities and relationships from ingested text (emails, notes, calendar events) without manual tagging, building the knowledge graph automatically from unstructured content.

Output: Relationship discovery service using LLM-based entity extraction with quality prompts
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-graphrag-advanced-mcp/03-RESEARCH.md

# Phase 2 CRUD operations
@apps/omnii_mcp/src/graph/operations/crud.ts
@apps/omnii_mcp/src/graph/schema/nodes.ts
@apps/omnii_mcp/src/graph/schema/relationships.ts

# OpenAI client pattern (for embeddings)
@apps/omnii_mcp/src/graph/operations/embeddings.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create entity extraction with quality prompts</name>
  <files>
    apps/omnii_mcp/src/services/graphrag/relationship-discovery.ts
  </files>
  <action>
Create `apps/omnii_mcp/src/services/graphrag/relationship-discovery.ts`:

1. **Type definitions**:
   ```typescript
   export interface ExtractedEntity {
     name: string;
     type: 'Person' | 'Organization' | 'Event' | 'Concept' | 'Location';
     properties: Record<string, unknown>;
     confidence: number;
   }

   export interface ExtractedRelationship {
     from: string;  // Entity name
     to: string;    // Entity name
     type: string;  // Specific relationship type
     properties: Record<string, unknown>;
   }

   export interface RelationshipDiscoveryResult {
     entities: ExtractedEntity[];
     relationships: ExtractedRelationship[];
     nodesCreated: number;
     nodesLinked: number;  // Matched to existing
     relationshipsCreated: number;
   }
   ```

2. **EXTRACTION_PROMPT constant** (critical for quality):
   ```typescript
   const EXTRACTION_PROMPT = `Extract entities and relationships from the following text.

RULES:
1. Entity types MUST be one of: Person, Organization, Event, Concept, Location
2. Relationship types MUST be SPECIFIC and MEANINGFUL:
   - Use: EMPLOYED_BY, FOUNDED, ATTENDED, REPLIED_TO, MENTIONED_IN, SCHEDULED_FOR, LOCATED_AT, WORKS_WITH, REPORTED_TO, PARTICIPANT_OF
   - NEVER use: RELATED_TO, ASSOCIATED_WITH, CONNECTED_TO, HAS_RELATIONSHIP (too vague)
3. For people, extract: name, email (if present), role (if mentioned)
4. For organizations, extract: name, type (company, nonprofit, etc.)
5. Confidence should be 0.0-1.0 based on how explicit the mention is

Return JSON in this exact format:
{
  "entities": [
    { "name": "John Smith", "type": "Person", "properties": { "role": "CEO" }, "confidence": 0.9 }
  ],
  "relationships": [
    { "from": "John Smith", "to": "Acme Corp", "type": "EMPLOYED_BY", "properties": { "role": "CEO" } }
  ]
}

Text to analyze:
`;
   ```

3. **extractEntities function**:
   ```typescript
   export async function extractEntities(text: string): Promise<{
     entities: ExtractedEntity[];
     relationships: ExtractedRelationship[];
   }>
   ```
   - Use OpenAI client with model "gpt-4o-mini" (per research - minimum for quality)
   - Send EXTRACTION_PROMPT + text
   - Parse JSON response with error handling
   - Validate entity types against allowed list
   - Filter out relationships with vague types (RELATED_TO, ASSOCIATED_WITH, etc.)
   - Return extracted entities and relationships

4. **OpenAI client setup**:
   - Import OpenAI from 'openai' (add to package.json if not present)
   - Use process.env.OPENAI_API_KEY (already used for embeddings)
   - Handle rate limits with exponential backoff (reuse pattern from embeddings.ts)
  </action>
  <verify>
Run TypeScript compilation: `cd apps/omnii_mcp && bunx tsc --noEmit`

Check for vague relationship filtering: `grep -E "RELATED_TO|ASSOCIATED_WITH" apps/omnii_mcp/src/services/graphrag/relationship-discovery.ts` (should appear in filter logic, not as valid types)
  </verify>
  <done>
- ExtractedEntity and ExtractedRelationship types exported
- EXTRACTION_PROMPT enforces specific relationship types
- extractEntities uses GPT-4o-mini for quality extraction
- Vague relationship types are filtered out
- Rate limit handling with exponential backoff
  </done>
</task>

<task type="auto">
  <name>Task 2: Create relationship discovery with graph linking</name>
  <files>
    apps/omnii_mcp/src/services/graphrag/relationship-discovery.ts
    apps/omnii_mcp/src/services/graphrag/index.ts
  </files>
  <action>
Add to `relationship-discovery.ts`:

1. **findMatchingNode function** (internal):
   ```typescript
   async function findMatchingNode(
     client: Neo4jClient,
     userId: string,
     entity: ExtractedEntity
   ): Promise<{ id: string; name: string } | null>
   ```
   - Search for existing node by name similarity
   - Use Cypher: `MATCH (n {user_id: $userId}) WHERE toLower(n.name) = toLower($name) RETURN n LIMIT 1`
   - Return node ID if found, null otherwise

2. **discoverRelationships function** (main export):
   ```typescript
   export async function discoverRelationships(
     client: Neo4jClient,
     userId: string,
     text: string,
     options?: {
       createMissingNodes?: boolean;  // Default: true
       minConfidence?: number;        // Default: 0.5
       sourceContext?: string;        // e.g., "email:abc123" for provenance
     }
   ): Promise<RelationshipDiscoveryResult>
   ```

   Implementation:
   a. Call extractEntities(text) to get LLM extraction
   b. Filter entities by minConfidence
   c. For each entity:
      - Try findMatchingNode first
      - If found: increment nodesLinked
      - If not found AND createMissingNodes=true:
        - Map ExtractedEntity type to NodeLabel
        - Call createNode from crud.ts with embedding
        - Increment nodesCreated
      - Track entity name -> node ID mapping
   d. For each relationship:
      - Look up from/to node IDs from mapping
      - If both exist, call createRelationship from crud.ts
      - Add sourceContext to relationship properties
      - Increment relationshipsCreated
   e. Return RelationshipDiscoveryResult with counts

3. **Update index.ts**:
   ```typescript
   export * from './relationship-discovery';
   ```

IMPORTANT: Use parameterized Cypher queries. Never interpolate relationship type directly - use APOC or dynamic query building safely.

For dynamic relationship types, since Neo4j doesn't support parameterized relationship types, use:
```typescript
// Validate relationship type against allowed list first
const ALLOWED_RELATIONSHIPS = ['EMPLOYED_BY', 'FOUNDED', 'ATTENDED', ...];
if (!ALLOWED_RELATIONSHIPS.includes(relType)) {
  throw new Error(`Invalid relationship type: ${relType}`);
}
// Then safe to use in query (validated against whitelist)
const query = `MATCH (a), (b) WHERE elementId(a) = $fromId AND elementId(b) = $toId CREATE (a)-[:${relType}]->(b)`;
```
  </action>
  <verify>
Run TypeScript compilation: `cd apps/omnii_mcp && bunx tsc --noEmit`

Check exports: `grep "export" apps/omnii_mcp/src/services/graphrag/index.ts`

Verify relationship type validation: `grep "ALLOWED_RELATIONSHIPS" apps/omnii_mcp/src/services/graphrag/relationship-discovery.ts`
  </verify>
  <done>
- discoverRelationships function exported as main interface
- Entities matched to existing nodes before creating new ones
- New nodes created with embeddings for vector search
- Relationship types validated against whitelist (prevents injection)
- Result includes counts: nodesCreated, nodesLinked, relationshipsCreated
- sourceContext stored for provenance tracking
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors
2. Extraction prompt enforces specific relationship types
3. Vague relationship types filtered in extractEntities
4. discoverRelationships links to existing nodes when possible
5. Relationship types validated against whitelist before Cypher execution
6. All queries use parameterized values (except validated relationship type)
</verification>

<success_criteria>
- [ ] extractEntities uses GPT-4o-mini with quality extraction prompt
- [ ] Vague relationship types (RELATED_TO, etc.) are filtered out
- [ ] discoverRelationships matches existing nodes before creating new
- [ ] New nodes created with embeddings for vector search
- [ ] Relationship types validated against ALLOWED_RELATIONSHIPS whitelist
- [ ] sourceContext tracked for relationship provenance
</success_criteria>

<output>
After completion, create `.planning/phases/03-graphrag-advanced-mcp/03-04-SUMMARY.md`
</output>
