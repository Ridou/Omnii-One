---
phase: 03-graphrag-advanced-mcp
plan: 04
type: execute
wave: 2
depends_on: ["03-02"]
files_modified:
  - apps/omnii_mcp/src/services/graphrag/relationship-discovery.ts
  - apps/omnii_mcp/src/services/graphrag/index.ts
  - apps/omnii_mcp/src/mcp/tools/extract-relationships.ts
  - apps/omnii_mcp/src/mcp/tools/index.ts
autonomous: true

must_haves:
  truths:
    - "AI can trigger relationship discovery from text via MCP tool"
    - "AI receives extraction results showing entities found and relationships created"
    - "Relationships use specific types (EMPLOYED_BY, ATTENDED) not vague types (RELATED_TO)"
    - "Extracted entities link to existing graph nodes when matches found"
  artifacts:
    - path: "apps/omnii_mcp/src/services/graphrag/relationship-discovery.ts"
      provides: "Automatic entity extraction and relationship discovery"
      exports: ["discoverRelationships", "extractEntities", "RelationshipDiscoveryResult"]
    - path: "apps/omnii_mcp/src/mcp/tools/extract-relationships.ts"
      provides: "MCP tool for AI-triggered relationship extraction"
      exports: ["ExtractRelationshipsToolDefinition", "handleExtractRelationships"]
  key_links:
    - from: "relationship-discovery.ts"
      to: "OpenAI API"
      via: "GPT-4o-mini for entity extraction"
      pattern: "openai.*chat.*completions"
    - from: "relationship-discovery.ts"
      to: "graph/operations/crud.ts"
      via: "createNode, createRelationship"
      pattern: "create(Node|Relationship)"
    - from: "extract-relationships.ts"
      to: "services/graphrag/relationship-discovery.ts"
      via: "discoverRelationships"
      pattern: "discoverRelationships"
---

<objective>
Implement automatic relationship discovery between entities.

Purpose: Enable the system to extract entities and relationships from ingested text (emails, notes, calendar events) without manual tagging, building the knowledge graph automatically from unstructured content.

Output: Relationship discovery service using LLM-based entity extraction with quality prompts
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-graphrag-advanced-mcp/03-RESEARCH.md

# Phase 2 CRUD operations
@apps/omnii_mcp/src/graph/operations/crud.ts
@apps/omnii_mcp/src/graph/schema/nodes.ts
@apps/omnii_mcp/src/graph/schema/relationships.ts

# OpenAI client pattern (for embeddings)
@apps/omnii_mcp/src/graph/operations/embeddings.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create entity extraction with quality prompts</name>
  <files>
    apps/omnii_mcp/src/services/graphrag/relationship-discovery.ts
  </files>
  <action>
Create `apps/omnii_mcp/src/services/graphrag/relationship-discovery.ts`:

1. **Type definitions**:
   ```typescript
   export interface ExtractedEntity {
     name: string;
     type: 'Person' | 'Organization' | 'Event' | 'Concept' | 'Location';
     properties: Record<string, unknown>;
     confidence: number;
   }

   export interface ExtractedRelationship {
     from: string;  // Entity name
     to: string;    // Entity name
     type: string;  // Specific relationship type
     properties: Record<string, unknown>;
   }

   export interface RelationshipDiscoveryResult {
     entities: ExtractedEntity[];
     relationships: ExtractedRelationship[];
     nodesCreated: number;
     nodesLinked: number;  // Matched to existing
     relationshipsCreated: number;
   }
   ```

2. **EXTRACTION_PROMPT constant** (critical for quality):
   ```typescript
   const EXTRACTION_PROMPT = `Extract entities and relationships from the following text.

RULES:
1. Entity types MUST be one of: Person, Organization, Event, Concept, Location
2. Relationship types MUST be SPECIFIC and MEANINGFUL:
   - Use: EMPLOYED_BY, FOUNDED, ATTENDED, REPLIED_TO, MENTIONED_IN, SCHEDULED_FOR, LOCATED_AT, WORKS_WITH, REPORTED_TO, PARTICIPANT_OF
   - NEVER use: RELATED_TO, ASSOCIATED_WITH, CONNECTED_TO, HAS_RELATIONSHIP (too vague)
3. For people, extract: name, email (if present), role (if mentioned)
4. For organizations, extract: name, type (company, nonprofit, etc.)
5. Confidence should be 0.0-1.0 based on how explicit the mention is

Return JSON in this exact format:
{
  "entities": [
    { "name": "John Smith", "type": "Person", "properties": { "role": "CEO" }, "confidence": 0.9 }
  ],
  "relationships": [
    { "from": "John Smith", "to": "Acme Corp", "type": "EMPLOYED_BY", "properties": { "role": "CEO" } }
  ]
}

Text to analyze:
`;
   ```

3. **extractEntities function**:
   ```typescript
   export async function extractEntities(text: string): Promise<{
     entities: ExtractedEntity[];
     relationships: ExtractedRelationship[];
   }>
   ```
   - Use OpenAI client with model "gpt-4o-mini" (per research - minimum for quality)
   - Send EXTRACTION_PROMPT + text
   - Parse JSON response with error handling
   - Validate entity types against allowed list
   - Filter out relationships with vague types (RELATED_TO, ASSOCIATED_WITH, etc.)
   - Return extracted entities and relationships

4. **OpenAI client setup**:
   - Import OpenAI from 'openai' (add to package.json if not present)
   - Use process.env.OPENAI_API_KEY (already used for embeddings)
   - Handle rate limits with exponential backoff (reuse pattern from embeddings.ts)
  </action>
  <verify>
Run TypeScript compilation: `cd apps/omnii_mcp && bunx tsc --noEmit`

Check for vague relationship filtering: `grep -E "RELATED_TO|ASSOCIATED_WITH" apps/omnii_mcp/src/services/graphrag/relationship-discovery.ts` (should appear in filter logic, not as valid types)
  </verify>
  <done>
- ExtractedEntity and ExtractedRelationship types exported
- EXTRACTION_PROMPT enforces specific relationship types
- extractEntities uses GPT-4o-mini for quality extraction
- Vague relationship types are filtered out
- Rate limit handling with exponential backoff
  </done>
</task>

<task type="auto">
  <name>Task 2: Create relationship discovery with graph linking</name>
  <files>
    apps/omnii_mcp/src/services/graphrag/relationship-discovery.ts
    apps/omnii_mcp/src/services/graphrag/index.ts
  </files>
  <action>
Add to `relationship-discovery.ts`:

1. **findMatchingNode function** (internal):
   ```typescript
   async function findMatchingNode(
     client: Neo4jClient,
     userId: string,
     entity: ExtractedEntity
   ): Promise<{ id: string; name: string } | null>
   ```
   - Search for existing node by name similarity
   - Use Cypher: `MATCH (n {user_id: $userId}) WHERE toLower(n.name) = toLower($name) RETURN n LIMIT 1`
   - Return node ID if found, null otherwise

2. **discoverRelationships function** (main export):
   ```typescript
   export async function discoverRelationships(
     client: Neo4jClient,
     userId: string,
     text: string,
     options?: {
       createMissingNodes?: boolean;  // Default: true
       minConfidence?: number;        // Default: 0.5
       sourceContext?: string;        // e.g., "email:abc123" for provenance
     }
   ): Promise<RelationshipDiscoveryResult>
   ```

   Implementation:
   a. Call extractEntities(text) to get LLM extraction
   b. Filter entities by minConfidence
   c. For each entity:
      - Try findMatchingNode first
      - If found: increment nodesLinked
      - If not found AND createMissingNodes=true:
        - Map ExtractedEntity type to NodeLabel
        - Call createNode from crud.ts with embedding
        - Increment nodesCreated
      - Track entity name -> node ID mapping
   d. For each relationship:
      - Look up from/to node IDs from mapping
      - If both exist, call createRelationship from crud.ts
      - Add sourceContext to relationship properties
      - Increment relationshipsCreated
   e. Return RelationshipDiscoveryResult with counts

3. **Update index.ts**:
   ```typescript
   export * from './relationship-discovery';
   ```

IMPORTANT: Use parameterized Cypher queries. Never interpolate relationship type directly - use APOC or dynamic query building safely.

For dynamic relationship types, since Neo4j doesn't support parameterized relationship types, use:
```typescript
// Validate relationship type against allowed list first
const ALLOWED_RELATIONSHIPS = ['EMPLOYED_BY', 'FOUNDED', 'ATTENDED', ...];
if (!ALLOWED_RELATIONSHIPS.includes(relType)) {
  throw new Error(`Invalid relationship type: ${relType}`);
}
// Then safe to use in query (validated against whitelist)
const query = `MATCH (a), (b) WHERE elementId(a) = $fromId AND elementId(b) = $toId CREATE (a)-[:${relType}]->(b)`;
```
  </action>
  <verify>
Run TypeScript compilation: `cd apps/omnii_mcp && bunx tsc --noEmit`

Check exports: `grep "export" apps/omnii_mcp/src/services/graphrag/index.ts`

Verify relationship type validation: `grep "ALLOWED_RELATIONSHIPS" apps/omnii_mcp/src/services/graphrag/relationship-discovery.ts`
  </verify>
  <done>
- discoverRelationships function exported as main interface
- Entities matched to existing nodes before creating new ones
- New nodes created with embeddings for vector search
- Relationship types validated against whitelist (prevents injection)
- Result includes counts: nodesCreated, nodesLinked, relationshipsCreated
- sourceContext stored for provenance tracking
  </done>
</task>

<task type="auto">
  <name>Task 3: Create MCP tool to expose relationship discovery</name>
  <files>
    apps/omnii_mcp/src/mcp/tools/extract-relationships.ts
    apps/omnii_mcp/src/mcp/tools/index.ts
  </files>
  <action>
Create `apps/omnii_mcp/src/mcp/tools/extract-relationships.ts` to expose discoverRelationships via MCP:

1. **Zod input schema**:
   ```typescript
   export const ExtractRelationshipsInputSchema = z.object({
     text: z.string().min(10).max(10000).describe('Text to extract entities and relationships from (10-10000 chars)'),
     create_missing_nodes: z.boolean().default(true).describe('Create new nodes for unmatched entities'),
     min_confidence: z.number().min(0).max(1).default(0.5).describe('Minimum confidence threshold for extracted entities'),
     source_context: z.string().optional().describe('Source identifier for provenance (e.g., "email:abc123")')
   });
   ```

2. **Tool definition**:
   ```typescript
   export const ExtractRelationshipsToolDefinition = {
     name: 'omnii_extract_relationships',
     description: 'Extract entities and relationships from text. Identifies people, organizations, events, and concepts, then creates or links graph nodes. Use when processing emails, meeting notes, or other unstructured text to build the knowledge graph.',
     inputSchema: {
       type: 'object',
       properties: {
         text: { type: 'string', description: 'Text to analyze for entities and relationships' },
         create_missing_nodes: { type: 'boolean', default: true, description: 'Create new nodes for unmatched entities' },
         min_confidence: { type: 'number', default: 0.5, description: 'Minimum confidence (0-1)' },
         source_context: { type: 'string', description: 'Source identifier for provenance' }
       },
       required: ['text']
     }
   };
   ```

3. **Handler function**:
   ```typescript
   export async function handleExtractRelationships(
     input: unknown,
     context: { userId: string; client: Neo4jClient }
   ): Promise<MCPToolResponse>
   ```
   - Validate input with Zod schema
   - Call `discoverRelationships` from relationship-discovery.ts
   - Return MCPToolResponse with extraction results:
     - entities found (names, types, confidence)
     - relationships created (from -> type -> to)
     - counts: nodesCreated, nodesLinked, relationshipsCreated
   - On error, return `{ isError: true, content: [{ type: 'text', text: error message }] }`

4. **Update tools/index.ts**:
   - Import ExtractRelationshipsToolDefinition and handleExtractRelationships
   - Add to TOOL_DEFINITIONS array
   - Add handler to TOOL_HANDLERS map

This wires the relationship discovery service into the MCP layer so AI can trigger extraction.
  </action>
  <verify>
Run TypeScript compilation: `cd apps/omnii_mcp && bunx tsc --noEmit`

Verify tool registration: `grep "omnii_extract_relationships" apps/omnii_mcp/src/mcp/tools/index.ts`

Check handler calls service: `grep "discoverRelationships" apps/omnii_mcp/src/mcp/tools/extract-relationships.ts`
  </verify>
  <done>
- ExtractRelationshipsToolDefinition exported with text, create_missing_nodes, min_confidence params
- handleExtractRelationships validates input and calls discoverRelationships service
- Response includes extraction results with entity and relationship details
- Tool registered in TOOL_DEFINITIONS and TOOL_HANDLERS
- AI can now trigger relationship extraction via MCP
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors
2. Extraction prompt enforces specific relationship types
3. Vague relationship types filtered in extractEntities
4. discoverRelationships links to existing nodes when possible
5. Relationship types validated against whitelist before Cypher execution
6. All queries use parameterized values (except validated relationship type)
7. MCP tool omnii_extract_relationships registered and callable
</verification>

<success_criteria>
- [ ] extractEntities uses GPT-4o-mini with quality extraction prompt
- [ ] Vague relationship types (RELATED_TO, etc.) are filtered out
- [ ] discoverRelationships matches existing nodes before creating new
- [ ] New nodes created with embeddings for vector search
- [ ] Relationship types validated against ALLOWED_RELATIONSHIPS whitelist
- [ ] sourceContext tracked for relationship provenance
- [ ] omnii_extract_relationships MCP tool callable by AI to trigger extraction
</success_criteria>

<output>
After completion, create `.planning/phases/03-graphrag-advanced-mcp/03-04-SUMMARY.md`
</output>
