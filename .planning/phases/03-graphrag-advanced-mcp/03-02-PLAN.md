---
phase: 03-graphrag-advanced-mcp
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/omnii_mcp/src/services/graphrag/dual-channel.ts
  - apps/omnii_mcp/src/services/graphrag/local-search.ts
  - apps/omnii_mcp/src/services/graphrag/index.ts
autonomous: true

must_haves:
  truths:
    - "Search combines vector similarity with graph traversal in single query flow"
    - "Related entities are discovered through 1-2 hop graph traversal"
    - "Results include both vector score and relationship context"
  artifacts:
    - path: "apps/omnii_mcp/src/services/graphrag/dual-channel.ts"
      provides: "Hybrid vector+graph retrieval combiner"
      exports: ["dualChannelSearch", "mergeChannelResults", "DualChannelResult"]
    - path: "apps/omnii_mcp/src/services/graphrag/local-search.ts"
      provides: "Entity-centric local search (GraphRAG pattern)"
      exports: ["localSearch", "LocalSearchOptions", "LocalSearchResult"]
  key_links:
    - from: "dual-channel.ts"
      to: "graph/operations/search.ts"
      via: "searchByText for vector channel"
      pattern: "searchByText"
    - from: "dual-channel.ts"
      to: "neo4j HTTP client"
      via: "graph traversal query"
      pattern: "MATCH.*-\\[r\\]-"
---

<objective>
Implement dual-channel retrieval combining vector search with graph traversal.

Purpose: Enable 67% better accuracy than vector-only RAG by combining semantic similarity (vector search) with structural context (graph traversal). This is the core GraphRAG pattern that makes the knowledge graph valuable.

Output: Dual-channel search service that finds semantically similar nodes and expands context via graph relationships
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-graphrag-advanced-mcp/03-RESEARCH.md

# Phase 2 foundation - vector search
@apps/omnii_mcp/src/graph/operations/search.ts
@apps/omnii_mcp/src/graph/operations/embeddings.ts
@apps/omnii_mcp/src/services/neo4j/http-client.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create dual-channel retrieval service</name>
  <files>
    apps/omnii_mcp/src/services/graphrag/dual-channel.ts
  </files>
  <action>
Create `apps/omnii_mcp/src/services/graphrag/dual-channel.ts` implementing the HybridCypherRetriever pattern:

1. **DualChannelResult interface**:
   ```typescript
   export interface DualChannelResult {
     entity: {
       id: string;
       name: string;
       type: string;
       properties: Record<string, unknown>;
     };
     vectorScore: number;
     relatedEntities: Array<{
       id: string;
       name: string;
       type: string;
       relationshipType: string;
       hopDistance: number;
     }>;
     relationships: Array<{
       type: string;
       direction: 'outgoing' | 'incoming';
       properties: Record<string, unknown>;
     }>;
   }
   ```

2. **dualChannelSearch function**:
   - Input: `client: Neo4jClient, query: string, userId: string, options?: { limit?: number, maxDepth?: number, minScore?: number, nodeTypes?: string[] }`
   - Default options: `limit: 10, maxDepth: 2, minScore: 0.7`

   Implementation steps:
   a. Generate embedding for query using `generateEmbedding` from embeddings.ts
   b. Execute combined Cypher query that:
      - Calls `db.index.vector.queryNodes` for initial candidates (get 2x limit for filtering)
      - Filters by user_id
      - Uses CALL subquery for graph traversal (1-2 hops)
      - Collects neighbors and relationships
      - Returns combined results ordered by vector score

   Use this Cypher pattern (from research):
   ```cypher
   CALL db.index.vector.queryNodes('entity_embeddings', $candidateLimit, $embedding)
   YIELD node, score
   WHERE node.user_id = $userId AND score >= $minScore
   CALL {
     WITH node
     MATCH (node)-[r1]-(neighbor1)
     WHERE neighbor1.user_id = $userId
     OPTIONAL MATCH (neighbor1)-[r2]-(neighbor2)
     WHERE neighbor2.user_id = $userId AND neighbor2 <> node
     RETURN collect(DISTINCT {node: neighbor1, rel: r1, hop: 1}) +
            collect(DISTINCT {node: neighbor2, rel: r2, hop: 2}) AS neighbors
   }
   RETURN node, score, neighbors
   ORDER BY score DESC
   LIMIT $limit
   ```

3. **mergeChannelResults function** (internal helper):
   - Combines vector results with graph context
   - Deduplicates related entities
   - Excludes embedding field from properties (too large for responses)

IMPORTANT: Always specify max depth bounds (1..2) in variable-length patterns to prevent exponential path explosion.
  </action>
  <verify>
Run TypeScript compilation: `cd apps/omnii_mcp && bunx tsc --noEmit`

Check for unbounded traversal: `grep -E "\\*\\]|\\*[0-9]*\\.\\.\\]" apps/omnii_mcp/src/services/graphrag/dual-channel.ts` (should return nothing - all patterns must have upper bound)
  </verify>
  <done>
- DualChannelResult type exported with entity, vectorScore, relatedEntities, relationships
- dualChannelSearch combines vector search + graph traversal in single flow
- maxDepth defaults to 2, preventing unbounded traversal
- Results include hop distance for related entities
  </done>
</task>

<task type="auto">
  <name>Task 2: Create local search service wrapper</name>
  <files>
    apps/omnii_mcp/src/services/graphrag/local-search.ts
    apps/omnii_mcp/src/services/graphrag/index.ts
  </files>
  <action>
Create `apps/omnii_mcp/src/services/graphrag/local-search.ts` as the primary GraphRAG search interface:

1. **LocalSearchOptions interface**:
   ```typescript
   export interface LocalSearchOptions {
     limit?: number;           // Default: 10
     maxDepth?: number;        // Default: 2
     minScore?: number;        // Default: 0.7
     nodeTypes?: NodeLabel[];  // Filter by node type
     timeRange?: string;       // Optional temporal filter (e.g., "last week")
     includeContext?: boolean; // Default: true - include related entities
   }
   ```

2. **LocalSearchResult interface**:
   ```typescript
   export interface LocalSearchResult {
     query: string;
     totalResults: number;
     results: DualChannelResult[];
     searchMetadata: {
       vectorSearchTime: number;
       graphTraversalTime: number;
       totalTime: number;
     };
   }
   ```

3. **localSearch function**:
   - Input: `client: Neo4jClient, query: string, userId: string, options?: LocalSearchOptions`
   - Primary interface for entity-centric queries
   - Calls `dualChannelSearch` internally
   - If `includeContext: false`, skip graph traversal (vector-only mode)
   - If `timeRange` provided, add temporal filter to Cypher query
   - Returns results with timing metadata

4. Update `apps/omnii_mcp/src/services/graphrag/index.ts` to export:
   ```typescript
   export * from './temporal-context';
   export * from './dual-channel';
   export * from './local-search';
   ```

NOTE: This is "local search" in GraphRAG terminology (entity-centric), not "global search" (corpus-wide). Global search is deferred to later phases per research recommendation.
  </action>
  <verify>
Run TypeScript compilation: `cd apps/omnii_mcp && bunx tsc --noEmit`

Verify exports: `grep "export" apps/omnii_mcp/src/services/graphrag/index.ts`
  </verify>
  <done>
- LocalSearchOptions and LocalSearchResult types exported
- localSearch function provides simplified interface to dual-channel retrieval
- Timing metadata included for performance monitoring
- Graph context optional via includeContext flag
- Temporal filtering supported via timeRange option
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors
2. No unbounded graph traversal patterns (all have depth limits)
3. dualChannelSearch combines vector + graph in single query
4. localSearch provides clean interface with timing metadata
5. All queries filter by user_id for multi-tenant isolation
</verification>

<success_criteria>
- [ ] dualChannelSearch executes combined vector+graph query
- [ ] Graph traversal limited to 1-2 hops maximum
- [ ] Results include vectorScore and relatedEntities with hop distance
- [ ] localSearch returns results with search timing metadata
- [ ] All Cypher queries parameterized and filter by user_id
</success_criteria>

<output>
After completion, create `.planning/phases/03-graphrag-advanced-mcp/03-02-SUMMARY.md`
</output>
