---
phase: 03-graphrag-advanced-mcp
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/omnii_mcp/src/services/graphrag/temporal-context.ts
  - apps/omnii_mcp/src/services/graphrag/index.ts
autonomous: true

must_haves:
  truths:
    - "Time-based queries like 'last week' resolve to correct Neo4j date ranges"
    - "Temporal filtering works with all node types (Entity, Event, Contact, Concept)"
    - "Query results include age/recency information for context"
  artifacts:
    - path: "apps/omnii_mcp/src/services/graphrag/temporal-context.ts"
      provides: "Temporal query utilities with duration mapping"
      exports: ["TEMPORAL_DURATIONS", "parseTemporalQuery", "queryTemporalNodes", "queryTemporalEvents"]
    - path: "apps/omnii_mcp/src/services/graphrag/index.ts"
      provides: "GraphRAG service barrel export"
      exports: ["temporal-context exports"]
  key_links:
    - from: "temporal-context.ts"
      to: "neo4j HTTP client"
      via: "executeQuery with duration parameters"
      pattern: "executeQuery.*duration"
---

<objective>
Implement temporal context awareness for time-based graph queries.

Purpose: Enable natural language time queries ("last week", "this month") that filter graph data by created_at/start_time timestamps, providing temporal awareness for AI assistants querying user's personal context.

Output: Temporal query service with duration mapping and Neo4j datetime arithmetic
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-graphrag-advanced-mcp/03-RESEARCH.md

# Phase 2 foundation
@apps/omnii_mcp/src/graph/operations/search.ts
@apps/omnii_mcp/src/services/neo4j/http-client.ts
@apps/omnii_mcp/src/graph/schema/nodes.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create temporal context service</name>
  <files>
    apps/omnii_mcp/src/services/graphrag/temporal-context.ts
    apps/omnii_mcp/src/services/graphrag/index.ts
  </files>
  <action>
Create `apps/omnii_mcp/src/services/graphrag/temporal-context.ts` with:

1. **TEMPORAL_DURATIONS constant** - Map of natural language to ISO 8601 durations:
   ```typescript
   export const TEMPORAL_DURATIONS: Record<string, string> = {
     "today": "P0D",
     "yesterday": "P1D",
     "last week": "P7D",
     "this week": "P7D",
     "last month": "P1M",
     "this month": "P1M",
     "last year": "P1Y",
     "this year": "P1Y"
   };
   ```

2. **parseTemporalQuery function** - Validates and returns duration string:
   - Input: `timeRange: string` (e.g., "last week")
   - Output: `{ duration: string, startTime: 'now-duration', endTime: 'now' }` or throw error with valid options
   - Case-insensitive matching

3. **queryTemporalNodes function** - Query nodes by time range:
   - Input: `client: Neo4jClient, userId: string, timeRange: string, options?: { nodeTypes?: NodeLabel[], limit?: number }`
   - Uses Cypher with `datetime() - duration($duration)` for range calculation
   - Returns nodes with `age` field showing `duration.between(created_at, datetime())`
   - Filter by user_id for multi-tenant isolation
   - Default limit: 50

4. **queryTemporalEvents function** - Specialized for Event nodes with start_time/end_time:
   - Input: `client: Neo4jClient, userId: string, timeRange: string, options?: { eventType?: string, includeRelated?: boolean }`
   - Query Event nodes by start_time within time range
   - If includeRelated=true, OPTIONAL MATCH to related Entity and Contact nodes
   - Return events with associated entities/contacts

Create `apps/omnii_mcp/src/services/graphrag/index.ts` as barrel export:
```typescript
export * from './temporal-context';
```

Use Neo4j datetime() function (timezone-aware) not localdatetime(). Store all times as UTC.
  </action>
  <verify>
Run TypeScript compilation: `cd apps/omnii_mcp && bun run build` (or `bunx tsc --noEmit`)

Verify exports: `grep -r "export" apps/omnii_mcp/src/services/graphrag/`
  </verify>
  <done>
- TEMPORAL_DURATIONS exported with 8 time range mappings
- parseTemporalQuery validates input and returns duration config
- queryTemporalNodes returns nodes within time range with age field
- queryTemporalEvents returns events with optional related entities
- All functions use parameterized Cypher queries (no injection risk)
  </done>
</task>

<task type="auto">
  <name>Task 2: Add temporal index for query performance</name>
  <files>
    apps/omnii_mcp/src/graph/schema/constraints.ts
  </files>
  <action>
Update `apps/omnii_mcp/src/graph/schema/constraints.ts` to add temporal index:

Add a new function `createTemporalIndex`:
```typescript
export async function createTemporalIndex(client: Neo4jClient): Promise<void> {
  // Index on created_at for all node types that support temporal queries
  const indexQueries = [
    `CREATE INDEX entity_created_at IF NOT EXISTS FOR (n:Entity) ON (n.created_at)`,
    `CREATE INDEX event_start_time IF NOT EXISTS FOR (n:Event) ON (n.start_time)`,
    `CREATE INDEX contact_created_at IF NOT EXISTS FOR (n:Contact) ON (n.created_at)`,
    `CREATE INDEX concept_created_at IF NOT EXISTS FOR (n:Concept) ON (n.created_at)`
  ];

  for (const query of indexQueries) {
    await client.executeQuery(query);
  }
}
```

Export the function from constraints.ts and add to the schema setup flow by updating `setupSchema` function to call `createTemporalIndex` after constraints.

This improves temporal query performance from O(n) scan to O(log n) index lookup.
  </action>
  <verify>
Run TypeScript compilation: `cd apps/omnii_mcp && bunx tsc --noEmit`

Check export: `grep "createTemporalIndex" apps/omnii_mcp/src/graph/schema/constraints.ts`
  </verify>
  <done>
- createTemporalIndex function creates 4 indexes (Entity, Event, Contact, Concept)
- Indexes use IF NOT EXISTS for idempotency
- setupSchema calls createTemporalIndex during user database provisioning
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors
2. TEMPORAL_DURATIONS has all 8 time range mappings
3. parseTemporalQuery throws descriptive error for invalid input
4. queryTemporalNodes and queryTemporalEvents use parameterized queries
5. Temporal indexes defined for all node types with timestamp fields
</verification>

<success_criteria>
- [ ] Temporal service exports TEMPORAL_DURATIONS, parseTemporalQuery, queryTemporalNodes, queryTemporalEvents
- [ ] Duration mapping covers: today, yesterday, last week, this week, last month, this month, last year, this year
- [ ] Queries use Neo4j datetime() with duration arithmetic
- [ ] Temporal indexes added to schema setup
- [ ] All Cypher queries are parameterized (no string interpolation)
</success_criteria>

<output>
After completion, create `.planning/phases/03-graphrag-advanced-mcp/03-01-SUMMARY.md`
</output>
