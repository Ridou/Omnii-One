---
phase: 03-graphrag-advanced-mcp
plan: 05
type: execute
wave: 3
depends_on: ["03-03"]
files_modified:
  - apps/omnii_mcp/src/mcp/adapters/openai.ts
  - apps/omnii_mcp/src/mcp/adapters/index.ts
  - apps/omnii_mcp/src/routes/openai.ts
  - apps/omnii_mcp/src/app.ts
autonomous: true

user_setup:
  - service: openai
    why: "Function calling for MCP tool invocation"
    env_vars:
      - name: OPENAI_API_KEY
        source: "Already configured for embeddings - no new setup needed"

must_haves:
  truths:
    - "OpenAI Chat API can invoke MCP tools via function calling"
    - "MCP tool schemas are correctly converted to OpenAI function format"
    - "Tool results are returned to OpenAI in correct message format"
    - "Parallel tool calls are supported when multiple tools requested"
  artifacts:
    - path: "apps/omnii_mcp/src/mcp/adapters/openai.ts"
      provides: "OpenAI function calling adapter for MCP tools"
      exports: ["convertMCPToolToOpenAI", "handleOpenAIToolCalls", "OpenAIToolAdapter"]
    - path: "apps/omnii_mcp/src/routes/openai.ts"
      provides: "HTTP endpoint for OpenAI-compatible requests"
      exports: ["openaiRoutes"]
  key_links:
    - from: "adapters/openai.ts"
      to: "mcp/tools/index.ts"
      via: "TOOL_DEFINITIONS for schema conversion"
      pattern: "TOOL_DEFINITIONS"
    - from: "routes/openai.ts"
      to: "adapters/openai.ts"
      via: "handleOpenAIToolCalls"
      pattern: "handleOpenAIToolCalls"
---

<objective>
Implement OpenAI function calling integration for MCP tools.

Purpose: Enable OpenAI models (GPT-4o, etc.) to invoke MCP tools via their native function calling mechanism, expanding the knowledge graph beyond Claude Desktop to OpenAI-powered applications.

Output: OpenAI adapter that converts MCP tools to OpenAI functions and handles tool call execution
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-graphrag-advanced-mcp/03-RESEARCH.md

# MCP tools to expose
@apps/omnii_mcp/src/mcp/tools/index.ts

# Auth middleware for user context
@apps/omnii_mcp/src/routes/auth.ts

# App for route registration
@apps/omnii_mcp/src/app.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create OpenAI function calling adapter</name>
  <files>
    apps/omnii_mcp/src/mcp/adapters/openai.ts
    apps/omnii_mcp/src/mcp/adapters/index.ts
  </files>
  <action>
Create `apps/omnii_mcp/src/mcp/adapters/openai.ts`:

1. **Type definitions**:
   ```typescript
   export interface OpenAITool {
     type: 'function';
     function: {
       name: string;
       description: string;
       parameters: {
         type: 'object';
         properties: Record<string, unknown>;
         required?: string[];
         additionalProperties: false;
       };
       strict: true;  // Enable Structured Outputs
     };
   }

   export interface OpenAIToolCall {
     id: string;
     type: 'function';
     function: {
       name: string;
       arguments: string;  // JSON string
     };
   }

   export interface OpenAIToolResult {
     tool_call_id: string;
     role: 'tool';
     name: string;
     content: string;
   }
   ```

2. **convertMCPToolToOpenAI function**:
   ```typescript
   export function convertMCPToolToOpenAI(mcpTool: MCPToolDefinition): OpenAITool
   ```
   - Map MCP inputSchema to OpenAI parameters format
   - Set `strict: true` for Structured Outputs compliance
   - Set `additionalProperties: false` as required by OpenAI strict mode
   - Return OpenAI function tool format

3. **getAllToolsForOpenAI function**:
   ```typescript
   export function getAllToolsForOpenAI(): OpenAITool[]
   ```
   - Import TOOL_DEFINITIONS from mcp/tools
   - Map all MCP tools to OpenAI format
   - Return array of OpenAI tools

4. **handleOpenAIToolCalls function**:
   ```typescript
   export async function handleOpenAIToolCalls(
     toolCalls: OpenAIToolCall[],
     context: { userId: string; client: Neo4jClient }
   ): Promise<OpenAIToolResult[]>
   ```
   - Use Promise.all for parallel execution (per OpenAI recommendation)
   - For each tool call:
     - Parse function.arguments JSON
     - Get handler from TOOL_HANDLERS
     - Execute handler with parsed arguments and context
     - Convert MCPToolResponse to OpenAI tool result format
   - Return array of tool results

5. **OpenAIToolAdapter class** (optional convenience wrapper):
   ```typescript
   export class OpenAIToolAdapter {
     constructor(private context: { userId: string; client: Neo4jClient }) {}

     getTools(): OpenAITool[]
     async executeToolCalls(toolCalls: OpenAIToolCall[]): Promise<OpenAIToolResult[]>
   }
   ```

Create `apps/omnii_mcp/src/mcp/adapters/index.ts`:
```typescript
export * from './openai';
```
  </action>
  <verify>
Run TypeScript compilation: `cd apps/omnii_mcp && bunx tsc --noEmit`

Check exports: `grep "export" apps/omnii_mcp/src/mcp/adapters/openai.ts`
  </verify>
  <done>
- OpenAITool type matches OpenAI function calling schema
- convertMCPToolToOpenAI converts MCP tools with strict: true
- getAllToolsForOpenAI returns all MCP tools in OpenAI format
- handleOpenAIToolCalls executes tools in parallel
- Tool results formatted with tool_call_id for OpenAI correlation
  </done>
</task>

<task type="auto">
  <name>Task 2: Create OpenAI-compatible HTTP endpoint</name>
  <files>
    apps/omnii_mcp/src/routes/openai.ts
    apps/omnii_mcp/src/app.ts
  </files>
  <action>
Create `apps/omnii_mcp/src/routes/openai.ts`:

1. **Route definition** using Elysia:
   ```typescript
   import { Elysia, t } from 'elysia';
   import { getAllToolsForOpenAI, handleOpenAIToolCalls } from '../mcp/adapters/openai';

   export const openaiRoutes = new Elysia({ prefix: '/api/openai' })
   ```

2. **GET /api/openai/tools** - Return available tools:
   ```typescript
   .get('/tools', () => {
     return {
       tools: getAllToolsForOpenAI(),
       version: '1.0.0'
     };
   })
   ```
   - Returns list of OpenAI-formatted tools for client integration
   - Clients can use this to configure their OpenAI calls

3. **POST /api/openai/execute-tools** - Execute tool calls:
   ```typescript
   .post('/execute-tools', async ({ body, store }) => {
     const { tool_calls } = body;
     const { userId, neo4jClient } = store;

     const results = await handleOpenAIToolCalls(tool_calls, {
       userId,
       client: neo4jClient
     });

     return { results };
   }, {
     body: t.Object({
       tool_calls: t.Array(t.Object({
         id: t.String(),
         type: t.Literal('function'),
         function: t.Object({
           name: t.String(),
           arguments: t.String()
         })
       }))
     })
   })
   ```
   - Accepts OpenAI tool_calls format directly
   - Returns results ready to send back to OpenAI API
   - Requires authentication (userId from auth middleware)

4. **Apply auth middleware** to routes that need user context (execute-tools)

5. **Update app.ts**:
   - Import openaiRoutes
   - Add to app: `app.use(openaiRoutes)`
   - Position after auth middleware

Note: This is NOT a full OpenAI API proxy. It provides endpoints for:
- Listing available tools (for client configuration)
- Executing tool calls (when client receives tool_calls from OpenAI)

The client is responsible for:
- Calling OpenAI API with tools
- Receiving tool_calls from OpenAI
- Calling our execute-tools endpoint
- Sending results back to OpenAI
  </action>
  <verify>
Run TypeScript compilation: `cd apps/omnii_mcp && bunx tsc --noEmit`

Check route registration: `grep "openaiRoutes" apps/omnii_mcp/src/app.ts`

Test endpoint availability: Start server and check `curl http://localhost:3000/api/openai/tools`
  </verify>
  <done>
- GET /api/openai/tools returns all MCP tools in OpenAI format
- POST /api/openai/execute-tools accepts OpenAI tool_calls and returns results
- Auth middleware applied to execute-tools endpoint
- Routes registered in app.ts
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors
2. All MCP tools converted to OpenAI format with strict: true
3. Tool calls executed in parallel via Promise.all
4. Results include tool_call_id for OpenAI correlation
5. Routes protected by authentication
6. GET /api/openai/tools accessible and returns tool list
</verification>

<success_criteria>
- [ ] convertMCPToolToOpenAI produces valid OpenAI function schema with strict: true
- [ ] getAllToolsForOpenAI returns all 6 MCP tools in OpenAI format
- [ ] handleOpenAIToolCalls executes tools in parallel
- [ ] POST /api/openai/execute-tools accepts tool_calls and returns results
- [ ] Authentication required for tool execution
</success_criteria>

<output>
After completion, create `.planning/phases/03-graphrag-advanced-mcp/03-05-SUMMARY.md`
</output>
