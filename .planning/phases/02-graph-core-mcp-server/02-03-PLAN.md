---
phase: 02-graph-core-mcp-server
plan: 03
type: execute
wave: 3
depends_on: ["02-01", "02-02"]
files_modified:
  - apps/omnii_mcp/src/mcp/server.ts
  - apps/omnii_mcp/src/mcp/capabilities.ts
  - apps/omnii_mcp/src/mcp/transport.ts
  - apps/omnii_mcp/src/mcp/index.ts
autonomous: true

must_haves:
  truths:
    - "MCP server initializes with proper capability declaration"
    - "Server handles initialize/initialized handshake correctly"
    - "Streamable HTTP transport is configured (not deprecated SSE)"
    - "Server declares tools capability"
  artifacts:
    - path: "apps/omnii_mcp/src/mcp/server.ts"
      provides: "MCP server initialization"
      exports: ["createMCPServer", "mcpServer"]
    - path: "apps/omnii_mcp/src/mcp/capabilities.ts"
      provides: "Server capability declaration"
      exports: ["SERVER_CAPABILITIES", "SERVER_INFO"]
    - path: "apps/omnii_mcp/src/mcp/transport.ts"
      provides: "HTTP transport configuration"
      exports: ["createHTTPTransport"]
  key_links:
    - from: "apps/omnii_mcp/src/mcp/server.ts"
      to: "@modelcontextprotocol/sdk"
      via: "McpServer class"
      pattern: "new.*McpServer\\|Server"
    - from: "apps/omnii_mcp/src/mcp/transport.ts"
      to: "@modelcontextprotocol/sdk"
      via: "StreamableHTTPServerTransport"
      pattern: "StreamableHTTP"
---

<objective>
Create the MCP server core with proper protocol compliance and transport layer.

Purpose: Establish MCP protocol foundation that Claude Desktop and other clients can connect to. The server must complete the three-step handshake (initialize request -> response -> initialized notification) before accepting tool calls.

Output: MCP server module with capability negotiation, Streamable HTTP transport, and proper initialization handling.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-graph-core-mcp-server/02-RESEARCH.md

# From prior plans
@apps/omnii_mcp/src/graph/index.ts

# MCP SDK reference (v1.12.0 installed)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define server capabilities and info</name>
  <files>apps/omnii_mcp/src/mcp/capabilities.ts</files>
  <action>
Create MCP server capability declarations:

1. Create `apps/omnii_mcp/src/mcp/capabilities.ts`:

Define server info constants:
```typescript
export const SERVER_INFO = {
  name: 'omnii-graph-server',
  version: '1.0.0',
  description: 'Personal context graph server for AI assistants'
} as const;
```

Define server capabilities:
```typescript
export const SERVER_CAPABILITIES = {
  tools: {},  // Declare tool support - tools registered separately
  // resources: {},  // Not implementing resources in Phase 2
  // prompts: {},    // Not implementing prompts in Phase 2
} as const;
```

Define protocol version supported:
```typescript
export const SUPPORTED_PROTOCOL_VERSIONS = ['2025-11-25'] as const;
export const DEFAULT_PROTOCOL_VERSION = '2025-11-25';
```

Note: Using protocol 2025-11-25 per research (stable version).
Do NOT use protocol 2026-03-26 features yet (Streamable HTTP transport is available in SDK v1.x).

Export all constants.
  </action>
  <verify>
TypeScript compilation:
```bash
cd apps/omnii_mcp && npx tsc --noEmit src/mcp/capabilities.ts
```

Check exports:
```bash
cd apps/omnii_mcp && bun -e "import { SERVER_INFO, SERVER_CAPABILITIES } from './src/mcp/capabilities'; console.log('Server:', SERVER_INFO.name, SERVER_INFO.version);"
```
Should output: Server: omnii-graph-server 1.0.0
  </verify>
  <done>
Server capabilities module exists with SERVER_INFO, SERVER_CAPABILITIES, and protocol version constants.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create MCP server with initialization handling</name>
  <files>apps/omnii_mcp/src/mcp/server.ts</files>
  <action>
Create the MCP server using @modelcontextprotocol/sdk:

1. Create `apps/omnii_mcp/src/mcp/server.ts`:

Import from SDK:
```typescript
import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { SERVER_INFO, SERVER_CAPABILITIES, DEFAULT_PROTOCOL_VERSION } from './capabilities';
```

Create server factory function:
```typescript
export function createMCPServer() {
  const server = new Server(
    SERVER_INFO,
    {
      capabilities: SERVER_CAPABILITIES
    }
  );

  // Track initialization state
  let isInitialized = false;

  // The SDK handles initialize/initialized automatically
  // but we track state for our own logging/debugging

  server.oninitialized = () => {
    isInitialized = true;
    console.log('[MCP] Server initialized, ready for tool calls');
  };

  server.onerror = (error) => {
    console.error('[MCP] Server error:', error);
  };

  return {
    server,
    isInitialized: () => isInitialized
  };
}
```

Create singleton instance for the app:
```typescript
let _mcpServer: ReturnType<typeof createMCPServer> | null = null;

export function getMCPServer() {
  if (!_mcpServer) {
    _mcpServer = createMCPServer();
  }
  return _mcpServer;
}

// For testing - reset server
export function resetMCPServer() {
  _mcpServer = null;
}
```

Export server and factory.

Note: The SDK v1.x Server class handles the three-step handshake automatically. We just need to:
1. Create server with capabilities
2. Connect to transport (next task)
3. Register tool handlers (Plan 04)
  </action>
  <verify>
TypeScript compilation:
```bash
cd apps/omnii_mcp && npx tsc --noEmit src/mcp/server.ts
```

Check server creation:
```bash
cd apps/omnii_mcp && bun -e "import { createMCPServer } from './src/mcp/server'; const { server } = createMCPServer(); console.log('Server created:', typeof server);"
```
Should output: Server created: object
  </verify>
  <done>
MCP server module exists. createMCPServer factory creates properly configured Server instance. Initialization state tracked. Singleton pattern available via getMCPServer.
  </done>
</task>

<task type="auto">
  <name>Task 3: Configure HTTP transport and create index</name>
  <files>
    apps/omnii_mcp/src/mcp/transport.ts
    apps/omnii_mcp/src/mcp/index.ts
  </files>
  <action>
Create HTTP transport configuration and module index:

1. Create `apps/omnii_mcp/src/mcp/transport.ts`:

The @modelcontextprotocol/sdk provides StreamableHTTPServerTransport. However, for Elysia integration, we need to create a custom approach since the SDK transport expects Express-like middleware.

Strategy: Create an Elysia route handler that bridges to MCP server.

```typescript
import { Elysia } from 'elysia';
import { getMCPServer } from './server';

/**
 * MCP HTTP Transport for Elysia
 *
 * Handles JSON-RPC 2.0 messages over HTTP POST.
 * MCP clients send requests to /mcp endpoint.
 */
export function createMCPRoutes() {
  const app = new Elysia({ prefix: '/mcp' });

  // Health check for MCP endpoint
  app.get('/health', () => {
    const { isInitialized } = getMCPServer();
    return {
      status: 'ok',
      initialized: isInitialized(),
      server: 'omnii-graph-server',
      version: '1.0.0'
    };
  });

  // Main MCP message handler
  // Note: Full JSON-RPC handling will be wired in Plan 05 with auth
  app.post('/', async ({ body, set }) => {
    // Placeholder - will be implemented with auth in Plan 05
    // For now, return method not implemented
    set.status = 501;
    return {
      jsonrpc: '2.0',
      error: {
        code: -32601,
        message: 'MCP endpoint not yet wired - see Plan 05'
      },
      id: (body as any)?.id ?? null
    };
  });

  return app;
}

export type MCPRoutes = ReturnType<typeof createMCPRoutes>;
```

Note: We're NOT using StreamableHTTPServerTransport directly because:
1. It expects Express middleware patterns
2. We need custom auth integration (Plan 05)
3. We'll handle the JSON-RPC layer ourselves for better control

The actual message handling will be completed in Plan 05 when auth is integrated.

2. Create `apps/omnii_mcp/src/mcp/index.ts`:
```typescript
// MCP Server module
export { SERVER_INFO, SERVER_CAPABILITIES, DEFAULT_PROTOCOL_VERSION } from './capabilities';
export { createMCPServer, getMCPServer, resetMCPServer } from './server';
export { createMCPRoutes, type MCPRoutes } from './transport';
```
  </action>
  <verify>
TypeScript compilation:
```bash
cd apps/omnii_mcp && npx tsc --noEmit src/mcp/index.ts
```

Test route creation:
```bash
cd apps/omnii_mcp && bun -e "
import { createMCPRoutes, getMCPServer } from './src/mcp';
const routes = createMCPRoutes();
const { server } = getMCPServer();
console.log('MCP routes created');
console.log('Server ready');
"
```
  </verify>
  <done>
MCP transport module exists with Elysia route handler. Module index exports all MCP components. Routes are ready to be integrated into main app.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Full module compilation:
```bash
cd apps/omnii_mcp && npx tsc --noEmit src/mcp/index.ts
```

2. Directory structure:
```bash
ls -la apps/omnii_mcp/src/mcp/
```
Should show: capabilities.ts, server.ts, transport.ts, index.ts

3. Export verification:
```bash
cd apps/omnii_mcp && bun -e "
import { SERVER_INFO, createMCPServer, createMCPRoutes } from './src/mcp';
console.log('Server name:', SERVER_INFO.name);
console.log('Exports verified');
"
```
</verification>

<success_criteria>
- MCP module directory exists at apps/omnii_mcp/src/mcp/
- Server capabilities declare tools support
- createMCPServer creates properly configured Server instance
- Initialization state tracking works
- Elysia routes created for /mcp endpoint with health check
- All code compiles without TypeScript errors
- Module exports all necessary components
</success_criteria>

<output>
After completion, create `.planning/phases/02-graph-core-mcp-server/02-03-SUMMARY.md`
</output>
