---
phase: 02-graph-core-mcp-server
plan: 05
type: execute
wave: 4
depends_on: ["02-03", "02-04"]
files_modified:
  - apps/omnii_mcp/src/middleware/rate-limit.ts
  - apps/omnii_mcp/src/mcp/transport.ts
  - apps/omnii_mcp/src/routes/index.ts
  - apps/omnii_mcp/package.json
autonomous: true

must_haves:
  truths:
    - "MCP requests require valid Bearer token authentication"
    - "Rate limiting prevents abuse (100 requests/minute per user)"
    - "MCP tools execute with user-isolated database connections"
    - "Unauthenticated requests return 401 error"
    - "Rate-limited requests return 429 error"
  artifacts:
    - path: "apps/omnii_mcp/src/middleware/rate-limit.ts"
      provides: "Token bucket rate limiting middleware"
      exports: ["mcpRateLimiter", "createRateLimiter"]
    - path: "apps/omnii_mcp/src/mcp/transport.ts"
      provides: "Complete MCP transport with auth and rate limiting"
      exports: ["createMCPRoutes"]
  key_links:
    - from: "apps/omnii_mcp/src/mcp/transport.ts"
      to: "apps/omnii_mcp/src/services/neo4j/http-client.ts"
      via: "createClientForUser()"
      pattern: "createClientForUser"
    - from: "apps/omnii_mcp/src/mcp/transport.ts"
      to: "@omnii/auth"
      via: "Supabase getUser()"
      pattern: "getUser|supabase.*auth"
---

<objective>
Wire MCP server with authentication, rate limiting, and route integration.

Purpose: Complete the MCP server by adding security (auth + rate limiting) and connecting it to the main Elysia app. After this plan, the /mcp endpoint will be fully functional.

Output: Rate limiting middleware, complete MCP transport with JSON-RPC handling, and integration into main routes.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-graph-core-mcp-server/02-RESEARCH.md

# From prior plans
@apps/omnii_mcp/src/mcp/server.ts
@apps/omnii_mcp/src/mcp/tools/index.ts
@apps/omnii_mcp/src/services/neo4j/http-client.ts
@apps/omnii_mcp/src/routes/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement rate limiting middleware</name>
  <files>
    apps/omnii_mcp/src/middleware/rate-limit.ts
    apps/omnii_mcp/package.json
  </files>
  <action>
Create token bucket rate limiter for MCP endpoints:

1. Install elysia-rate-limit:
```bash
cd apps/omnii_mcp && pnpm add elysia-rate-limit
```

2. Create `apps/omnii_mcp/src/middleware/rate-limit.ts`:

```typescript
import { rateLimit } from 'elysia-rate-limit';

/**
 * MCP Rate Limiter Configuration
 *
 * Token bucket algorithm:
 * - 100 requests per minute per user
 * - Allows burst up to bucket capacity
 * - Refills at steady rate
 */
export const MCP_RATE_LIMIT = {
  duration: 60000,      // 60 second window
  max: 100,             // 100 requests per minute
  errorResponse: {
    jsonrpc: '2.0',
    error: {
      code: -32000,
      message: 'Rate limit exceeded. Maximum 100 requests per minute.'
    },
    id: null
  }
} as const;

/**
 * Extract user ID from Authorization header for per-user rate limiting.
 * Falls back to IP address for unauthenticated requests.
 */
function extractRateLimitKey(request: Request): string {
  const authHeader = request.headers.get('authorization');

  if (authHeader?.startsWith('Bearer ')) {
    try {
      // Parse JWT to extract user ID without full verification
      // (Verification happens in auth middleware)
      const token = authHeader.substring(7);
      const payload = JSON.parse(atob(token.split('.')[1]));
      if (payload.sub) {
        return `user:${payload.sub}`;
      }
    } catch {
      // Invalid token format - fall through to IP-based limiting
    }
  }

  // Fallback to IP-based rate limiting for anonymous requests
  // Note: This is more restrictive since multiple users might share an IP
  return `ip:${request.headers.get('x-forwarded-for') || 'unknown'}`;
}

/**
 * Create rate limiter plugin for Elysia
 */
export function createRateLimiter() {
  return rateLimit({
    duration: MCP_RATE_LIMIT.duration,
    max: MCP_RATE_LIMIT.max,
    responseMessage: JSON.stringify(MCP_RATE_LIMIT.errorResponse),
    generator: (req) => extractRateLimitKey(req),
    // Don't count errors against rate limit
    countFailed: false,
    headers: true  // Include X-RateLimit-* headers
  });
}

// Pre-configured instance for MCP routes
export const mcpRateLimiter = createRateLimiter();
```
  </action>
  <verify>
Check package installation:
```bash
cd apps/omnii_mcp && grep "elysia-rate-limit" package.json
```

TypeScript compilation:
```bash
cd apps/omnii_mcp && npx tsc --noEmit src/middleware/rate-limit.ts
```

Test import:
```bash
cd apps/omnii_mcp && bun -e "import { mcpRateLimiter, MCP_RATE_LIMIT } from './src/middleware/rate-limit'; console.log('Rate limit:', MCP_RATE_LIMIT.max, 'per', MCP_RATE_LIMIT.duration/1000, 'seconds');"
```
  </verify>
  <done>
Rate limiting middleware exists with token bucket algorithm. Per-user limiting via JWT parsing. Fallback to IP-based limiting for anonymous requests.
  </done>
</task>

<task type="auto">
  <name>Task 2: Complete MCP transport with auth and tool routing</name>
  <files>apps/omnii_mcp/src/mcp/transport.ts</files>
  <action>
Update MCP transport to handle full JSON-RPC protocol with authentication:

Replace the placeholder in `apps/omnii_mcp/src/mcp/transport.ts`:

```typescript
import { Elysia } from 'elysia';
import { createSupabaseClient } from '@omnii/auth';
import { createClientForUser } from '../services/neo4j/http-client';
import { getMCPServer, SERVER_INFO } from './server';
import { TOOL_DEFINITIONS, getToolHandler } from './tools';
import { mcpRateLimiter } from '../middleware/rate-limit';

// JSON-RPC 2.0 types
interface JsonRpcRequest {
  jsonrpc: '2.0';
  method: string;
  params?: unknown;
  id?: string | number | null;
}

interface JsonRpcResponse {
  jsonrpc: '2.0';
  result?: unknown;
  error?: {
    code: number;
    message: string;
    data?: unknown;
  };
  id: string | number | null;
}

// Auth context
interface AuthContext {
  userId: string;
  tenantId: string;
}

/**
 * Authenticate request using Supabase JWT
 */
async function authenticateRequest(authHeader: string | null): Promise<AuthContext> {
  if (!authHeader?.startsWith('Bearer ')) {
    throw new Error('Missing or invalid authorization header');
  }

  const token = authHeader.substring(7);
  const supabase = createSupabaseClient();

  const { data: { user }, error } = await supabase.auth.getUser(token);

  if (error || !user) {
    throw new Error('Invalid or expired token');
  }

  return {
    userId: user.id,
    tenantId: user.id  // Database-per-user pattern
  };
}

/**
 * Handle MCP JSON-RPC methods
 */
async function handleMCPMethod(
  method: string,
  params: unknown,
  auth: AuthContext
): Promise<unknown> {
  const { server } = getMCPServer();

  switch (method) {
    case 'initialize': {
      // Return server capabilities
      return {
        protocolVersion: (params as any)?.protocolVersion || '2025-11-25',
        capabilities: {
          tools: {}
        },
        serverInfo: SERVER_INFO
      };
    }

    case 'notifications/initialized': {
      // Client acknowledging initialization - no response needed
      return null;
    }

    case 'tools/list': {
      // Return available tools
      return {
        tools: TOOL_DEFINITIONS
      };
    }

    case 'tools/call': {
      const { name, arguments: args } = params as { name: string; arguments?: unknown };

      const handler = getToolHandler(name);
      if (!handler) {
        throw { code: -32601, message: `Tool not found: ${name}` };
      }

      // Get user-specific database client
      const neo4jClient = await createClientForUser(auth.tenantId);

      // Execute tool
      return await handler(neo4jClient, args || {});
    }

    default:
      throw { code: -32601, message: `Method not found: ${method}` };
  }
}

/**
 * Create MCP routes for Elysia
 */
export function createMCPRoutes() {
  const app = new Elysia({ prefix: '/mcp' });

  // Apply rate limiting
  app.use(mcpRateLimiter);

  // Health check (no auth required)
  app.get('/health', () => {
    const { isInitialized } = getMCPServer();
    return {
      status: 'ok',
      initialized: isInitialized(),
      server: SERVER_INFO.name,
      version: SERVER_INFO.version,
      tools: TOOL_DEFINITIONS.length
    };
  });

  // Main MCP endpoint
  app.post('/', async ({ body, headers, set }): Promise<JsonRpcResponse> => {
    const request = body as JsonRpcRequest;
    const requestId = request?.id ?? null;

    // Validate JSON-RPC structure
    if (!request?.jsonrpc || request.jsonrpc !== '2.0' || !request.method) {
      set.status = 400;
      return {
        jsonrpc: '2.0',
        error: {
          code: -32600,
          message: 'Invalid JSON-RPC 2.0 request'
        },
        id: requestId
      };
    }

    // Authenticate (inline pattern per Phase 1 decision)
    let auth: AuthContext;
    try {
      auth = await authenticateRequest(headers.authorization || null);
    } catch (error) {
      set.status = 401;
      return {
        jsonrpc: '2.0',
        error: {
          code: -32000,
          message: error instanceof Error ? error.message : 'Authentication failed'
        },
        id: requestId
      };
    }

    // Handle method
    try {
      const result = await handleMCPMethod(request.method, request.params, auth);

      // Notifications don't get responses
      if (request.method.startsWith('notifications/')) {
        set.status = 204;
        return undefined as any;  // No content for notifications
      }

      return {
        jsonrpc: '2.0',
        result,
        id: requestId
      };
    } catch (error: any) {
      // Handle structured errors (from method handlers)
      if (error.code && error.message) {
        return {
          jsonrpc: '2.0',
          error: {
            code: error.code,
            message: error.message,
            data: error.data
          },
          id: requestId
        };
      }

      // Handle unexpected errors
      console.error('[MCP] Error handling request:', error);
      return {
        jsonrpc: '2.0',
        error: {
          code: -32603,
          message: error instanceof Error ? error.message : 'Internal error'
        },
        id: requestId
      };
    }
  });

  return app;
}

export type MCPRoutes = ReturnType<typeof createMCPRoutes>;
```
  </action>
  <verify>
TypeScript compilation:
```bash
cd apps/omnii_mcp && npx tsc --noEmit src/mcp/transport.ts
```

Test route creation:
```bash
cd apps/omnii_mcp && bun -e "import { createMCPRoutes } from './src/mcp/transport'; const routes = createMCPRoutes(); console.log('MCP routes created with auth and rate limiting');"
```
  </verify>
  <done>
MCP transport handles full JSON-RPC 2.0 protocol. Authentication via Supabase JWT. Rate limiting applied. Tool calls route to handlers with user-isolated database client.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate MCP routes into main app</name>
  <files>apps/omnii_mcp/src/routes/index.ts</files>
  <action>
Add MCP routes to the main Elysia router:

1. Read current `apps/omnii_mcp/src/routes/index.ts` and add MCP routes.

Add import at top:
```typescript
import { createMCPRoutes } from '../mcp/transport';
```

Add MCP routes to the router (alongside existing routes like auth, graph, etc.):
```typescript
// In the routes setup
.use(createMCPRoutes())
```

The exact location depends on the current file structure. Add it with the other route groups.

Also ensure the middleware directory is created if it doesn't exist:
```bash
mkdir -p apps/omnii_mcp/src/middleware
```

2. Verify the routes are wired by checking the app would start (won't actually run without env):
```bash
cd apps/omnii_mcp && bun --print "require('./src/routes')"
```
  </action>
  <verify>
Check routes file imports MCP:
```bash
cd apps/omnii_mcp && grep "createMCPRoutes" src/routes/index.ts
```

TypeScript compilation:
```bash
cd apps/omnii_mcp && npx tsc --noEmit src/routes/index.ts
```
  </verify>
  <done>
MCP routes integrated into main Elysia app. /mcp endpoint available when server starts.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Full compilation:
```bash
cd apps/omnii_mcp && npx tsc --noEmit
```

2. Check MCP module exports:
```bash
cd apps/omnii_mcp && bun -e "
import { createMCPRoutes, TOOL_DEFINITIONS, getMCPServer, SERVER_INFO } from './src/mcp';
import { mcpRateLimiter } from './src/middleware/rate-limit';
console.log('Server:', SERVER_INFO.name);
console.log('Tools:', TOOL_DEFINITIONS.length);
console.log('Rate limiter loaded:', typeof mcpRateLimiter);
"
```

3. Verify route integration:
```bash
cd apps/omnii_mcp && grep -n "mcp" src/routes/index.ts
```
</verification>

<success_criteria>
- elysia-rate-limit package installed
- Rate limiting middleware configured with 100 req/min per user
- MCP transport handles JSON-RPC 2.0 initialize, tools/list, tools/call methods
- Authentication via Supabase JWT with proper error codes
- Tool calls create user-isolated Neo4j clients via createClientForUser
- MCP routes integrated into main Elysia app
- All code compiles without TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-graph-core-mcp-server/02-05-SUMMARY.md`
</output>
