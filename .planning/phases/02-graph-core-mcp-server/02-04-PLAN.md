---
phase: 02-graph-core-mcp-server
plan: 04
type: execute
wave: 3
depends_on: ["02-02", "02-03"]
files_modified:
  - apps/omnii_mcp/src/mcp/tools/search-nodes.ts
  - apps/omnii_mcp/src/mcp/tools/get-context.ts
  - apps/omnii_mcp/src/mcp/tools/list-entities.ts
  - apps/omnii_mcp/src/mcp/tools/index.ts
autonomous: true

must_haves:
  truths:
    - "MCP tool 'omnii_graph_search_nodes' performs semantic search"
    - "MCP tool 'omnii_graph_get_context' retrieves node with relationships"
    - "MCP tool 'omnii_graph_list_entities' lists nodes by type"
    - "All tools have Zod input validation"
    - "All tools return structured JSON responses"
  artifacts:
    - path: "apps/omnii_mcp/src/mcp/tools/search-nodes.ts"
      provides: "Semantic search MCP tool"
      exports: ["searchNodesToolDefinition", "handleSearchNodes"]
    - path: "apps/omnii_mcp/src/mcp/tools/get-context.ts"
      provides: "Context retrieval MCP tool"
      exports: ["getContextToolDefinition", "handleGetContext"]
    - path: "apps/omnii_mcp/src/mcp/tools/list-entities.ts"
      provides: "Entity listing MCP tool"
      exports: ["listEntitiesToolDefinition", "handleListEntities"]
    - path: "apps/omnii_mcp/src/mcp/tools/index.ts"
      provides: "Tool registration and export"
      exports: ["TOOL_DEFINITIONS", "TOOL_HANDLERS", "registerTools"]
  key_links:
    - from: "apps/omnii_mcp/src/mcp/tools/search-nodes.ts"
      to: "apps/omnii_mcp/src/graph/operations/search.ts"
      via: "searchByText()"
      pattern: "searchByText"
    - from: "apps/omnii_mcp/src/mcp/tools/get-context.ts"
      to: "apps/omnii_mcp/src/graph/operations/crud.ts"
      via: "getNode()"
      pattern: "getNode"
    - from: "apps/omnii_mcp/src/mcp/tools/list-entities.ts"
      to: "apps/omnii_mcp/src/graph/operations/crud.ts"
      via: "getNodesByLabel()"
      pattern: "getNodesByLabel"
---

<objective>
Implement the three basic MCP tools for graph queries: search_nodes, get_context, and list_entities.

Purpose: These are the core tools that AI assistants will use to query user data. They bridge the MCP protocol to the graph operations created in Plans 01-02.

Output: Three MCP tool definitions with Zod schemas, handler functions, and a registration module.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-graph-core-mcp-server/02-RESEARCH.md

# From prior plans
@apps/omnii_mcp/src/graph/index.ts
@apps/omnii_mcp/src/mcp/server.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement search_nodes tool</name>
  <files>apps/omnii_mcp/src/mcp/tools/search-nodes.ts</files>
  <action>
Create the semantic search MCP tool:

1. Create `apps/omnii_mcp/src/mcp/tools/search-nodes.ts`:

Import dependencies:
```typescript
import { z } from 'zod';
import { searchByText, NodeLabel } from '../../graph';
import type { Neo4jHTTPClient } from '../../services/neo4j/http-client';
```

Define input schema with Zod (descriptions are critical for LLM understanding):
```typescript
export const SearchNodesInputSchema = z.object({
  query: z.string()
    .min(1)
    .max(500)
    .describe('Natural language search query describing what to find'),
  limit: z.number()
    .int()
    .min(1)
    .max(50)
    .default(10)
    .describe('Maximum number of results to return'),
  nodeTypes: z.array(z.enum(['Concept', 'Entity', 'Event', 'Contact']))
    .optional()
    .describe('Filter results to specific node types'),
  minScore: z.number()
    .min(0)
    .max(1)
    .default(0.7)
    .describe('Minimum similarity score (0-1) for results')
});

export type SearchNodesInput = z.infer<typeof SearchNodesInputSchema>;
```

Define tool definition (for tools/list response):
```typescript
export const searchNodesToolDefinition = {
  name: 'omnii_graph_search_nodes',
  description: 'Search the user\'s personal knowledge graph using semantic similarity. ' +
    'Use this to find concepts, entities, events, or contacts that match a natural language query. ' +
    'Returns ranked results with similarity scores.',
  inputSchema: {
    type: 'object',
    properties: {
      query: {
        type: 'string',
        description: 'Natural language search query describing what to find'
      },
      limit: {
        type: 'number',
        description: 'Maximum number of results to return (1-50, default 10)'
      },
      nodeTypes: {
        type: 'array',
        items: { type: 'string', enum: ['Concept', 'Entity', 'Event', 'Contact'] },
        description: 'Filter results to specific node types'
      },
      minScore: {
        type: 'number',
        description: 'Minimum similarity score (0-1, default 0.7)'
      }
    },
    required: ['query']
  }
};
```

Implement handler function:
```typescript
export async function handleSearchNodes(
  client: Neo4jHTTPClient,
  input: unknown
): Promise<{ content: Array<{ type: 'text'; text: string }>; isError?: boolean }> {
  try {
    // Validate input
    const parsed = SearchNodesInputSchema.parse(input);

    // Execute search
    const results = await searchByText(client, parsed.query, {
      limit: parsed.limit,
      nodeTypes: parsed.nodeTypes?.map(t => t as NodeLabel),
      minScore: parsed.minScore
    });

    // Format response for MCP
    return {
      content: [{
        type: 'text',
        text: JSON.stringify({
          query: parsed.query,
          resultCount: results.length,
          results: results.map(r => ({
            id: r.id,
            name: r.name,
            type: r.labels[0],
            score: r.score.toFixed(3),
            properties: r.properties
          }))
        }, null, 2)
      }]
    };
  } catch (error) {
    const message = error instanceof Error ? error.message : 'Unknown error';
    return {
      content: [{
        type: 'text',
        text: JSON.stringify({ error: message })
      }],
      isError: true
    };
  }
}
```

Use 'omnii_graph_' prefix to avoid tool name collisions (per research pitfall).
  </action>
  <verify>
TypeScript compilation:
```bash
cd apps/omnii_mcp && npx tsc --noEmit src/mcp/tools/search-nodes.ts
```

Check exports:
```bash
cd apps/omnii_mcp && bun -e "import { searchNodesToolDefinition, SearchNodesInputSchema } from './src/mcp/tools/search-nodes'; console.log('Tool:', searchNodesToolDefinition.name);"
```
Should output: Tool: omnii_graph_search_nodes
  </verify>
  <done>
search_nodes tool implemented with Zod validation, proper MCP response format, and error handling.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement get_context and list_entities tools</name>
  <files>
    apps/omnii_mcp/src/mcp/tools/get-context.ts
    apps/omnii_mcp/src/mcp/tools/list-entities.ts
  </files>
  <action>
Create the remaining two MCP tools:

1. Create `apps/omnii_mcp/src/mcp/tools/get-context.ts`:

```typescript
import { z } from 'zod';
import { getNode, findRelatedNodes } from '../../graph';
import type { Neo4jHTTPClient } from '../../services/neo4j/http-client';

export const GetContextInputSchema = z.object({
  nodeId: z.string()
    .uuid()
    .describe('The unique ID of the node to get context for'),
  includeRelated: z.boolean()
    .default(true)
    .describe('Whether to include related nodes'),
  maxDepth: z.number()
    .int()
    .min(1)
    .max(3)
    .default(1)
    .describe('Maximum relationship depth to traverse (1-3)')
});

export type GetContextInput = z.infer<typeof GetContextInputSchema>;

export const getContextToolDefinition = {
  name: 'omnii_graph_get_context',
  description: 'Get detailed context about a specific node in the knowledge graph, ' +
    'including its properties and optionally related nodes. ' +
    'Use this after search_nodes to get full details about a result.',
  inputSchema: {
    type: 'object',
    properties: {
      nodeId: {
        type: 'string',
        description: 'The unique ID (UUID) of the node'
      },
      includeRelated: {
        type: 'boolean',
        description: 'Whether to include related nodes (default true)'
      },
      maxDepth: {
        type: 'number',
        description: 'Maximum relationship depth to traverse (1-3, default 1)'
      }
    },
    required: ['nodeId']
  }
};

export async function handleGetContext(
  client: Neo4jHTTPClient,
  input: unknown
): Promise<{ content: Array<{ type: 'text'; text: string }>; isError?: boolean }> {
  try {
    const parsed = GetContextInputSchema.parse(input);

    // Get the main node
    const node = await getNode(client, parsed.nodeId);

    if (!node) {
      return {
        content: [{
          type: 'text',
          text: JSON.stringify({ error: `Node not found: ${parsed.nodeId}` })
        }],
        isError: true
      };
    }

    // Get related nodes if requested
    let related: unknown[] = [];
    if (parsed.includeRelated) {
      related = await findRelatedNodes(client, parsed.nodeId, {
        maxDepth: parsed.maxDepth,
        limit: 20
      });
    }

    return {
      content: [{
        type: 'text',
        text: JSON.stringify({
          node,
          relatedCount: related.length,
          related
        }, null, 2)
      }]
    };
  } catch (error) {
    const message = error instanceof Error ? error.message : 'Unknown error';
    return {
      content: [{
        type: 'text',
        text: JSON.stringify({ error: message })
      }],
      isError: true
    };
  }
}
```

2. Create `apps/omnii_mcp/src/mcp/tools/list-entities.ts`:

```typescript
import { z } from 'zod';
import { getNodesByLabel, NodeLabel } from '../../graph';
import type { Neo4jHTTPClient } from '../../services/neo4j/http-client';

export const ListEntitiesInputSchema = z.object({
  nodeType: z.enum(['Concept', 'Entity', 'Event', 'Contact'])
    .describe('The type of nodes to list'),
  limit: z.number()
    .int()
    .min(1)
    .max(100)
    .default(20)
    .describe('Maximum number of results to return'),
  offset: z.number()
    .int()
    .min(0)
    .default(0)
    .describe('Number of results to skip (for pagination)')
});

export type ListEntitiesInput = z.infer<typeof ListEntitiesInputSchema>;

export const listEntitiesToolDefinition = {
  name: 'omnii_graph_list_entities',
  description: 'List nodes in the knowledge graph by type. ' +
    'Use this to browse available concepts, entities, events, or contacts. ' +
    'Results are ordered by creation date (newest first).',
  inputSchema: {
    type: 'object',
    properties: {
      nodeType: {
        type: 'string',
        enum: ['Concept', 'Entity', 'Event', 'Contact'],
        description: 'The type of nodes to list'
      },
      limit: {
        type: 'number',
        description: 'Maximum number of results to return (1-100, default 20)'
      },
      offset: {
        type: 'number',
        description: 'Number of results to skip for pagination (default 0)'
      }
    },
    required: ['nodeType']
  }
};

export async function handleListEntities(
  client: Neo4jHTTPClient,
  input: unknown
): Promise<{ content: Array<{ type: 'text'; text: string }>; isError?: boolean }> {
  try {
    const parsed = ListEntitiesInputSchema.parse(input);

    const label = parsed.nodeType as NodeLabel;
    const results = await getNodesByLabel(client, label, parsed.limit + parsed.offset);

    // Apply offset manually (pagination)
    const paged = results.slice(parsed.offset, parsed.offset + parsed.limit);

    return {
      content: [{
        type: 'text',
        text: JSON.stringify({
          nodeType: parsed.nodeType,
          total: results.length,
          returned: paged.length,
          offset: parsed.offset,
          nodes: paged.map(n => ({
            id: n.id,
            name: n.name,
            createdAt: n.createdAt
          }))
        }, null, 2)
      }]
    };
  } catch (error) {
    const message = error instanceof Error ? error.message : 'Unknown error';
    return {
      content: [{
        type: 'text',
        text: JSON.stringify({ error: message })
      }],
      isError: true
    };
  }
}
```
  </action>
  <verify>
TypeScript compilation:
```bash
cd apps/omnii_mcp && npx tsc --noEmit src/mcp/tools/get-context.ts src/mcp/tools/list-entities.ts
```

Check tool definitions:
```bash
cd apps/omnii_mcp && bun -e "
import { getContextToolDefinition } from './src/mcp/tools/get-context';
import { listEntitiesToolDefinition } from './src/mcp/tools/list-entities';
console.log('Tool 1:', getContextToolDefinition.name);
console.log('Tool 2:', listEntitiesToolDefinition.name);
"
```
Should output both tool names with omnii_graph_ prefix.
  </verify>
  <done>
get_context and list_entities tools implemented with Zod validation, proper MCP response format, and error handling.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create tool registration module</name>
  <files>apps/omnii_mcp/src/mcp/tools/index.ts</files>
  <action>
Create the tool index that aggregates all tools:

1. Create `apps/omnii_mcp/src/mcp/tools/index.ts`:

```typescript
import {
  searchNodesToolDefinition,
  handleSearchNodes,
  SearchNodesInputSchema
} from './search-nodes';
import {
  getContextToolDefinition,
  handleGetContext,
  GetContextInputSchema
} from './get-context';
import {
  listEntitiesToolDefinition,
  handleListEntities,
  ListEntitiesInputSchema
} from './list-entities';
import type { Neo4jHTTPClient } from '../../services/neo4j/http-client';

// Export all tool definitions (for tools/list response)
export const TOOL_DEFINITIONS = [
  searchNodesToolDefinition,
  getContextToolDefinition,
  listEntitiesToolDefinition
] as const;

// Tool name to handler mapping
export const TOOL_HANDLERS: Record<
  string,
  (client: Neo4jHTTPClient, input: unknown) => Promise<{
    content: Array<{ type: 'text'; text: string }>;
    isError?: boolean;
  }>
> = {
  [searchNodesToolDefinition.name]: handleSearchNodes,
  [getContextToolDefinition.name]: handleGetContext,
  [listEntitiesToolDefinition.name]: handleListEntities
};

// Export individual tools for direct use
export {
  searchNodesToolDefinition,
  handleSearchNodes,
  SearchNodesInputSchema,
  getContextToolDefinition,
  handleGetContext,
  GetContextInputSchema,
  listEntitiesToolDefinition,
  handleListEntities,
  ListEntitiesInputSchema
};

// Helper to check if tool exists
export function isValidTool(name: string): boolean {
  return name in TOOL_HANDLERS;
}

// Helper to get tool handler
export function getToolHandler(name: string) {
  return TOOL_HANDLERS[name] ?? null;
}
```

2. Update `apps/omnii_mcp/src/mcp/index.ts` to export tools:
```typescript
// Add to existing exports
export * from './tools';
```
  </action>
  <verify>
TypeScript compilation:
```bash
cd apps/omnii_mcp && npx tsc --noEmit src/mcp/tools/index.ts
```

Verify all tools exported:
```bash
cd apps/omnii_mcp && bun -e "
import { TOOL_DEFINITIONS, TOOL_HANDLERS, isValidTool } from './src/mcp/tools';
console.log('Tool count:', TOOL_DEFINITIONS.length);
console.log('Tools:', TOOL_DEFINITIONS.map(t => t.name).join(', '));
console.log('search_nodes valid:', isValidTool('omnii_graph_search_nodes'));
"
```
Should show 3 tools with omnii_graph_ prefixes.
  </verify>
  <done>
Tool index exports all tool definitions, handlers, and helper functions. Tools are ready for MCP server registration.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Full module compilation:
```bash
cd apps/omnii_mcp && npx tsc --noEmit src/mcp/index.ts
```

2. Directory structure:
```bash
ls -la apps/omnii_mcp/src/mcp/tools/
```
Should show: search-nodes.ts, get-context.ts, list-entities.ts, index.ts

3. Tool verification:
```bash
cd apps/omnii_mcp && bun -e "
import { TOOL_DEFINITIONS, getToolHandler } from './src/mcp';
console.log('All tools:');
TOOL_DEFINITIONS.forEach(t => {
  const hasHandler = !!getToolHandler(t.name);
  console.log('  -', t.name, hasHandler ? '(handler ok)' : '(MISSING HANDLER)');
});
"
```
</verification>

<success_criteria>
- Three MCP tools implemented: omnii_graph_search_nodes, omnii_graph_get_context, omnii_graph_list_entities
- All tools have Zod input schemas with proper descriptions
- All tools return MCP-compliant response format: { content: [{ type: 'text', text: string }] }
- All tools handle errors gracefully with isError: true
- Tool index exports TOOL_DEFINITIONS array and TOOL_HANDLERS map
- Helper functions isValidTool and getToolHandler work correctly
- All code compiles without TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-graph-core-mcp-server/02-04-SUMMARY.md`
</output>
