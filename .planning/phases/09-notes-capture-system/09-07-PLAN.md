---
phase: 09-notes-capture-system
plan: 07
type: execute
wave: 5
depends_on: ["09-05", "09-06"]
files_modified:
  - apps/omnii-mobile/src/features/notes/api/notesApi.ts
  - apps/omnii-mobile/src/features/notes/api/index.ts
  - apps/omnii-mobile/src/features/notes/components/NoteEditor.tsx
  - apps/omnii-mobile/src/features/notes/components/VoiceNoteButton.tsx
  - apps/omnii-mobile/src/features/notes/components/BacklinksPanel.tsx
  - apps/omnii-mobile/src/features/notes/components/TemplateSelector.tsx
  - apps/omnii-mobile/src/features/notes/components/index.ts
autonomous: false

must_haves:
  truths:
    - "User can type note with [[wikilinks]] visible in editor"
    - "User can tap voice button and see real-time transcription"
    - "User can view backlinks panel with linking notes"
    - "User can select template and see pre-filled content"
    - "Voice transcription creates note via API"
    - "Template selection creates note via API"
  artifacts:
    - path: "apps/omnii-mobile/src/features/notes/api/notesApi.ts"
      provides: "API client functions for note CRUD"
      exports: ["createNote", "createNoteFromTemplate", "getBacklinks", "updateNote"]
    - path: "apps/omnii-mobile/src/features/notes/components/NoteEditor.tsx"
      provides: "Note editing component with wikilink styling"
    - path: "apps/omnii-mobile/src/features/notes/components/VoiceNoteButton.tsx"
      provides: "Voice recording button with transcription display"
    - path: "apps/omnii-mobile/src/features/notes/components/BacklinksPanel.tsx"
      provides: "Panel showing notes that link to current note"
    - path: "apps/omnii-mobile/src/features/notes/components/TemplateSelector.tsx"
      provides: "Template selection modal"
  key_links:
    - from: "apps/omnii-mobile/src/features/notes/components/VoiceNoteButton.tsx"
      to: "apps/omnii-mobile/src/features/notes/hooks/useVoiceCapture.ts"
      via: "uses useVoiceCapture hook"
      pattern: "import.*useVoiceCapture.*from.*hooks"
    - from: "apps/omnii-mobile/src/features/notes/components/NoteEditor.tsx"
      to: "apps/omnii-mobile/src/features/notes/api/notesApi.ts"
      via: "calls createNote API"
      pattern: "import.*createNote.*from.*api"
    - from: "apps/omnii-mobile/src/features/notes/components/TemplateSelector.tsx"
      to: "apps/omnii-mobile/src/features/notes/api/notesApi.ts"
      via: "calls createNoteFromTemplate API"
      pattern: "createNoteFromTemplate"
---

<objective>
Create mobile UI components for note editing, voice capture, backlinks display, and template selection with full API wiring

Purpose: Provides user-facing interface for all note capture features (wiki links, backlinks, templates, voice) with backend integration
Output: NoteEditor, VoiceNoteButton, BacklinksPanel, TemplateSelector components + notesApi client
</objective>

<execution_context>
@/Users/santino/.claude/get-shit-done/workflows/execute-plan.md
@/Users/santino/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-notes-capture-system/09-RESEARCH.md
@apps/omnii-mobile/src/features/notes/hooks/useVoiceCapture.ts
@apps/omnii-mobile/src/components/chat/ChatInput.tsx
@apps/omnii_mcp/src/routes/notes.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create VoiceNoteButton component</name>
  <files>apps/omnii-mobile/src/features/notes/components/VoiceNoteButton.tsx</files>
  <action>
Create voice recording button that shows real-time transcription.

Create `apps/omnii-mobile/src/features/notes/components/VoiceNoteButton.tsx`:

```tsx
/**
 * Voice Note Button
 *
 * Press-and-hold or toggle button for voice note capture.
 * Shows real-time transcription as user speaks.
 */

import React, { useState } from 'react';
import {
  View,
  Text,
  Pressable,
  ActivityIndicator,
  StyleSheet,
} from 'react-native';
import { Mic, MicOff, AlertCircle } from 'lucide-react-native';
import { useVoiceCapture } from '../hooks/useVoiceCapture';

interface VoiceNoteButtonProps {
  /** Called when transcription is complete */
  onTranscriptComplete: (transcript: string) => void;
  /** Called on interim results for live preview */
  onInterimResult?: (transcript: string) => void;
  /** Optional custom styling */
  style?: object;
  /** Language code (default: en-US) */
  language?: string;
}

export function VoiceNoteButton({
  onTranscriptComplete,
  onInterimResult,
  style,
  language = 'en-US',
}: VoiceNoteButtonProps) {
  const [showTranscript, setShowTranscript] = useState(false);

  const {
    transcript,
    isRecording,
    isSupported,
    error,
    isFinal,
    startRecording,
    stopRecording,
    clearTranscript,
  } = useVoiceCapture({
    language,
    onResult: (result) => {
      // Show interim results
      if (onInterimResult && !result.isFinal) {
        onInterimResult(result.transcript);
      }

      // Handle final result
      if (result.isFinal && result.transcript.trim()) {
        onTranscriptComplete(result.transcript);
        setShowTranscript(false);
      }
    },
    onError: (err) => {
      console.error('Voice capture error:', err);
    },
  });

  const handlePress = async () => {
    if (isRecording) {
      stopRecording();
      // Final result will be handled in onResult callback
    } else {
      clearTranscript();
      setShowTranscript(true);
      await startRecording();
    }
  };

  // Not supported on this device
  if (!isSupported) {
    return (
      <View style={[styles.container, styles.disabled, style]}>
        <MicOff size={24} color="#9CA3AF" />
        <Text style={styles.disabledText}>Voice not supported</Text>
      </View>
    );
  }

  return (
    <View style={[styles.container, style]}>
      {/* Recording button */}
      <Pressable
        onPress={handlePress}
        style={[
          styles.button,
          isRecording && styles.buttonRecording,
        ]}
        accessibilityLabel={isRecording ? 'Stop recording' : 'Start voice note'}
        accessibilityRole="button"
      >
        {isRecording ? (
          <>
            <View style={styles.recordingIndicator} />
            <Mic size={24} color="#FFFFFF" />
          </>
        ) : (
          <Mic size={24} color="#6366F1" />
        )}
      </Pressable>

      {/* Transcript display */}
      {showTranscript && (
        <View style={styles.transcriptContainer}>
          {isRecording && (
            <View style={styles.listeningIndicator}>
              <ActivityIndicator size="small" color="#6366F1" />
              <Text style={styles.listeningText}>Listening...</Text>
            </View>
          )}

          {transcript ? (
            <Text style={styles.transcript}>{transcript}</Text>
          ) : (
            isRecording && (
              <Text style={styles.placeholder}>Speak now...</Text>
            )
          )}

          {error && (
            <View style={styles.errorContainer}>
              <AlertCircle size={16} color="#EF4444" />
              <Text style={styles.errorText}>{error}</Text>
            </View>
          )}
        </View>
      )}
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    alignItems: 'center',
  },
  disabled: {
    opacity: 0.5,
    flexDirection: 'row',
    gap: 8,
  },
  disabledText: {
    color: '#9CA3AF',
    fontSize: 12,
  },
  button: {
    width: 56,
    height: 56,
    borderRadius: 28,
    backgroundColor: '#EEF2FF',
    justifyContent: 'center',
    alignItems: 'center',
    borderWidth: 2,
    borderColor: '#6366F1',
  },
  buttonRecording: {
    backgroundColor: '#6366F1',
    borderColor: '#4F46E5',
  },
  recordingIndicator: {
    position: 'absolute',
    top: -4,
    right: -4,
    width: 16,
    height: 16,
    borderRadius: 8,
    backgroundColor: '#EF4444',
  },
  transcriptContainer: {
    marginTop: 12,
    padding: 12,
    backgroundColor: '#F9FAFB',
    borderRadius: 8,
    minWidth: 200,
    maxWidth: 300,
  },
  listeningIndicator: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
    marginBottom: 8,
  },
  listeningText: {
    color: '#6366F1',
    fontSize: 12,
    fontWeight: '500',
  },
  transcript: {
    color: '#111827',
    fontSize: 14,
    lineHeight: 20,
  },
  placeholder: {
    color: '#9CA3AF',
    fontSize: 14,
    fontStyle: 'italic',
  },
  errorContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 6,
    marginTop: 8,
  },
  errorText: {
    color: '#EF4444',
    fontSize: 12,
  },
});
```
  </action>
  <verify>Verify file exists with `ls apps/omnii-mobile/src/features/notes/components/VoiceNoteButton.tsx`.</verify>
  <done>VoiceNoteButton component shows recording state and real-time transcription</done>
</task>

<task type="auto">
  <name>Task 2: Create notes API client</name>
  <files>
apps/omnii-mobile/src/features/notes/api/notesApi.ts
apps/omnii-mobile/src/features/notes/api/index.ts
  </files>
  <action>
Create API client functions to wire mobile components to backend note endpoints.

Create `apps/omnii-mobile/src/features/notes/api/notesApi.ts`:

```typescript
/**
 * Notes API Client
 *
 * Client functions for interacting with the notes REST API.
 * Used by NoteEditor, TemplateSelector, and BacklinksPanel components.
 */

import { API_BASE_URL } from '@/config/api';

type CreatedVia = 'manual' | 'voice' | 'template';
type TemplateType = 'meeting-notes' | 'daily-journal' | 'contact-notes';

interface CreateNoteParams {
  userId: string;
  title: string;
  content: string;
  createdVia?: CreatedVia;
}

interface CreateNoteResult {
  success: boolean;
  noteId: string;
  normalizedTitle: string;
  linksCreated: number;
  stubsCreated: number;
}

interface TemplateContext {
  currentUser?: string;
  date?: string; // ISO date string
  meeting?: {
    title: string;
    attendees: string[];
    project?: string;
  };
  contact?: {
    name: string;
    company?: string;
    email?: string;
  };
  journal?: {
    previousDate?: string;
    nextDate?: string;
  };
}

interface CreateFromTemplateParams {
  userId: string;
  templateType: TemplateType;
  context: TemplateContext;
}

interface CreateFromTemplateResult {
  success: boolean;
  noteId: string;
  normalizedTitle: string;
  title: string;
  linksCreated: number;
  stubsCreated: number;
}

interface BacklinkItem {
  noteId: string;
  title: string;
  preview: string;
  updatedAt: string;
}

interface BacklinksResult {
  targetId: string;
  targetTitle: string;
  backlinks: BacklinkItem[];
  totalCount: number;
}

interface UpdateNoteParams {
  userId: string;
  noteId: string;
  title?: string;
  content?: string;
}

interface UpdateNoteResult {
  success: boolean;
  noteId: string;
  linksUpdated: {
    linksCreated: number;
    stubsCreated: number;
  } | null;
}

/**
 * Create a new note.
 *
 * @param params - Note creation parameters
 * @returns Created note info with link resolution stats
 *
 * @example
 * const result = await createNote({
 *   userId: 'user_123',
 *   title: 'Meeting Notes',
 *   content: 'Discussed [[Project Alpha]] with [[John Smith]]',
 *   createdVia: 'manual'
 * });
 */
export async function createNote(params: CreateNoteParams): Promise<CreateNoteResult> {
  const response = await fetch(`${API_BASE_URL}/api/notes`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      userId: params.userId,
      title: params.title,
      content: params.content,
      createdVia: params.createdVia || 'manual',
    }),
  });

  if (!response.ok) {
    const error = await response.json();
    throw new Error(error.details || error.error || 'Failed to create note');
  }

  return response.json();
}

/**
 * Create a note from a template.
 *
 * @param params - Template creation parameters
 * @returns Created note info with pre-filled content
 *
 * @example
 * const result = await createNoteFromTemplate({
 *   userId: 'user_123',
 *   templateType: 'meeting-notes',
 *   context: {
 *     meeting: {
 *       title: 'Sprint Planning',
 *       attendees: ['Alice', 'Bob'],
 *       project: 'Project Alpha'
 *     }
 *   }
 * });
 */
export async function createNoteFromTemplate(
  params: CreateFromTemplateParams
): Promise<CreateFromTemplateResult> {
  const response = await fetch(`${API_BASE_URL}/api/notes/from-template`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      userId: params.userId,
      templateType: params.templateType,
      context: params.context,
    }),
  });

  if (!response.ok) {
    const error = await response.json();
    throw new Error(error.details || error.error || 'Failed to create note from template');
  }

  return response.json();
}

/**
 * Get backlinks for a note.
 *
 * @param userId - User ID
 * @param noteId - Note ID to get backlinks for
 * @param limit - Max results (default 50)
 * @param offset - Pagination offset (default 0)
 * @returns Backlinks data with previews
 *
 * @example
 * const backlinks = await getBacklinks('user_123', 'note_abc123');
 */
export async function getBacklinks(
  userId: string,
  noteId: string,
  limit: number = 50,
  offset: number = 0
): Promise<BacklinksResult> {
  const params = new URLSearchParams({
    userId,
    limit: String(limit),
    offset: String(offset),
  });

  const response = await fetch(`${API_BASE_URL}/api/notes/${noteId}/backlinks?${params}`);

  if (!response.ok) {
    const error = await response.json();
    throw new Error(error.details || error.error || 'Failed to get backlinks');
  }

  return response.json();
}

/**
 * Update an existing note.
 *
 * @param params - Update parameters
 * @returns Update result with link resolution stats
 *
 * @example
 * const result = await updateNote({
 *   userId: 'user_123',
 *   noteId: 'note_abc123',
 *   content: 'Updated content with [[new link]]'
 * });
 */
export async function updateNote(params: UpdateNoteParams): Promise<UpdateNoteResult> {
  const response = await fetch(`${API_BASE_URL}/api/notes/${params.noteId}`, {
    method: 'PATCH',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      userId: params.userId,
      title: params.title,
      content: params.content,
    }),
  });

  if (!response.ok) {
    const error = await response.json();
    throw new Error(error.details || error.error || 'Failed to update note');
  }

  return response.json();
}

/**
 * Delete a note.
 *
 * @param userId - User ID
 * @param noteId - Note ID to delete
 *
 * @example
 * await deleteNote('user_123', 'note_abc123');
 */
export async function deleteNote(userId: string, noteId: string): Promise<void> {
  const params = new URLSearchParams({ userId });

  const response = await fetch(`${API_BASE_URL}/api/notes/${noteId}?${params}`, {
    method: 'DELETE',
  });

  if (!response.ok) {
    const error = await response.json();
    throw new Error(error.details || error.error || 'Failed to delete note');
  }
}

/**
 * Get a note by ID.
 *
 * @param userId - User ID
 * @param noteId - Note ID
 * @returns Note with parsed wikilinks
 */
export async function getNote(userId: string, noteId: string) {
  const params = new URLSearchParams({ userId });

  const response = await fetch(`${API_BASE_URL}/api/notes/${noteId}?${params}`);

  if (!response.ok) {
    const error = await response.json();
    throw new Error(error.details || error.error || 'Failed to get note');
  }

  return response.json();
}

/**
 * List recent notes.
 *
 * @param userId - User ID
 * @param limit - Max results (default 50)
 * @param includeStubs - Include stub notes (default false)
 * @returns List of recent notes
 */
export async function listNotes(
  userId: string,
  limit: number = 50,
  includeStubs: boolean = false
) {
  const params = new URLSearchParams({
    userId,
    limit: String(limit),
    includeStubs: String(includeStubs),
  });

  const response = await fetch(`${API_BASE_URL}/api/notes?${params}`);

  if (!response.ok) {
    const error = await response.json();
    throw new Error(error.details || error.error || 'Failed to list notes');
  }

  return response.json();
}

/**
 * Search notes by title.
 *
 * @param userId - User ID
 * @param query - Search query
 * @param limit - Max results (default 20)
 * @returns Matching notes
 */
export async function searchNotes(userId: string, query: string, limit: number = 20) {
  const params = new URLSearchParams({
    userId,
    q: query,
    limit: String(limit),
  });

  const response = await fetch(`${API_BASE_URL}/api/notes/search?${params}`);

  if (!response.ok) {
    const error = await response.json();
    throw new Error(error.details || error.error || 'Failed to search notes');
  }

  return response.json();
}
```

Create `apps/omnii-mobile/src/features/notes/api/index.ts`:

```typescript
/**
 * Notes API Module
 *
 * Barrel export for notes API client functions.
 */

export {
  createNote,
  createNoteFromTemplate,
  getBacklinks,
  updateNote,
  deleteNote,
  getNote,
  listNotes,
  searchNotes,
} from './notesApi';
```
  </action>
  <verify>Verify files exist with `ls apps/omnii-mobile/src/features/notes/api/`. Run type check if available.</verify>
  <done>notesApi.ts exports createNote, createNoteFromTemplate, getBacklinks, updateNote, deleteNote, getNote, listNotes, searchNotes</done>
</task>

<task type="auto">
  <name>Task 3: Create BacklinksPanel and TemplateSelector</name>
  <files>
apps/omnii-mobile/src/features/notes/components/BacklinksPanel.tsx
apps/omnii-mobile/src/features/notes/components/TemplateSelector.tsx
  </files>
  <action>
Create backlinks panel and template selector components.

Create `apps/omnii-mobile/src/features/notes/components/BacklinksPanel.tsx`:

```tsx
/**
 * Backlinks Panel
 *
 * Shows notes that link to the current note.
 * Collapsible panel with preview text for context.
 */

import React, { useState } from 'react';
import {
  View,
  Text,
  Pressable,
  FlatList,
  ActivityIndicator,
  StyleSheet,
} from 'react-native';
import { ChevronDown, ChevronUp, Link2 } from 'lucide-react-native';

interface BacklinkItem {
  noteId: string;
  title: string;
  preview: string;
  updatedAt: string;
}

interface BacklinksPanelProps {
  /** Note ID to show backlinks for */
  targetId: string;
  /** Backlinks data from API */
  backlinks: BacklinkItem[];
  /** Total count (may be more than shown) */
  totalCount: number;
  /** Loading state */
  isLoading?: boolean;
  /** Called when a backlink is pressed */
  onBacklinkPress: (noteId: string) => void;
  /** Load more callback for pagination */
  onLoadMore?: () => void;
}

export function BacklinksPanel({
  backlinks,
  totalCount,
  isLoading,
  onBacklinkPress,
  onLoadMore,
}: BacklinksPanelProps) {
  const [isExpanded, setIsExpanded] = useState(true);

  const formatDate = (dateStr: string) => {
    const date = new Date(dateStr);
    return date.toLocaleDateString(undefined, {
      month: 'short',
      day: 'numeric',
    });
  };

  const renderBacklink = ({ item }: { item: BacklinkItem }) => (
    <Pressable
      style={styles.backlinkItem}
      onPress={() => onBacklinkPress(item.noteId)}
      accessibilityLabel={`Open ${item.title}`}
      accessibilityRole="button"
    >
      <View style={styles.backlinkHeader}>
        <Text style={styles.backlinkTitle} numberOfLines={1}>
          {item.title}
        </Text>
        <Text style={styles.backlinkDate}>{formatDate(item.updatedAt)}</Text>
      </View>
      <Text style={styles.backlinkPreview} numberOfLines={2}>
        {item.preview}
      </Text>
    </Pressable>
  );

  if (totalCount === 0 && !isLoading) {
    return null; // Don't show panel if no backlinks
  }

  return (
    <View style={styles.container}>
      {/* Header */}
      <Pressable
        style={styles.header}
        onPress={() => setIsExpanded(!isExpanded)}
        accessibilityLabel={isExpanded ? 'Collapse backlinks' : 'Expand backlinks'}
        accessibilityRole="button"
      >
        <View style={styles.headerLeft}>
          <Link2 size={16} color="#6366F1" />
          <Text style={styles.headerText}>
            {totalCount} {totalCount === 1 ? 'Backlink' : 'Backlinks'}
          </Text>
        </View>
        {isExpanded ? (
          <ChevronUp size={20} color="#6B7280" />
        ) : (
          <ChevronDown size={20} color="#6B7280" />
        )}
      </Pressable>

      {/* Content */}
      {isExpanded && (
        <View style={styles.content}>
          {isLoading ? (
            <View style={styles.loadingContainer}>
              <ActivityIndicator size="small" color="#6366F1" />
            </View>
          ) : (
            <FlatList
              data={backlinks}
              keyExtractor={(item) => item.noteId}
              renderItem={renderBacklink}
              ItemSeparatorComponent={() => <View style={styles.separator} />}
              ListFooterComponent={
                backlinks.length < totalCount && onLoadMore ? (
                  <Pressable style={styles.loadMore} onPress={onLoadMore}>
                    <Text style={styles.loadMoreText}>
                      Show more ({totalCount - backlinks.length} remaining)
                    </Text>
                  </Pressable>
                ) : null
              }
            />
          )}
        </View>
      )}
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    backgroundColor: '#F9FAFB',
    borderRadius: 8,
    marginVertical: 8,
    borderWidth: 1,
    borderColor: '#E5E7EB',
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 12,
  },
  headerLeft: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
  },
  headerText: {
    fontSize: 14,
    fontWeight: '600',
    color: '#374151',
  },
  content: {
    borderTopWidth: 1,
    borderTopColor: '#E5E7EB',
    maxHeight: 300,
  },
  loadingContainer: {
    padding: 20,
    alignItems: 'center',
  },
  backlinkItem: {
    padding: 12,
  },
  backlinkHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 4,
  },
  backlinkTitle: {
    fontSize: 14,
    fontWeight: '500',
    color: '#111827',
    flex: 1,
    marginRight: 8,
  },
  backlinkDate: {
    fontSize: 12,
    color: '#9CA3AF',
  },
  backlinkPreview: {
    fontSize: 13,
    color: '#6B7280',
    lineHeight: 18,
  },
  separator: {
    height: 1,
    backgroundColor: '#E5E7EB',
  },
  loadMore: {
    padding: 12,
    alignItems: 'center',
  },
  loadMoreText: {
    color: '#6366F1',
    fontSize: 13,
  },
});
```

Create `apps/omnii-mobile/src/features/notes/components/TemplateSelector.tsx`:

```tsx
/**
 * Template Selector
 *
 * Modal or sheet for selecting note templates.
 * Shows template previews and context options.
 */

import React from 'react';
import {
  View,
  Text,
  Pressable,
  Modal,
  StyleSheet,
} from 'react-native';
import {
  X,
  Calendar,
  BookOpen,
  User,
} from 'lucide-react-native';

type TemplateType = 'meeting-notes' | 'daily-journal' | 'contact-notes';

interface Template {
  type: TemplateType;
  name: string;
  description: string;
  icon: React.ReactNode;
}

const templates: Template[] = [
  {
    type: 'meeting-notes',
    name: 'Meeting Notes',
    description: 'Structured notes with attendees, agenda, and action items',
    icon: <Calendar size={24} color="#6366F1" />,
  },
  {
    type: 'daily-journal',
    name: 'Daily Journal',
    description: 'Daily reflection with priorities and gratitude',
    icon: <BookOpen size={24} color="#10B981" />,
  },
  {
    type: 'contact-notes',
    name: 'Contact Notes',
    description: 'Track interactions and notes about a person',
    icon: <User size={24} color="#F59E0B" />,
  },
];

interface TemplateSelectorProps {
  /** Whether modal is visible */
  visible: boolean;
  /** Close callback */
  onClose: () => void;
  /** Called when template is selected */
  onSelectTemplate: (type: TemplateType) => void;
}

export function TemplateSelector({
  visible,
  onClose,
  onSelectTemplate,
}: TemplateSelectorProps) {
  return (
    <Modal
      visible={visible}
      animationType="slide"
      presentationStyle="pageSheet"
      onRequestClose={onClose}
    >
      <View style={styles.container}>
        {/* Header */}
        <View style={styles.header}>
          <Text style={styles.title}>Create from Template</Text>
          <Pressable
            onPress={onClose}
            style={styles.closeButton}
            accessibilityLabel="Close"
            accessibilityRole="button"
          >
            <X size={24} color="#6B7280" />
          </Pressable>
        </View>

        {/* Template list */}
        <View style={styles.templateList}>
          {templates.map((template) => (
            <Pressable
              key={template.type}
              style={styles.templateItem}
              onPress={() => {
                onSelectTemplate(template.type);
                onClose();
              }}
              accessibilityLabel={`Create ${template.name}`}
              accessibilityRole="button"
            >
              <View style={styles.templateIcon}>{template.icon}</View>
              <View style={styles.templateContent}>
                <Text style={styles.templateName}>{template.name}</Text>
                <Text style={styles.templateDescription}>
                  {template.description}
                </Text>
              </View>
            </Pressable>
          ))}
        </View>

        {/* Quick create option */}
        <Pressable
          style={styles.blankNote}
          onPress={() => {
            onClose();
            // Parent handles blank note creation
          }}
        >
          <Text style={styles.blankNoteText}>Or start with a blank note</Text>
        </Pressable>
      </View>
    </Modal>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#FFFFFF',
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#E5E7EB',
  },
  title: {
    fontSize: 18,
    fontWeight: '600',
    color: '#111827',
  },
  closeButton: {
    padding: 4,
  },
  templateList: {
    padding: 16,
    gap: 12,
  },
  templateItem: {
    flexDirection: 'row',
    padding: 16,
    backgroundColor: '#F9FAFB',
    borderRadius: 12,
    borderWidth: 1,
    borderColor: '#E5E7EB',
  },
  templateIcon: {
    width: 48,
    height: 48,
    borderRadius: 8,
    backgroundColor: '#FFFFFF',
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: 12,
  },
  templateContent: {
    flex: 1,
    justifyContent: 'center',
  },
  templateName: {
    fontSize: 16,
    fontWeight: '600',
    color: '#111827',
    marginBottom: 4,
  },
  templateDescription: {
    fontSize: 13,
    color: '#6B7280',
    lineHeight: 18,
  },
  blankNote: {
    padding: 16,
    alignItems: 'center',
  },
  blankNoteText: {
    color: '#6366F1',
    fontSize: 14,
  },
});
```
  </action>
  <verify>Verify files exist with `ls apps/omnii-mobile/src/features/notes/components/`.</verify>
  <done>BacklinksPanel shows linking notes; TemplateSelector provides template selection modal</done>
</task>

<task type="auto">
  <name>Task 4: Create NoteEditor with API wiring and module index</name>
  <files>
apps/omnii-mobile/src/features/notes/components/NoteEditor.tsx
apps/omnii-mobile/src/features/notes/components/index.ts
  </files>
  <action>
Create note editor component with API wiring for voice and template creation.

Create `apps/omnii-mobile/src/features/notes/components/NoteEditor.tsx`:

```tsx
/**
 * Note Editor
 *
 * Markdown-aware text editor with wikilink highlighting.
 * Supports voice input and template insertion.
 * Wired to backend API for persistence.
 */

import React, { useState, useRef, useCallback } from 'react';
import {
  View,
  TextInput,
  Text,
  Pressable,
  ScrollView,
  StyleSheet,
  KeyboardAvoidingView,
  Platform,
  Alert,
} from 'react-native';
import { Save, FileText, Mic } from 'lucide-react-native';
import { VoiceNoteButton } from './VoiceNoteButton';
import { TemplateSelector } from './TemplateSelector';
import { BacklinksPanel } from './BacklinksPanel';
import { createNote, createNoteFromTemplate, updateNote } from '../api';

type TemplateType = 'meeting-notes' | 'daily-journal' | 'contact-notes';

interface NoteEditorProps {
  /** User ID for API calls */
  userId: string;
  /** Initial title */
  initialTitle?: string;
  /** Initial content */
  initialContent?: string;
  /** Note ID (for backlinks and updates, undefined for new notes) */
  noteId?: string;
  /** Backlinks data */
  backlinks?: {
    items: Array<{ noteId: string; title: string; preview: string; updatedAt: string }>;
    totalCount: number;
  };
  /** Called after note is saved successfully */
  onSaveComplete?: (noteId: string) => void;
  /** Called when template creates a new note */
  onTemplateNoteCreated?: (noteId: string, title: string) => void;
  /** Called when backlink is pressed */
  onBacklinkPress: (noteId: string) => void;
}

export function NoteEditor({
  userId,
  initialTitle = '',
  initialContent = '',
  noteId,
  backlinks,
  onSaveComplete,
  onTemplateNoteCreated,
  onBacklinkPress,
}: NoteEditorProps) {
  const [title, setTitle] = useState(initialTitle);
  const [content, setContent] = useState(initialContent);
  const [showTemplates, setShowTemplates] = useState(false);
  const [showVoice, setShowVoice] = useState(false);
  const [isSaving, setIsSaving] = useState(false);

  const contentRef = useRef<TextInput>(null);

  // Count wikilinks for display
  const wikilinkCount = (content.match(/\[\[[^\]]+\]\]/g) || []).length;

  /**
   * Save note to API (create or update)
   */
  const handleSave = async () => {
    if (!title.trim()) {
      Alert.alert('Title Required', 'Please enter a title for your note.');
      return;
    }

    setIsSaving(true);
    try {
      if (noteId) {
        // Update existing note
        await updateNote({
          userId,
          noteId,
          title: title.trim(),
          content,
        });
        onSaveComplete?.(noteId);
      } else {
        // Create new note
        const result = await createNote({
          userId,
          title: title.trim(),
          content,
          createdVia: 'manual',
        });
        onSaveComplete?.(result.noteId);
      }
    } catch (error) {
      Alert.alert(
        'Save Failed',
        error instanceof Error ? error.message : 'Unable to save note. Please try again.'
      );
    } finally {
      setIsSaving(false);
    }
  };

  /**
   * Handle voice transcription completion.
   * Creates a new note with the transcript via API.
   */
  const handleVoiceTranscript = useCallback(async (transcript: string) => {
    setShowVoice(false);

    // If editing existing note, append to content
    if (noteId) {
      setContent((prev) => {
        if (prev.endsWith('\n') || prev === '') {
          return prev + transcript;
        }
        return prev + '\n\n' + transcript;
      });
      return;
    }

    // For new note with voice, create immediately via API
    try {
      const voiceTitle = `Voice Note - ${new Date().toLocaleDateString()}`;
      const result = await createNote({
        userId,
        title: voiceTitle,
        content: transcript,
        createdVia: 'voice',
      });
      onSaveComplete?.(result.noteId);
    } catch (error) {
      // Fallback: populate editor fields for manual save
      setTitle(`Voice Note - ${new Date().toLocaleDateString()}`);
      setContent(transcript);
      Alert.alert(
        'Auto-save Failed',
        'Voice note added to editor. Tap Save to persist.'
      );
    }
  }, [userId, noteId, onSaveComplete]);

  /**
   * Handle template selection.
   * Creates a new note from template via API.
   */
  const handleTemplateSelect = useCallback(async (templateType: TemplateType) => {
    setShowTemplates(false);

    try {
      const result = await createNoteFromTemplate({
        userId,
        templateType,
        context: {
          currentUser: userId,
          date: new Date().toISOString(),
        },
      });
      onTemplateNoteCreated?.(result.noteId, result.title);
    } catch (error) {
      Alert.alert(
        'Template Failed',
        error instanceof Error ? error.message : 'Unable to create note from template.'
      );
    }
  }, [userId, onTemplateNoteCreated]);

  return (
    <KeyboardAvoidingView
      style={styles.container}
      behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
    >
      {/* Toolbar */}
      <View style={styles.toolbar}>
        <Pressable
          style={styles.toolbarButton}
          onPress={() => setShowTemplates(true)}
          accessibilityLabel="Use template"
        >
          <FileText size={20} color="#6366F1" />
        </Pressable>

        <Pressable
          style={styles.toolbarButton}
          onPress={() => setShowVoice(true)}
          accessibilityLabel="Voice input"
        >
          <Mic size={20} color="#6366F1" />
        </Pressable>

        <View style={styles.toolbarSpacer} />

        {wikilinkCount > 0 && (
          <Text style={styles.linkCount}>
            {wikilinkCount} {wikilinkCount === 1 ? 'link' : 'links'}
          </Text>
        )}

        <Pressable
          style={[styles.saveButton, isSaving && styles.saveButtonDisabled]}
          onPress={handleSave}
          disabled={isSaving || !title.trim()}
          accessibilityLabel="Save note"
        >
          <Save size={20} color="#FFFFFF" />
          <Text style={styles.saveButtonText}>
            {isSaving ? 'Saving...' : 'Save'}
          </Text>
        </Pressable>
      </View>

      <ScrollView style={styles.editorScroll}>
        {/* Title input */}
        <TextInput
          style={styles.titleInput}
          value={title}
          onChangeText={setTitle}
          placeholder="Note title..."
          placeholderTextColor="#9CA3AF"
          autoFocus={!initialTitle}
          returnKeyType="next"
          onSubmitEditing={() => contentRef.current?.focus()}
        />

        {/* Content input */}
        <TextInput
          ref={contentRef}
          style={styles.contentInput}
          value={content}
          onChangeText={setContent}
          placeholder="Start writing... Use [[double brackets]] to create links"
          placeholderTextColor="#9CA3AF"
          multiline
          textAlignVertical="top"
        />

        {/* Backlinks panel (if viewing existing note) */}
        {noteId && backlinks && (
          <BacklinksPanel
            targetId={noteId}
            backlinks={backlinks.items}
            totalCount={backlinks.totalCount}
            onBacklinkPress={onBacklinkPress}
          />
        )}
      </ScrollView>

      {/* Template selector modal */}
      <TemplateSelector
        visible={showTemplates}
        onClose={() => setShowTemplates(false)}
        onSelectTemplate={handleTemplateSelect}
      />

      {/* Voice input modal */}
      {showVoice && (
        <View style={styles.voiceOverlay}>
          <Pressable
            style={styles.voiceBackdrop}
            onPress={() => setShowVoice(false)}
          />
          <View style={styles.voiceContainer}>
            <Text style={styles.voiceTitle}>Voice Note</Text>
            <VoiceNoteButton onTranscriptComplete={handleVoiceTranscript} />
            <Pressable
              style={styles.voiceCancel}
              onPress={() => setShowVoice(false)}
            >
              <Text style={styles.voiceCancelText}>Cancel</Text>
            </Pressable>
          </View>
        </View>
      )}
    </KeyboardAvoidingView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#FFFFFF',
  },
  toolbar: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 12,
    borderBottomWidth: 1,
    borderBottomColor: '#E5E7EB',
    gap: 8,
  },
  toolbarButton: {
    padding: 8,
    borderRadius: 8,
    backgroundColor: '#EEF2FF',
  },
  toolbarSpacer: {
    flex: 1,
  },
  linkCount: {
    fontSize: 12,
    color: '#6B7280',
    marginRight: 12,
  },
  saveButton: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 6,
    paddingHorizontal: 16,
    paddingVertical: 8,
    backgroundColor: '#6366F1',
    borderRadius: 8,
  },
  saveButtonDisabled: {
    opacity: 0.5,
  },
  saveButtonText: {
    color: '#FFFFFF',
    fontWeight: '600',
  },
  editorScroll: {
    flex: 1,
    padding: 16,
  },
  titleInput: {
    fontSize: 24,
    fontWeight: '600',
    color: '#111827',
    marginBottom: 16,
    padding: 0,
  },
  contentInput: {
    fontSize: 16,
    color: '#374151',
    lineHeight: 24,
    minHeight: 200,
    padding: 0,
  },
  voiceOverlay: {
    ...StyleSheet.absoluteFillObject,
    justifyContent: 'flex-end',
  },
  voiceBackdrop: {
    ...StyleSheet.absoluteFillObject,
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
  },
  voiceContainer: {
    backgroundColor: '#FFFFFF',
    borderTopLeftRadius: 16,
    borderTopRightRadius: 16,
    padding: 24,
    alignItems: 'center',
  },
  voiceTitle: {
    fontSize: 18,
    fontWeight: '600',
    color: '#111827',
    marginBottom: 24,
  },
  voiceCancel: {
    marginTop: 24,
    padding: 12,
  },
  voiceCancelText: {
    color: '#6B7280',
    fontSize: 16,
  },
});
```

Create `apps/omnii-mobile/src/features/notes/components/index.ts`:

```typescript
/**
 * Notes Feature Components
 */

export { NoteEditor } from './NoteEditor';
export { VoiceNoteButton } from './VoiceNoteButton';
export { BacklinksPanel } from './BacklinksPanel';
export { TemplateSelector } from './TemplateSelector';
```
  </action>
  <verify>Verify all component files exist with `ls apps/omnii-mobile/src/features/notes/components/`.</verify>
  <done>NoteEditor with API wiring for voice and template creation; component index exports all components</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete mobile UI for note capture with full backend wiring:
- VoiceNoteButton: Press to record, shows real-time transcription
- BacklinksPanel: Collapsible panel showing linking notes
- TemplateSelector: Modal with three template options (creates note via API)
- NoteEditor: Full editing experience with toolbar, voice, and backlinks
- notesApi: API client with createNote, createNoteFromTemplate, getBacklinks, updateNote
  </what-built>
  <how-to-verify>
1. Run mobile app: `cd apps/omnii-mobile && npx expo start`
2. Navigate to a screen that uses NoteEditor (or create test screen)
3. Test voice capture with API:
   - Tap microphone button
   - Speak a sentence
   - Verify transcription appears within 3 seconds
   - Verify note is created in backend (check API logs or database)
4. Test template selector with API:
   - Tap template button in toolbar
   - Verify three templates shown
   - Select one and verify note is created via POST /api/notes/from-template
5. Test manual save:
   - Type a title and content
   - Tap Save button
   - Verify POST /api/notes is called successfully
6. Test backlinks panel (requires existing notes with links):
   - View note that has backlinks
   - Verify panel shows linking notes from GET /api/notes/:id/backlinks
   - Tap a backlink to navigate
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues found</resume-signal>
</task>

</tasks>

<verification>
1. All component files created and exported
2. notesApi.ts exports createNote, createNoteFromTemplate, getBacklinks, updateNote
3. VoiceNoteButton uses useVoiceCapture hook
4. NoteEditor.handleVoiceTranscript calls createNote API with createdVia: 'voice'
5. NoteEditor.handleTemplateSelect calls createNoteFromTemplate API
6. BacklinksPanel shows collapsible list
7. TemplateSelector displays three template options
8. Human verification of voice -> API flow
</verification>

<success_criteria>
- Voice capture creates note via POST /api/notes with createdVia: 'voice'
- Template selection creates note via POST /api/notes/from-template
- Manual save calls POST /api/notes or PATCH /api/notes/:id
- Backlinks fetched via GET /api/notes/:id/backlinks
- All NOTE requirements (01-04) have working UI + API wiring
</success_criteria>

<output>
After completion, create `.planning/phases/09-notes-capture-system/09-07-SUMMARY.md`
</output>
