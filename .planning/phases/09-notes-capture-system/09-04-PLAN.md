---
phase: 09-notes-capture-system
plan: 04
type: execute
wave: 3
depends_on: ["09-02"]
files_modified:
  - apps/omnii_mcp/src/notes/graph/note-operations.ts
  - apps/omnii_mcp/src/notes/graph/link-resolver.ts
  - apps/omnii_mcp/src/notes/graph/backlinks-query.ts
  - apps/omnii_mcp/src/notes/graph/index.ts
autonomous: true

must_haves:
  truths:
    - "Notes can be created with LINKS_TO relationships for wikilinks"
    - "Stub notes are created for forward references"
    - "Backlinks query returns notes that link to a target"
    - "Single directional relationships traversable both ways"
  artifacts:
    - path: "apps/omnii_mcp/src/notes/graph/note-operations.ts"
      provides: "CRUD operations for Note nodes"
      exports: ["createNote", "updateNote", "deleteNote", "getNoteById", "getNoteByNormalizedTitle"]
    - path: "apps/omnii_mcp/src/notes/graph/link-resolver.ts"
      provides: "Creates LINKS_TO relationships from wikilinks"
      exports: ["resolveWikilinks", "removeStaleLinks"]
    - path: "apps/omnii_mcp/src/notes/graph/backlinks-query.ts"
      provides: "Query backlinks for a note"
      exports: ["getBacklinks", "getBacklinkCount", "getBacklinksForEntity"]
  key_links:
    - from: "apps/omnii_mcp/src/notes/graph/note-operations.ts"
      to: "apps/omnii_mcp/src/services/neo4j/http-client.ts"
      via: "Neo4jHTTPClient for Cypher queries"
      pattern: "Neo4jHTTPClient"
    - from: "apps/omnii_mcp/src/notes/graph/link-resolver.ts"
      to: "apps/omnii_mcp/src/notes/parsers/wikilink-parser.ts"
      via: "extractWikilinks for parsing content"
      pattern: "import.*extractWikilinks.*from.*parsers"
---

<objective>
Create Neo4j graph operations for notes including CRUD, wikilink resolution, and backlinks queries

Purpose: Implements bidirectional linking by creating LINKS_TO relationships when notes contain [[wikilinks]] and enabling backlinks discovery
Output: Note CRUD operations, wikilink-to-relationship resolver, backlinks query functions
</objective>

<execution_context>
@/Users/santino/.claude/get-shit-done/workflows/execute-plan.md
@/Users/santino/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-notes-capture-system/09-RESEARCH.md
@apps/omnii_mcp/src/notes/types.ts
@apps/omnii_mcp/src/notes/parsers/wikilink-parser.ts
@apps/omnii_mcp/src/graph/schema/nodes.ts
@apps/omnii_mcp/src/ingestion/sources/files/graph-operations.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create note CRUD operations</name>
  <files>apps/omnii_mcp/src/notes/graph/note-operations.ts</files>
  <action>
Create Neo4j CRUD operations for Note nodes following the established pattern from file graph-operations.

Create `apps/omnii_mcp/src/notes/graph/note-operations.ts`:

```typescript
/**
 * Note Graph Operations
 *
 * CRUD operations for Note nodes in Neo4j.
 * Creates notes with proper normalization for wikilink matching.
 */

import { nanoid } from 'nanoid';
import type { Neo4jHTTPClient } from '../../services/neo4j/http-client';
import type { NoteNode } from '../../graph/schema/nodes';
import type { NoteInput, NoteUpdateInput, CreateNoteResult } from '../types';
import { normalizeTitle } from '../parsers/wikilink-parser';

/**
 * Create a new note in the graph.
 *
 * Does NOT resolve wikilinks - use link-resolver after creation.
 *
 * @param client - Neo4j HTTP client
 * @param input - Note creation input
 * @returns Created note ID and metadata
 */
export async function createNote(
  client: Neo4jHTTPClient,
  input: NoteInput
): Promise<{ noteId: string; normalizedTitle: string }> {
  const noteId = `note_${nanoid(12)}`;
  const normalizedTitle = normalizeTitle(input.title);
  const now = new Date().toISOString();

  const cypher = `
    CREATE (n:Note {
      id: $id,
      name: $title,
      title: $title,
      normalizedTitle: $normalizedTitle,
      content: $content,
      frontmatter: $frontmatter,
      templateType: $templateType,
      isStub: false,
      createdVia: $createdVia,
      createdAt: datetime($createdAt),
      updatedAt: datetime($createdAt),
      linkCount: 0,
      backlinkCount: 0
    })
    RETURN n.id AS id
  `;

  try {
    await client.query(cypher, {
      id: noteId,
      title: input.title,
      normalizedTitle,
      content: input.content,
      frontmatter: input.frontmatter ? JSON.stringify(input.frontmatter) : null,
      templateType: input.templateType || null,
      createdVia: input.createdVia,
      createdAt: now,
    });

    return { noteId, normalizedTitle };
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    throw new Error(`Failed to create note: ${message}`);
  }
}

/**
 * Create a stub note for forward wikilink reference.
 * Used when a [[link]] targets a note that doesn't exist yet.
 *
 * @param client - Neo4j HTTP client
 * @param normalizedTitle - Normalized title from wikilink
 * @param displayTitle - Original display text from wikilink
 * @returns Created stub note ID
 */
export async function createStubNote(
  client: Neo4jHTTPClient,
  normalizedTitle: string,
  displayTitle: string
): Promise<string> {
  const noteId = `note_${nanoid(12)}`;
  const now = new Date().toISOString();

  const cypher = `
    MERGE (n:Note {normalizedTitle: $normalizedTitle})
    ON CREATE SET
      n.id = $id,
      n.name = $displayTitle,
      n.title = $displayTitle,
      n.content = '',
      n.isStub = true,
      n.createdVia = 'wikilink-stub',
      n.createdAt = datetime($createdAt),
      n.updatedAt = datetime($createdAt),
      n.linkCount = 0,
      n.backlinkCount = 0
    RETURN n.id AS id
  `;

  try {
    const result = await client.query(cypher, {
      id: noteId,
      normalizedTitle,
      displayTitle,
      createdAt: now,
    });

    const fields = result.data?.fields || [];
    const idIndex = fields.indexOf('id');
    return result.data?.values?.[0]?.[idIndex] as string || noteId;
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    throw new Error(`Failed to create stub note: ${message}`);
  }
}

/**
 * Get note by ID.
 *
 * @param client - Neo4j HTTP client
 * @param noteId - Note UUID
 * @returns Note or null
 */
export async function getNoteById(
  client: Neo4jHTTPClient,
  noteId: string
): Promise<NoteNode | null> {
  const cypher = `
    MATCH (n:Note {id: $id})
    RETURN n {
      .id, .name, .title, .normalizedTitle, .content,
      .frontmatter, .templateType, .isStub, .createdVia,
      .linkCount, .backlinkCount,
      createdAt: toString(n.createdAt),
      updatedAt: toString(n.updatedAt)
    } AS note
  `;

  try {
    const result = await client.query(cypher, { id: noteId });

    if (!result.data?.values?.length) {
      return null;
    }

    const fields = result.data.fields;
    const noteIndex = fields.indexOf('note');
    return result.data.values[0][noteIndex] as NoteNode;
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    throw new Error(`Failed to get note: ${message}`);
  }
}

/**
 * Get note by normalized title (for wikilink resolution).
 *
 * @param client - Neo4j HTTP client
 * @param normalizedTitle - Normalized title to look up
 * @returns Note or null
 */
export async function getNoteByNormalizedTitle(
  client: Neo4jHTTPClient,
  normalizedTitle: string
): Promise<NoteNode | null> {
  const cypher = `
    MATCH (n:Note {normalizedTitle: $normalizedTitle})
    RETURN n {
      .id, .name, .title, .normalizedTitle, .content,
      .frontmatter, .templateType, .isStub, .createdVia,
      .linkCount, .backlinkCount,
      createdAt: toString(n.createdAt),
      updatedAt: toString(n.updatedAt)
    } AS note
  `;

  try {
    const result = await client.query(cypher, { normalizedTitle });

    if (!result.data?.values?.length) {
      return null;
    }

    const fields = result.data.fields;
    const noteIndex = fields.indexOf('note');
    return result.data.values[0][noteIndex] as NoteNode;
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    throw new Error(`Failed to get note by title: ${message}`);
  }
}

/**
 * Update an existing note.
 *
 * @param client - Neo4j HTTP client
 * @param noteId - Note ID to update
 * @param updates - Fields to update
 */
export async function updateNote(
  client: Neo4jHTTPClient,
  noteId: string,
  updates: NoteUpdateInput
): Promise<void> {
  const setClauses: string[] = ['n.updatedAt = datetime()'];
  const params: Record<string, unknown> = { id: noteId };

  if (updates.title !== undefined) {
    setClauses.push('n.title = $title');
    setClauses.push('n.name = $title');
    setClauses.push('n.normalizedTitle = $normalizedTitle');
    params.title = updates.title;
    params.normalizedTitle = normalizeTitle(updates.title);
  }

  if (updates.content !== undefined) {
    setClauses.push('n.content = $content');
    params.content = updates.content;
  }

  if (updates.frontmatter !== undefined) {
    setClauses.push('n.frontmatter = $frontmatter');
    params.frontmatter = JSON.stringify(updates.frontmatter);
  }

  // If updating a stub to full note
  setClauses.push('n.isStub = false');

  const cypher = `
    MATCH (n:Note {id: $id})
    SET ${setClauses.join(', ')}
  `;

  try {
    await client.query(cypher, params);
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    throw new Error(`Failed to update note: ${message}`);
  }
}

/**
 * Delete a note and its relationships.
 *
 * @param client - Neo4j HTTP client
 * @param noteId - Note ID to delete
 */
export async function deleteNote(
  client: Neo4jHTTPClient,
  noteId: string
): Promise<void> {
  const cypher = `
    MATCH (n:Note {id: $id})
    DETACH DELETE n
  `;

  try {
    await client.query(cypher, { id: noteId });
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    throw new Error(`Failed to delete note: ${message}`);
  }
}

/**
 * List recent notes.
 *
 * @param client - Neo4j HTTP client
 * @param limit - Max notes to return
 * @param includeStubs - Whether to include stub notes
 * @returns Array of notes
 */
export async function listRecentNotes(
  client: Neo4jHTTPClient,
  limit: number = 50,
  includeStubs: boolean = false
): Promise<NoteNode[]> {
  const stubFilter = includeStubs ? '' : 'WHERE n.isStub = false';

  const cypher = `
    MATCH (n:Note)
    ${stubFilter}
    RETURN n {
      .id, .name, .title, .normalizedTitle,
      .templateType, .isStub, .createdVia,
      .linkCount, .backlinkCount,
      createdAt: toString(n.createdAt),
      updatedAt: toString(n.updatedAt)
    } AS note
    ORDER BY n.updatedAt DESC
    LIMIT $limit
  `;

  try {
    const result = await client.query(cypher, { limit });

    if (!result.data?.values?.length) {
      return [];
    }

    const fields = result.data.fields;
    const noteIndex = fields.indexOf('note');
    return result.data.values.map((row) => row[noteIndex] as NoteNode);
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    throw new Error(`Failed to list notes: ${message}`);
  }
}

/**
 * Search notes by title.
 *
 * @param client - Neo4j HTTP client
 * @param query - Search query
 * @param limit - Max results
 * @returns Matching notes
 */
export async function searchNotesByTitle(
  client: Neo4jHTTPClient,
  query: string,
  limit: number = 20
): Promise<NoteNode[]> {
  const normalizedQuery = normalizeTitle(query);

  const cypher = `
    MATCH (n:Note)
    WHERE n.normalizedTitle CONTAINS $query
       OR toLower(n.title) CONTAINS toLower($rawQuery)
    RETURN n {
      .id, .name, .title, .normalizedTitle,
      .isStub, .createdVia,
      createdAt: toString(n.createdAt)
    } AS note
    ORDER BY n.isStub ASC, n.updatedAt DESC
    LIMIT $limit
  `;

  try {
    const result = await client.query(cypher, {
      query: normalizedQuery,
      rawQuery: query,
      limit,
    });

    if (!result.data?.values?.length) {
      return [];
    }

    const fields = result.data.fields;
    const noteIndex = fields.indexOf('note');
    return result.data.values.map((row) => row[noteIndex] as NoteNode);
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    throw new Error(`Failed to search notes: ${message}`);
  }
}

/**
 * Update link counts on a note.
 *
 * @param client - Neo4j HTTP client
 * @param noteId - Note ID
 */
export async function updateNoteLinkCounts(
  client: Neo4jHTTPClient,
  noteId: string
): Promise<void> {
  const cypher = `
    MATCH (n:Note {id: $id})
    OPTIONAL MATCH (n)-[out:LINKS_TO]->()
    OPTIONAL MATCH ()-[in:LINKS_TO]->(n)
    WITH n, count(DISTINCT out) AS outLinks, count(DISTINCT in) AS inLinks
    SET n.linkCount = outLinks, n.backlinkCount = inLinks
  `;

  try {
    await client.query(cypher, { id: noteId });
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    throw new Error(`Failed to update link counts: ${message}`);
  }
}
```
  </action>
  <verify>Run `bun typecheck --filter omnii_mcp`. Verify all exported functions are typed correctly.</verify>
  <done>note-operations.ts exports createNote, createStubNote, getNoteById, getNoteByNormalizedTitle, updateNote, deleteNote, listRecentNotes, searchNotesByTitle, updateNoteLinkCounts</done>
</task>

<task type="auto">
  <name>Task 2: Create wikilink resolver</name>
  <files>apps/omnii_mcp/src/notes/graph/link-resolver.ts</files>
  <action>
Create wikilink resolver that creates LINKS_TO relationships from [[wikilinks]] in note content.

Create `apps/omnii_mcp/src/notes/graph/link-resolver.ts`:

```typescript
/**
 * Wikilink Resolver
 *
 * Creates LINKS_TO relationships from [[wikilinks]] in note content.
 * Creates stub notes for forward references to non-existent notes.
 *
 * Key principle: Single directional LINKS_TO relationship.
 * Neo4j traverses relationships in both directions at same speed,
 * so we don't need duplicate relationships for bidirectional linking.
 */

import type { Neo4jHTTPClient } from '../../services/neo4j/http-client';
import { extractWikilinks } from '../parsers/wikilink-parser';
import type { WikilinkMatch } from '../types';

/**
 * Result from resolving wikilinks.
 */
export interface ResolveResult {
  /** Number of LINKS_TO relationships created */
  linksCreated: number;
  /** Number of stub notes created for forward references */
  stubsCreated: number;
  /** Normalized targets that were linked */
  targets: string[];
}

/**
 * Resolve wikilinks in a note's content.
 *
 * For each [[wikilink]] found:
 * 1. Find or create target note (stub if doesn't exist)
 * 2. Create LINKS_TO relationship from source to target
 *
 * Uses MERGE to avoid duplicate relationships.
 *
 * @param client - Neo4j HTTP client
 * @param sourceNoteId - ID of the note containing wikilinks
 * @param content - Note content to parse for wikilinks
 * @returns Resolution statistics
 */
export async function resolveWikilinks(
  client: Neo4jHTTPClient,
  sourceNoteId: string,
  content: string
): Promise<ResolveResult> {
  const wikilinks = extractWikilinks(content);

  if (wikilinks.length === 0) {
    return { linksCreated: 0, stubsCreated: 0, targets: [] };
  }

  // Cypher to create links with stub note creation
  // Uses MERGE for idempotency (safe to run multiple times)
  const cypher = `
    MATCH (source:Note {id: $sourceId})
    UNWIND $targets AS target

    // Find or create target note
    MERGE (targetNote:Note {normalizedTitle: target.normalized})
    ON CREATE SET
      targetNote.id = 'note_' + substring(randomUUID(), 0, 12),
      targetNote.name = target.display,
      targetNote.title = target.display,
      targetNote.content = '',
      targetNote.isStub = true,
      targetNote.createdVia = 'wikilink-stub',
      targetNote.createdAt = datetime(),
      targetNote.updatedAt = datetime(),
      targetNote.linkCount = 0,
      targetNote.backlinkCount = 0

    // Create link relationship (only if not exists)
    MERGE (source)-[:LINKS_TO]->(targetNote)

    // Return what we did
    RETURN targetNote.id AS targetId, targetNote.isStub AS isStub
  `;

  try {
    const targets = wikilinks.map((link) => ({
      normalized: link.normalizedTarget,
      display: link.display,
    }));

    const result = await client.query(cypher, {
      sourceId: sourceNoteId,
      targets,
    });

    // Count stubs created
    let stubsCreated = 0;
    if (result.data?.values?.length) {
      const fields = result.data.fields;
      const stubIndex = fields.indexOf('isStub');
      for (const row of result.data.values) {
        if (row[stubIndex] === true) {
          stubsCreated++;
        }
      }
    }

    // Update source note's link count
    await updateSourceLinkCount(client, sourceNoteId, wikilinks.length);

    // Update backlink counts on all targets
    await updateTargetBacklinkCounts(
      client,
      wikilinks.map((w) => w.normalizedTarget)
    );

    return {
      linksCreated: wikilinks.length,
      stubsCreated,
      targets: wikilinks.map((w) => w.normalizedTarget),
    };
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    throw new Error(`Failed to resolve wikilinks: ${message}`);
  }
}

/**
 * Remove stale LINKS_TO relationships when note content changes.
 * Call before resolveWikilinks to ensure links match current content.
 *
 * @param client - Neo4j HTTP client
 * @param noteId - Note ID to clean up
 * @param currentTargets - Normalized targets that should remain linked
 */
export async function removeStaleLinks(
  client: Neo4jHTTPClient,
  noteId: string,
  currentTargets: string[]
): Promise<number> {
  const cypher = `
    MATCH (source:Note {id: $noteId})-[r:LINKS_TO]->(target:Note)
    WHERE NOT target.normalizedTitle IN $currentTargets
    DELETE r
    RETURN count(r) AS removed
  `;

  try {
    const result = await client.query(cypher, {
      noteId,
      currentTargets,
    });

    const fields = result.data?.fields || [];
    const removedIndex = fields.indexOf('removed');
    return (result.data?.values?.[0]?.[removedIndex] as number) || 0;
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    throw new Error(`Failed to remove stale links: ${message}`);
  }
}

/**
 * Update a note's outgoing link count.
 */
async function updateSourceLinkCount(
  client: Neo4jHTTPClient,
  noteId: string,
  count: number
): Promise<void> {
  const cypher = `
    MATCH (n:Note {id: $id})
    SET n.linkCount = $count
  `;

  await client.query(cypher, { id: noteId, count });
}

/**
 * Update backlink counts on target notes.
 */
async function updateTargetBacklinkCounts(
  client: Neo4jHTTPClient,
  normalizedTitles: string[]
): Promise<void> {
  const cypher = `
    UNWIND $titles AS title
    MATCH (target:Note {normalizedTitle: title})
    OPTIONAL MATCH ()-[r:LINKS_TO]->(target)
    WITH target, count(r) AS backlinks
    SET target.backlinkCount = backlinks
  `;

  await client.query(cypher, { titles: normalizedTitles });
}

/**
 * Get all notes linked from a source note.
 *
 * @param client - Neo4j HTTP client
 * @param noteId - Source note ID
 * @returns Array of linked note IDs and titles
 */
export async function getOutgoingLinks(
  client: Neo4jHTTPClient,
  noteId: string
): Promise<Array<{ id: string; title: string; isStub: boolean }>> {
  const cypher = `
    MATCH (source:Note {id: $noteId})-[:LINKS_TO]->(target:Note)
    RETURN target.id AS id, target.title AS title, target.isStub AS isStub
    ORDER BY target.title
  `;

  try {
    const result = await client.query(cypher, { noteId });

    if (!result.data?.values?.length) {
      return [];
    }

    const fields = result.data.fields;
    const idIndex = fields.indexOf('id');
    const titleIndex = fields.indexOf('title');
    const stubIndex = fields.indexOf('isStub');

    return result.data.values.map((row) => ({
      id: row[idIndex] as string,
      title: row[titleIndex] as string,
      isStub: row[stubIndex] as boolean,
    }));
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    throw new Error(`Failed to get outgoing links: ${message}`);
  }
}

/**
 * Process note update: remove stale links, then resolve current links.
 * Convenience function for the common update workflow.
 *
 * @param client - Neo4j HTTP client
 * @param noteId - Note being updated
 * @param newContent - New content to parse and link
 * @returns Resolution result
 */
export async function updateNoteLinks(
  client: Neo4jHTTPClient,
  noteId: string,
  newContent: string
): Promise<ResolveResult> {
  const wikilinks = extractWikilinks(newContent);
  const currentTargets = wikilinks.map((w) => w.normalizedTarget);

  // Remove links that no longer exist in content
  await removeStaleLinks(client, noteId, currentTargets);

  // Resolve current links (creates new ones, MERGE handles existing)
  return resolveWikilinks(client, noteId, newContent);
}
```
  </action>
  <verify>Run `bun typecheck --filter omnii_mcp`. Verify MERGE patterns are correct for idempotent link creation.</verify>
  <done>link-resolver.ts exports resolveWikilinks, removeStaleLinks, getOutgoingLinks, updateNoteLinks functions</done>
</task>

<task type="auto">
  <name>Task 3: Create backlinks query and module index</name>
  <files>
apps/omnii_mcp/src/notes/graph/backlinks-query.ts
apps/omnii_mcp/src/notes/graph/index.ts
  </files>
  <action>
Create backlinks query for fetching notes that link to a target, and barrel export.

Create `apps/omnii_mcp/src/notes/graph/backlinks-query.ts`:

```typescript
/**
 * Backlinks Query
 *
 * Queries for notes that link TO a given target note.
 * Uses Neo4j's efficient reverse relationship traversal.
 *
 * Key insight: MATCH (other)-[:LINKS_TO]->(target) is as fast
 * as forward traversal, no need for duplicate relationships.
 */

import type { Neo4jHTTPClient } from '../../services/neo4j/http-client';
import type { BacklinkResult, BacklinksData } from '../types';

/**
 * Get backlinks for a note.
 *
 * Returns notes that contain [[wikilinks]] pointing to the target.
 * Includes preview text around the link for context.
 *
 * @param client - Neo4j HTTP client
 * @param targetNoteId - Note ID to find backlinks for
 * @param limit - Max results (default 50)
 * @param offset - Pagination offset
 * @returns Backlinks data with results and count
 */
export async function getBacklinks(
  client: Neo4jHTTPClient,
  targetNoteId: string,
  limit: number = 50,
  offset: number = 0
): Promise<BacklinksData> {
  // First get total count
  const countCypher = `
    MATCH (other:Note)-[:LINKS_TO]->(target:Note {id: $targetId})
    WHERE other.isStub = false
    RETURN count(other) AS total, target.title AS targetTitle
  `;

  // Then get paginated results with preview
  const resultsCypher = `
    MATCH (other:Note)-[:LINKS_TO]->(target:Note {id: $targetId})
    WHERE other.isStub = false

    // Extract preview: first 150 chars or content around wikilink
    WITH other, target,
      CASE
        WHEN size(other.content) <= 150 THEN other.content
        ELSE substring(other.content, 0, 150) + '...'
      END AS preview

    RETURN other.id AS noteId,
           other.title AS title,
           preview,
           toString(other.updatedAt) AS updatedAt
    ORDER BY other.updatedAt DESC
    SKIP $offset
    LIMIT $limit
  `;

  try {
    // Get count
    const countResult = await client.query(countCypher, { targetId: targetNoteId });

    let totalCount = 0;
    let targetTitle = '';
    if (countResult.data?.values?.length) {
      const fields = countResult.data.fields;
      const totalIndex = fields.indexOf('total');
      const titleIndex = fields.indexOf('targetTitle');
      totalCount = countResult.data.values[0][totalIndex] as number;
      targetTitle = countResult.data.values[0][titleIndex] as string;
    }

    // Get results
    const resultsResult = await client.query(resultsCypher, {
      targetId: targetNoteId,
      limit,
      offset,
    });

    const backlinks: BacklinkResult[] = [];
    if (resultsResult.data?.values?.length) {
      const fields = resultsResult.data.fields;
      const noteIdIndex = fields.indexOf('noteId');
      const titleIndex = fields.indexOf('title');
      const previewIndex = fields.indexOf('preview');
      const updatedAtIndex = fields.indexOf('updatedAt');

      for (const row of resultsResult.data.values) {
        backlinks.push({
          noteId: row[noteIdIndex] as string,
          title: row[titleIndex] as string,
          preview: row[previewIndex] as string,
          updatedAt: row[updatedAtIndex] as string,
        });
      }
    }

    return {
      targetId: targetNoteId,
      targetTitle,
      backlinks,
      totalCount,
    };
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    throw new Error(`Failed to get backlinks: ${message}`);
  }
}

/**
 * Get backlink count for a note.
 * Fast count query without fetching full backlink data.
 *
 * @param client - Neo4j HTTP client
 * @param targetNoteId - Note ID
 * @returns Number of backlinks
 */
export async function getBacklinkCount(
  client: Neo4jHTTPClient,
  targetNoteId: string
): Promise<number> {
  const cypher = `
    MATCH (other:Note)-[:LINKS_TO]->(target:Note {id: $targetId})
    WHERE other.isStub = false
    RETURN count(other) AS count
  `;

  try {
    const result = await client.query(cypher, { targetId: targetNoteId });

    if (!result.data?.values?.length) {
      return 0;
    }

    const fields = result.data.fields;
    const countIndex = fields.indexOf('count');
    return result.data.values[0][countIndex] as number;
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    throw new Error(`Failed to get backlink count: ${message}`);
  }
}

/**
 * Get backlinks for an entity node (not just notes).
 * Allows notes to link to Person, Organization, etc.
 *
 * @param client - Neo4j HTTP client
 * @param entityId - Entity node ID
 * @param limit - Max results
 * @returns Backlinks data
 */
export async function getBacklinksForEntity(
  client: Neo4jHTTPClient,
  entityId: string,
  limit: number = 50
): Promise<BacklinksData> {
  const cypher = `
    MATCH (note:Note)-[:MENTIONS|LINKS_TO]->(entity {id: $entityId})
    WHERE note.isStub = false

    WITH note, entity,
      CASE
        WHEN size(note.content) <= 150 THEN note.content
        ELSE substring(note.content, 0, 150) + '...'
      END AS preview

    RETURN note.id AS noteId,
           note.title AS title,
           preview,
           toString(note.updatedAt) AS updatedAt,
           labels(entity)[0] AS entityType,
           entity.name AS entityName
    ORDER BY note.updatedAt DESC
    LIMIT $limit
  `;

  try {
    const result = await client.query(cypher, { entityId, limit });

    const backlinks: BacklinkResult[] = [];
    let targetTitle = '';

    if (result.data?.values?.length) {
      const fields = result.data.fields;
      const noteIdIndex = fields.indexOf('noteId');
      const titleIndex = fields.indexOf('title');
      const previewIndex = fields.indexOf('preview');
      const updatedAtIndex = fields.indexOf('updatedAt');
      const entityNameIndex = fields.indexOf('entityName');

      for (const row of result.data.values) {
        backlinks.push({
          noteId: row[noteIdIndex] as string,
          title: row[titleIndex] as string,
          preview: row[previewIndex] as string,
          updatedAt: row[updatedAtIndex] as string,
        });
      }

      // Use entity name as target title
      targetTitle = result.data.values[0][entityNameIndex] as string;
    }

    return {
      targetId: entityId,
      targetTitle,
      backlinks,
      totalCount: backlinks.length,
    };
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    throw new Error(`Failed to get entity backlinks: ${message}`);
  }
}

/**
 * Get notes with most backlinks (popular/hub notes).
 *
 * @param client - Neo4j HTTP client
 * @param limit - Max results
 * @returns Notes sorted by backlink count
 */
export async function getMostLinkedNotes(
  client: Neo4jHTTPClient,
  limit: number = 10
): Promise<Array<{ id: string; title: string; backlinkCount: number }>> {
  const cypher = `
    MATCH (n:Note)
    WHERE n.isStub = false AND n.backlinkCount > 0
    RETURN n.id AS id, n.title AS title, n.backlinkCount AS backlinkCount
    ORDER BY n.backlinkCount DESC
    LIMIT $limit
  `;

  try {
    const result = await client.query(cypher, { limit });

    if (!result.data?.values?.length) {
      return [];
    }

    const fields = result.data.fields;
    const idIndex = fields.indexOf('id');
    const titleIndex = fields.indexOf('title');
    const countIndex = fields.indexOf('backlinkCount');

    return result.data.values.map((row) => ({
      id: row[idIndex] as string,
      title: row[titleIndex] as string,
      backlinkCount: row[countIndex] as number,
    }));
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    throw new Error(`Failed to get most linked notes: ${message}`);
  }
}
```

Create `apps/omnii_mcp/src/notes/graph/index.ts`:

```typescript
/**
 * Notes Graph Operations Module
 *
 * Exports CRUD operations, wikilink resolution, and backlinks queries.
 */

// Note CRUD operations
export {
  createNote,
  createStubNote,
  getNoteById,
  getNoteByNormalizedTitle,
  updateNote,
  deleteNote,
  listRecentNotes,
  searchNotesByTitle,
  updateNoteLinkCounts,
} from './note-operations';

// Wikilink resolution
export {
  resolveWikilinks,
  removeStaleLinks,
  getOutgoingLinks,
  updateNoteLinks,
} from './link-resolver';

export type { ResolveResult } from './link-resolver';

// Backlinks queries
export {
  getBacklinks,
  getBacklinkCount,
  getBacklinksForEntity,
  getMostLinkedNotes,
} from './backlinks-query';
```
  </action>
  <verify>Run `bun typecheck --filter omnii_mcp`. Verify backlinks query uses reverse traversal `(other)-[:LINKS_TO]->(target)` pattern.</verify>
  <done>backlinks-query.ts exports getBacklinks, getBacklinkCount, getBacklinksForEntity, getMostLinkedNotes; graph/index.ts barrel exports all operations</done>
</task>

</tasks>

<verification>
1. `bun typecheck --filter omnii_mcp` passes
2. createNote creates Note with normalizedTitle for wikilink matching
3. resolveWikilinks creates LINKS_TO relationships and stub notes
4. getBacklinks queries reverse direction efficiently
5. All functions exported from graph/index.ts
</verification>

<success_criteria>
- Note CRUD operations follow established graph-operations pattern
- Wikilink resolver creates LINKS_TO + stubs with MERGE
- Backlinks query uses efficient reverse traversal
- Link counts maintained on notes
- Ready for note routes in 09-05
</success_criteria>

<output>
After completion, create `.planning/phases/09-notes-capture-system/09-04-SUMMARY.md`
</output>
