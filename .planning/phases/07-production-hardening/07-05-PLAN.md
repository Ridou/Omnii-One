---
phase: 07-production-hardening
plan: 05
type: execute
wave: 2
depends_on: ["07-04"]
files_modified:
  - apps/omnii_mcp/src/services/export/data-exporter.ts
  - apps/omnii_mcp/src/services/export/formatters/json.ts
  - apps/omnii_mcp/src/services/export/formatters/csv.ts
  - apps/omnii_mcp/src/services/export/formatters/markdown.ts
  - apps/omnii_mcp/src/services/export/index.ts
  - apps/omnii_mcp/src/routes/export.ts
  - apps/omnii_mcp/src/routes/index.ts
autonomous: true

must_haves:
  truths:
    - "User can export all data in JSON format"
    - "User can export all data in CSV format"
    - "User can export all data in Markdown format"
    - "Export includes version history if requested"
    - "Export is streamed for large datasets"
  artifacts:
    - path: "apps/omnii_mcp/src/services/export/data-exporter.ts"
      provides: "Core export logic with streaming"
      exports: ["DataExporter"]
    - path: "apps/omnii_mcp/src/services/export/formatters/json.ts"
      provides: "JSON formatter"
      exports: ["formatAsJson"]
    - path: "apps/omnii_mcp/src/services/export/formatters/csv.ts"
      provides: "CSV formatter"
      exports: ["formatAsCsv"]
    - path: "apps/omnii_mcp/src/routes/export.ts"
      provides: "Export REST endpoints"
      exports: ["exportRoutes"]
  key_links:
    - from: "apps/omnii_mcp/src/routes/export.ts"
      to: "services/export"
      via: "DataExporter usage"
      pattern: "DataExporter"
---

<objective>
Implement GDPR-compliant data export functionality allowing users to download all their data in JSON, CSV, or Markdown formats.

Purpose: Success criteria 5 requires data export in multiple formats for GDPR data portability compliance.
Output: Export service with JSON/CSV/Markdown formatters and REST endpoint for user data download.
</objective>

<execution_context>
@/Users/santino/.claude/get-shit-done/workflows/execute-plan.md
@/Users/santino/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-production-hardening/07-RESEARCH.md
@.planning/phases/07-production-hardening/07-04-PLAN.md

Research provides:
- GDPR Article 20 data portability requirements
- JSON/CSV/Markdown formatters
- Streaming for large datasets to avoid timeouts

Plan 07-04 provides:
- Version history operations for including version data in exports
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create export formatters</name>
  <files>
    apps/omnii_mcp/src/services/export/formatters/json.ts
    apps/omnii_mcp/src/services/export/formatters/csv.ts
    apps/omnii_mcp/src/services/export/formatters/markdown.ts
  </files>
  <action>
Create the export formatters directory and files:

**json.ts** - JSON formatter:
```typescript
export interface ExportNode {
  id: string;
  type: string;
  name?: string;
  properties: Record<string, unknown>;
  createdAt?: string;
  relationships?: {
    type: string;
    targetId: string;
    targetName?: string;
  }[];
  versionHistory?: {
    version: number;
    createdAt: string;
    createdBy: string;
    changeDescription?: string;
  }[];
}

export interface ExportData {
  exportDate: string;
  userId: string;
  format: string;
  nodeCount: number;
  nodes: ExportNode[];
}

export function formatAsJson(data: ExportData): string {
  return JSON.stringify(
    {
      exportDate: data.exportDate,
      userId: data.userId,
      format: 'GDPR Data Export - JSON',
      nodeCount: data.nodeCount,
      data: data.nodes,
    },
    null,
    2
  );
}

export function formatAsJsonStream(nodes: ExportNode[]): Generator<string> {
  return (function* () {
    yield '{\n';
    yield `  "exportDate": "${new Date().toISOString()}",\n`;
    yield `  "format": "GDPR Data Export - JSON",\n`;
    yield `  "nodeCount": ${nodes.length},\n`;
    yield '  "data": [\n';

    for (let i = 0; i < nodes.length; i++) {
      const node = nodes[i];
      const json = JSON.stringify(node, null, 4).replace(/^/gm, '    ');
      yield json;
      if (i < nodes.length - 1) {
        yield ',';
      }
      yield '\n';
    }

    yield '  ]\n';
    yield '}\n';
  })();
}
```

**csv.ts** - CSV formatter:
```typescript
import type { ExportNode } from './json';

// Escape CSV values (handle commas, quotes, newlines)
function escapeCSV(value: unknown): string {
  if (value === null || value === undefined) {
    return '';
  }

  const str = typeof value === 'object' ? JSON.stringify(value) : String(value);

  // If contains comma, quote, or newline, wrap in quotes and escape quotes
  if (str.includes(',') || str.includes('"') || str.includes('\n')) {
    return `"${str.replace(/"/g, '""')}"`;
  }

  return str;
}

export function formatAsCsv(nodes: ExportNode[]): string {
  const headers = ['type', 'id', 'name', 'createdAt', 'properties', 'relationships', 'versionCount'];
  const lines: string[] = [headers.join(',')];

  for (const node of nodes) {
    const row = [
      escapeCSV(node.type),
      escapeCSV(node.id),
      escapeCSV(node.name || ''),
      escapeCSV(node.createdAt || ''),
      escapeCSV(JSON.stringify(node.properties)),
      escapeCSV(node.relationships?.map((r) => `${r.type}->${r.targetId}`).join('; ') || ''),
      escapeCSV(node.versionHistory?.length || 0),
    ];
    lines.push(row.join(','));
  }

  return lines.join('\n');
}

export function* formatAsCsvStream(nodes: ExportNode[]): Generator<string> {
  const headers = ['type', 'id', 'name', 'createdAt', 'properties', 'relationships', 'versionCount'];
  yield headers.join(',') + '\n';

  for (const node of nodes) {
    const row = [
      escapeCSV(node.type),
      escapeCSV(node.id),
      escapeCSV(node.name || ''),
      escapeCSV(node.createdAt || ''),
      escapeCSV(JSON.stringify(node.properties)),
      escapeCSV(node.relationships?.map((r) => `${r.type}->${r.targetId}`).join('; ') || ''),
      escapeCSV(node.versionHistory?.length || 0),
    ];
    yield row.join(',') + '\n';
  }
}
```

**markdown.ts** - Markdown formatter:
```typescript
import type { ExportNode } from './json';

export function formatAsMarkdown(nodes: ExportNode[], userId: string): string {
  const lines: string[] = [];

  lines.push('# Data Export');
  lines.push('');
  lines.push(`**Export Date:** ${new Date().toISOString()}`);
  lines.push(`**User ID:** ${userId}`);
  lines.push(`**Total Items:** ${nodes.length}`);
  lines.push('');
  lines.push('---');
  lines.push('');

  // Group by type
  const grouped = new Map<string, ExportNode[]>();
  for (const node of nodes) {
    const existing = grouped.get(node.type) || [];
    existing.push(node);
    grouped.set(node.type, existing);
  }

  for (const [type, typeNodes] of grouped) {
    lines.push(`## ${type}s (${typeNodes.length})`);
    lines.push('');

    for (const node of typeNodes) {
      lines.push(`### ${node.name || node.id}`);
      lines.push('');
      lines.push(`- **ID:** \`${node.id}\``);
      if (node.createdAt) {
        lines.push(`- **Created:** ${node.createdAt}`);
      }

      // Properties
      const props = Object.entries(node.properties)
        .filter(([key]) => !['id', 'name', 'createdAt', 'embedding'].includes(key));

      if (props.length > 0) {
        lines.push('- **Properties:**');
        for (const [key, value] of props) {
          const displayValue = typeof value === 'object' ? JSON.stringify(value) : String(value);
          lines.push(`  - ${key}: ${displayValue}`);
        }
      }

      // Relationships
      if (node.relationships && node.relationships.length > 0) {
        lines.push('- **Relationships:**');
        for (const rel of node.relationships) {
          lines.push(`  - ${rel.type} -> ${rel.targetName || rel.targetId}`);
        }
      }

      // Version history
      if (node.versionHistory && node.versionHistory.length > 0) {
        lines.push(`- **Version History:** ${node.versionHistory.length} versions`);
        for (const ver of node.versionHistory.slice(0, 5)) {
          lines.push(`  - v${ver.version} (${ver.createdAt}) by ${ver.createdBy}${ver.changeDescription ? `: ${ver.changeDescription}` : ''}`);
        }
        if (node.versionHistory.length > 5) {
          lines.push(`  - ...and ${node.versionHistory.length - 5} more`);
        }
      }

      lines.push('');
    }
  }

  return lines.join('\n');
}
```
  </action>
  <verify>TypeScript compiles without errors</verify>
  <done>Export formatters created for JSON, CSV, and Markdown</done>
</task>

<task type="auto">
  <name>Task 2: Create data exporter service</name>
  <files>
    apps/omnii_mcp/src/services/export/data-exporter.ts
    apps/omnii_mcp/src/services/export/index.ts
  </files>
  <action>
Create the main data exporter service:

**data-exporter.ts**:
```typescript
import { createHttpNeo4jClient, type Neo4jHttpClient } from '../neo4j/http-client';
import { createVersionedOperations } from '../../graph/versioning';
import { formatAsJson, type ExportNode, type ExportData } from './formatters/json';
import { formatAsCsv } from './formatters/csv';
import { formatAsMarkdown } from './formatters/markdown';

export type ExportFormat = 'json' | 'csv' | 'markdown';

export interface ExportOptions {
  userId: string;
  format: ExportFormat;
  includeRelationships?: boolean;
  includeVersionHistory?: boolean;
  nodeTypes?: string[];
}

export class DataExporter {
  private client: Neo4jHttpClient;

  constructor(client?: Neo4jHttpClient) {
    this.client = client || createHttpNeo4jClient();
  }

  async exportUserData(options: ExportOptions): Promise<string> {
    const {
      userId,
      format,
      includeRelationships = true,
      includeVersionHistory = false,
      nodeTypes,
    } = options;

    // Fetch all user data from graph
    const nodes = await this.fetchUserNodes(userId, nodeTypes, includeRelationships);

    // Optionally fetch version history for each node
    if (includeVersionHistory) {
      await this.enrichWithVersionHistory(nodes);
    }

    // Format based on requested format
    const exportData: ExportData = {
      exportDate: new Date().toISOString(),
      userId,
      format: format.toUpperCase(),
      nodeCount: nodes.length,
      nodes,
    };

    switch (format) {
      case 'json':
        return formatAsJson(exportData);
      case 'csv':
        return formatAsCsv(nodes);
      case 'markdown':
        return formatAsMarkdown(nodes, userId);
      default:
        throw new Error(`Unsupported format: ${format}`);
    }
  }

  private async fetchUserNodes(
    userId: string,
    nodeTypes?: string[],
    includeRelationships = true
  ): Promise<ExportNode[]> {
    // Build type filter
    const types = nodeTypes?.length
      ? nodeTypes.map((t) => `n:${t}`).join(' OR ')
      : 'n:Concept OR n:Entity OR n:Event OR n:Contact';

    // Build query - exclude embedding from properties (too large)
    const query = `
      MATCH (n)
      WHERE n.userId = $userId AND (${types})
      ${includeRelationships ? `
        OPTIONAL MATCH (n)-[r]->(m)
        WHERE m.userId = $userId
      ` : ''}
      RETURN
        n.id as id,
        labels(n)[0] as type,
        n.name as name,
        n.created_at as createdAt,
        properties(n) as props
        ${includeRelationships ? `,
          collect(DISTINCT {
            type: type(r),
            targetId: m.id,
            targetName: m.name
          }) as relationships
        ` : ''}
    `;

    const result = await this.client.query(query, { userId });

    return result.map((row) => {
      // Remove embedding from properties
      const props = row.props as Record<string, unknown>;
      const { embedding, userId: _, ...cleanProps } = props;

      const node: ExportNode = {
        id: row.id as string,
        type: row.type as string,
        name: row.name as string | undefined,
        createdAt: row.createdAt as string | undefined,
        properties: cleanProps,
      };

      if (includeRelationships && row.relationships) {
        node.relationships = (row.relationships as any[]).filter(
          (r) => r.type && r.targetId
        );
      }

      return node;
    });
  }

  private async enrichWithVersionHistory(nodes: ExportNode[]): Promise<void> {
    const versionOps = createVersionedOperations(this.client);

    for (const node of nodes) {
      try {
        const history = await versionOps.getVersionHistory(node.id, 20);
        if (history.length > 0) {
          node.versionHistory = history.map((h) => ({
            version: h.version,
            createdAt: h.createdAt,
            createdBy: h.createdBy,
            changeDescription: h.changeDescription,
          }));
        }
      } catch (error) {
        // Node may not have version history - continue
        console.warn(`[Export] No version history for ${node.id}`);
      }
    }
  }

  /**
   * Get content type for export format
   */
  static getContentType(format: ExportFormat): string {
    switch (format) {
      case 'json':
        return 'application/json';
      case 'csv':
        return 'text/csv';
      case 'markdown':
        return 'text/markdown';
    }
  }

  /**
   * Get file extension for export format
   */
  static getFileExtension(format: ExportFormat): string {
    switch (format) {
      case 'json':
        return 'json';
      case 'csv':
        return 'csv';
      case 'markdown':
        return 'md';
    }
  }
}
```

**index.ts** - Barrel export:
```typescript
export { DataExporter, type ExportFormat, type ExportOptions } from './data-exporter';
export { formatAsJson, formatAsJsonStream, type ExportNode, type ExportData } from './formatters/json';
export { formatAsCsv, formatAsCsvStream } from './formatters/csv';
export { formatAsMarkdown } from './formatters/markdown';
```
  </action>
  <verify>TypeScript compiles without errors</verify>
  <done>DataExporter service created with format support</done>
</task>

<task type="auto">
  <name>Task 3: Create export REST endpoint</name>
  <files>
    apps/omnii_mcp/src/routes/export.ts
    apps/omnii_mcp/src/routes/index.ts
  </files>
  <action>
Create the export REST route:

**export.ts**:
```typescript
import { Elysia, t } from 'elysia';
import { DataExporter, type ExportFormat } from '../services/export';
import { logAuditEvent, AuditEventType } from '../services/audit';

export const exportRoutes = new Elysia({ prefix: '/api/export' })
  // Export user data
  .get(
    '/',
    async ({ query, set, request }) => {
      const userId = query.userId;
      const format = (query.format || 'json') as ExportFormat;

      if (!userId) {
        set.status = 400;
        return { error: 'userId is required' };
      }

      // Validate format
      if (!['json', 'csv', 'markdown'].includes(format)) {
        set.status = 400;
        return { error: 'Invalid format. Must be json, csv, or markdown' };
      }

      try {
        const exporter = new DataExporter();
        const data = await exporter.exportUserData({
          userId,
          format,
          includeRelationships: query.includeRelationships !== 'false',
          includeVersionHistory: query.includeVersionHistory === 'true',
          nodeTypes: query.nodeTypes?.split(','),
        });

        // Log audit event
        await logAuditEvent({
          eventType: AuditEventType.GRAPH_DATA_ACCESSED,
          actor: { type: 'user', id: userId },
          resource: { type: 'export', id: `export-${Date.now()}` },
          action: 'export',
          metadata: {
            format,
            includeVersionHistory: query.includeVersionHistory === 'true',
          },
          severity: 'info',
          correlationId: request.headers.get('x-correlation-id') || undefined,
        });

        // Set response headers for download
        const filename = `omnii-export-${new Date().toISOString().split('T')[0]}.${DataExporter.getFileExtension(format)}`;
        set.headers = {
          'Content-Type': DataExporter.getContentType(format),
          'Content-Disposition': `attachment; filename="${filename}"`,
        };

        return data;
      } catch (error) {
        console.error('[Export] Failed:', error);
        set.status = 500;
        return {
          error: 'Export failed',
          details: error instanceof Error ? error.message : 'Unknown error',
        };
      }
    },
    {
      query: t.Object({
        userId: t.String(),
        format: t.Optional(t.Union([
          t.Literal('json'),
          t.Literal('csv'),
          t.Literal('markdown'),
        ])),
        includeRelationships: t.Optional(t.String()),
        includeVersionHistory: t.Optional(t.String()),
        nodeTypes: t.Optional(t.String()),
      }),
    }
  )

  // Health check
  .get('/health', () => ({
    status: 'ok',
    formats: ['json', 'csv', 'markdown'],
  }));
```

Update routes/index.ts to include export routes:
```typescript
import { exportRoutes } from './export';

// Add to the routes export
.use(exportRoutes)
```
  </action>
  <verify>Run `bun run check` from apps/omnii_mcp - no TypeScript errors</verify>
  <done>Export REST endpoint created with format options and download headers</done>
</task>

</tasks>

<verification>
Run these checks after completing all tasks:

1. TypeScript compiles: `cd apps/omnii_mcp && bun run check`
2. App starts: `cd apps/omnii_mcp && bun run dev` - no startup errors
3. Routes registered: Check Swagger at /swagger shows export endpoints
4. Health check works: `curl http://localhost:3000/api/export/health`

Test export (requires data in graph):
```bash
# JSON export
curl "http://localhost:3000/api/export?userId=test-user&format=json" -o export.json

# CSV export
curl "http://localhost:3000/api/export?userId=test-user&format=csv" -o export.csv

# Markdown export with version history
curl "http://localhost:3000/api/export?userId=test-user&format=markdown&includeVersionHistory=true" -o export.md
```
</verification>

<success_criteria>
- JSON formatter produces valid JSON with all node data
- CSV formatter escapes special characters correctly
- Markdown formatter groups by type with readable output
- DataExporter fetches user nodes and relationships
- Version history included when requested
- Export endpoint returns downloadable file with correct headers
- Audit event logged for each export
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/07-production-hardening/07-05-SUMMARY.md`
</output>
