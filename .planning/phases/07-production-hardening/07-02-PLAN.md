---
phase: 07-production-hardening
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/omnii-mobile/package.json
  - apps/omnii-mobile/app.config.js
  - apps/omnii-mobile/src/lib/sentry.ts
  - apps/omnii-mobile/src/services/notifications/push-registration.ts
  - apps/omnii-mobile/src/services/notifications/notification-handlers.ts
  - apps/omnii-mobile/src/services/notifications/channels.ts
  - apps/omnii-mobile/src/services/notifications/index.ts
  - apps/omnii-mobile/src/app/_layout.tsx
autonomous: true

must_haves:
  truths:
    - "Mobile errors are captured and sent to Sentry"
    - "Push notification permission can be requested"
    - "Expo Push Token is obtained on physical device"
    - "Android notification channels are configured"
    - "Notification foreground behavior is configured"
  artifacts:
    - path: "apps/omnii-mobile/src/lib/sentry.ts"
      provides: "Sentry mobile initialization"
      exports: ["initSentry"]
    - path: "apps/omnii-mobile/src/services/notifications/push-registration.ts"
      provides: "Push token registration"
      exports: ["registerForPushNotifications", "getPushToken"]
    - path: "apps/omnii-mobile/src/services/notifications/notification-handlers.ts"
      provides: "Notification response handlers"
      exports: ["setupNotificationHandlers"]
  key_links:
    - from: "apps/omnii-mobile/src/app/_layout.tsx"
      to: "lib/sentry"
      via: "Sentry.wrap(RootLayout)"
      pattern: "Sentry\\.wrap"
---

<objective>
Set up Sentry for mobile error tracking and Expo push notifications for meeting reminders and workflow completions.

Purpose: Production mobile errors need tracking (success criteria 3), and users need push notifications for important events (success criteria 1).
Output: Sentry initialized in mobile app, push notification infrastructure ready for meeting reminders and workflow completions.
</objective>

<execution_context>
@/Users/santino/.claude/get-shit-done/workflows/execute-plan.md
@/Users/santino/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-production-hardening/07-RESEARCH.md

Research provides:
- @sentry/react-native ^7.8.0 for mobile error tracking
- expo-notifications for Expo Push service
- expo-device for device detection (required for push)
- Android notification channels for meeting reminders and workflow updates
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install mobile observability and notification dependencies</name>
  <files>apps/omnii-mobile/package.json, apps/omnii-mobile/app.config.js</files>
  <action>
Install Sentry and notification packages:

```bash
cd apps/omnii-mobile && npx expo install expo-notifications expo-device
cd apps/omnii-mobile && bun add @sentry/react-native
```

Update app.config.js to add Sentry Expo plugin configuration. Add to the plugins array:
```javascript
[
  '@sentry/react-native/expo',
  {
    organization: process.env.SENTRY_ORG,
    project: process.env.SENTRY_PROJECT,
  }
],
```

Also add notification permissions to Android config in app.config.js:
```javascript
android: {
  // ... existing config
  permissions: [
    'android.permission.POST_NOTIFICATIONS',
    // ... any existing permissions
  ],
},
```

Verify packages appear in package.json dependencies.
  </action>
  <verify>Run `grep -E "sentry|expo-notifications|expo-device" apps/omnii-mobile/package.json` shows all packages</verify>
  <done>Dependencies installed and Expo config updated for Sentry plugin</done>
</task>

<task type="auto">
  <name>Task 2: Create Sentry mobile initialization</name>
  <files>apps/omnii-mobile/src/lib/sentry.ts</files>
  <action>
Create Sentry initialization for React Native:

```typescript
import * as Sentry from '@sentry/react-native';

export function initSentry(): void {
  const dsn = process.env.EXPO_PUBLIC_SENTRY_DSN;

  if (!dsn) {
    console.warn('[Sentry] No DSN configured, skipping initialization');
    return;
  }

  Sentry.init({
    dsn,
    environment: __DEV__ ? 'development' : 'production',
    enableAutoSessionTracking: true,
    tracesSampleRate: __DEV__ ? 1.0 : 0.2,
    attachScreenshot: true,
    attachViewHierarchy: true,
    // Don't send errors in development unless testing Sentry
    enabled: !__DEV__ || !!process.env.EXPO_PUBLIC_SENTRY_DEBUG,
  });

  console.log('[Sentry] Initialized for', __DEV__ ? 'development' : 'production');
}

export { Sentry };
```

This initializes Sentry with:
- Screenshot and view hierarchy capture for better debugging
- Auto session tracking
- Lower sample rate in production (20%)
- Disabled in development by default (unless SENTRY_DEBUG set)
  </action>
  <verify>TypeScript compiles without errors</verify>
  <done>Sentry mobile initialization created</done>
</task>

<task type="auto">
  <name>Task 3: Create push notification services</name>
  <files>
    apps/omnii-mobile/src/services/notifications/push-registration.ts
    apps/omnii-mobile/src/services/notifications/notification-handlers.ts
    apps/omnii-mobile/src/services/notifications/channels.ts
    apps/omnii-mobile/src/services/notifications/index.ts
  </files>
  <action>
Create notification services directory and files:

**push-registration.ts** - Token registration:
```typescript
import * as Notifications from 'expo-notifications';
import * as Device from 'expo-device';
import Constants from 'expo-constants';
import { Platform } from 'react-native';
import { setupNotificationChannels } from './channels';

let cachedToken: string | null = null;

export async function registerForPushNotifications(): Promise<string | null> {
  // Push notifications only work on physical devices
  if (!Device.isDevice) {
    console.warn('[Push] Push notifications require a physical device');
    return null;
  }

  // Check existing permissions
  const { status: existingStatus } = await Notifications.getPermissionsAsync();
  let finalStatus = existingStatus;

  // Request if not already granted
  if (existingStatus !== 'granted') {
    const { status } = await Notifications.requestPermissionsAsync();
    finalStatus = status;
  }

  if (finalStatus !== 'granted') {
    console.warn('[Push] Permission not granted');
    return null;
  }

  // Set up Android notification channels
  if (Platform.OS === 'android') {
    await setupNotificationChannels();
  }

  // Get Expo Push Token
  try {
    const projectId = Constants.expoConfig?.extra?.eas?.projectId;
    const tokenResponse = await Notifications.getExpoPushTokenAsync({
      projectId,
    });
    cachedToken = tokenResponse.data;
    console.log('[Push] Token obtained:', cachedToken.substring(0, 20) + '...');
    return cachedToken;
  } catch (error) {
    console.error('[Push] Failed to get token:', error);
    return null;
  }
}

export function getPushToken(): string | null {
  return cachedToken;
}

// Listen for token changes (tokens can rotate)
export function setupTokenRefreshListener(
  onTokenChange: (token: string) => void
): () => void {
  const subscription = Notifications.addPushTokenListener((tokenData) => {
    cachedToken = tokenData.data;
    onTokenChange(tokenData.data);
  });

  return () => subscription.remove();
}
```

**notification-handlers.ts** - Response handlers:
```typescript
import * as Notifications from 'expo-notifications';
import { router } from 'expo-router';

// Configure foreground notification behavior
Notifications.setNotificationHandler({
  handleNotification: async () => ({
    shouldShowBanner: true,
    shouldShowList: true,
    shouldPlaySound: true,
    shouldSetBadge: true,
  }),
});

export interface NotificationData {
  type: 'meeting_reminder' | 'workflow_completion';
  meetingId?: string;
  workflowName?: string;
  success?: boolean;
}

export function setupNotificationHandlers(): () => void {
  // Handle notification received while app is foregrounded
  const receivedSubscription = Notifications.addNotificationReceivedListener(
    (notification) => {
      console.log('[Push] Notification received:', notification.request.identifier);
    }
  );

  // Handle user tapping on notification
  const responseSubscription = Notifications.addNotificationResponseReceivedListener(
    (response) => {
      const data = response.notification.request.content.data as NotificationData;

      switch (data.type) {
        case 'meeting_reminder':
          if (data.meetingId) {
            // Navigate to calendar/event detail
            router.push(`/(tabs)/timeline`);
          }
          break;
        case 'workflow_completion':
          // Navigate to workflow status or home
          router.push(`/(tabs)/`);
          break;
      }
    }
  );

  return () => {
    receivedSubscription.remove();
    responseSubscription.remove();
  };
}

// Schedule a meeting reminder notification
export async function scheduleMeetingReminder(
  meetingId: string,
  title: string,
  startsAt: Date,
  reminderMinutes: number = 10
): Promise<string> {
  const triggerTime = new Date(startsAt.getTime() - reminderMinutes * 60 * 1000);

  // Don't schedule if trigger time is in the past
  if (triggerTime.getTime() < Date.now()) {
    console.warn('[Push] Reminder time already passed');
    return '';
  }

  const notificationId = await Notifications.scheduleNotificationAsync({
    content: {
      title: 'Meeting Reminder',
      body: `${title} starts in ${reminderMinutes} minutes`,
      data: { type: 'meeting_reminder', meetingId } as NotificationData,
    },
    trigger: {
      type: Notifications.SchedulableTriggerInputTypes.DATE,
      date: triggerTime,
      channelId: 'reminders',
    },
  });

  return notificationId;
}

// Send immediate workflow completion notification
export async function notifyWorkflowComplete(
  workflowName: string,
  success: boolean,
  details?: string
): Promise<void> {
  await Notifications.scheduleNotificationAsync({
    content: {
      title: success ? 'Workflow Complete' : 'Workflow Failed',
      body: success
        ? `${workflowName} finished successfully`
        : `${workflowName} failed${details ? `: ${details}` : ''}`,
      data: {
        type: 'workflow_completion',
        workflowName,
        success,
      } as NotificationData,
    },
    trigger: null, // Immediate
  });
}

// Cancel a scheduled notification
export async function cancelNotification(notificationId: string): Promise<void> {
  await Notifications.cancelScheduledNotificationAsync(notificationId);
}
```

**channels.ts** - Android notification channels:
```typescript
import * as Notifications from 'expo-notifications';

export async function setupNotificationChannels(): Promise<void> {
  // Meeting reminders - high importance
  await Notifications.setNotificationChannelAsync('reminders', {
    name: 'Meeting Reminders',
    importance: Notifications.AndroidImportance.HIGH,
    vibrationPattern: [0, 250, 250, 250],
    lightColor: '#4F46E5', // Indigo
    sound: 'default',
    description: 'Notifications for upcoming meetings',
  });

  // Workflow updates - default importance
  await Notifications.setNotificationChannelAsync('workflows', {
    name: 'Workflow Updates',
    importance: Notifications.AndroidImportance.DEFAULT,
    lightColor: '#10B981', // Emerald
    sound: 'default',
    description: 'Notifications for workflow completions',
  });

  console.log('[Push] Android notification channels configured');
}
```

**index.ts** - Barrel export:
```typescript
export {
  registerForPushNotifications,
  getPushToken,
  setupTokenRefreshListener,
} from './push-registration';

export {
  setupNotificationHandlers,
  scheduleMeetingReminder,
  notifyWorkflowComplete,
  cancelNotification,
  type NotificationData,
} from './notification-handlers';

export { setupNotificationChannels } from './channels';
```
  </action>
  <verify>Run `cd apps/omnii-mobile && npx tsc --noEmit` - no TypeScript errors</verify>
  <done>Push notification services created with registration, handlers, and channels</done>
</task>

</tasks>

<verification>
Run these checks after completing all tasks:

1. TypeScript compiles: `cd apps/omnii-mobile && npx tsc --noEmit`
2. Dependencies installed: Check package.json has all packages
3. App config valid: `cd apps/omnii-mobile && npx expo config --type introspect` (no errors)

Note: Full push notification testing requires:
- Physical device (not emulator/simulator)
- EXPO_PUBLIC_SENTRY_DSN env var for Sentry
- EAS project ID in app.config.js for Expo Push service
</verification>

<success_criteria>
- Sentry SDK installed and lib/sentry.ts exports initSentry
- expo-notifications and expo-device installed
- Push registration requests permissions and obtains token
- Android notification channels configured (reminders, workflows)
- Notification handlers respond to taps with navigation
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/07-production-hardening/07-02-SUMMARY.md`
</output>
