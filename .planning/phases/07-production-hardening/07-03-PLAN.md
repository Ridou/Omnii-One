---
phase: 07-production-hardening
plan: 03
type: execute
wave: 2
depends_on: ["07-02"]
files_modified:
  - apps/omnii-mobile/package.json
  - apps/omnii-mobile/src/services/sync/adaptive-controller.ts
  - apps/omnii-mobile/src/services/sync/network-monitor.ts
  - apps/omnii-mobile/src/services/sync/index.ts
  - apps/omnii-mobile/src/context/SyncProvider.tsx
autonomous: true

must_haves:
  truths:
    - "Sync frequency adjusts based on network type (WiFi vs cellular)"
    - "Sync pauses when offline"
    - "Sync resumes when connection restored"
    - "Cellular connection triggers conservative sync (longer intervals)"
    - "WiFi connection allows frequent sync"
  artifacts:
    - path: "apps/omnii-mobile/src/services/sync/adaptive-controller.ts"
      provides: "Network-aware sync frequency controller"
      exports: ["AdaptiveSyncController"]
    - path: "apps/omnii-mobile/src/services/sync/network-monitor.ts"
      provides: "NetInfo wrapper with state tracking"
      exports: ["NetworkMonitor", "useNetworkState"]
  key_links:
    - from: "apps/omnii-mobile/src/context/SyncProvider.tsx"
      to: "services/sync/adaptive-controller"
      via: "AdaptiveSyncController instantiation"
      pattern: "AdaptiveSyncController"
---

<objective>
Implement adaptive sync frequency that adjusts based on network conditions to optimize battery usage and data freshness.

Purpose: Success criteria 2 requires adaptive sync based on network conditions to avoid draining battery on poor connections.
Output: AdaptiveSyncController that adjusts PowerSync polling frequency based on WiFi/cellular/offline state.
</objective>

<execution_context>
@/Users/santino/.claude/get-shit-done/workflows/execute-plan.md
@/Users/santino/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-production-hardening/07-RESEARCH.md
@.planning/phases/05-mobile-client-offline-sync/05-03-SUMMARY.md

Research provides:
- @react-native-community/netinfo ^11.x for network detection
- Adaptive sync pattern with network state machine
- PowerSync integration points in SyncProvider

Phase 5 Plan 3 established:
- SyncProvider with PowerSync lifecycle management
- OmniiConnector for sync operations
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install NetInfo dependency</name>
  <files>apps/omnii-mobile/package.json</files>
  <action>
Install the React Native NetInfo package:

```bash
cd apps/omnii-mobile && bun add @react-native-community/netinfo
```

This package provides:
- Network type detection (WiFi, cellular, none)
- Cellular generation (3G, 4G, 5G)
- Internet reachability checks
- Event subscription for network changes

Verify package appears in package.json dependencies.
  </action>
  <verify>Run `grep "netinfo" apps/omnii-mobile/package.json` shows the package</verify>
  <done>NetInfo package installed</done>
</task>

<task type="auto">
  <name>Task 2: Create adaptive sync services</name>
  <files>
    apps/omnii-mobile/src/services/sync/network-monitor.ts
    apps/omnii-mobile/src/services/sync/adaptive-controller.ts
    apps/omnii-mobile/src/services/sync/index.ts
  </files>
  <action>
Create the sync services directory and files:

**network-monitor.ts** - NetInfo wrapper:
```typescript
import NetInfo, { NetInfoState, NetInfoStateType } from '@react-native-community/netinfo';
import { useEffect, useState } from 'react';

export type NetworkQuality = 'excellent' | 'good' | 'poor' | 'offline';

export interface NetworkState {
  isConnected: boolean;
  isInternetReachable: boolean | null;
  type: NetInfoStateType;
  quality: NetworkQuality;
  cellularGeneration: string | null;
}

function determineQuality(state: NetInfoState): NetworkQuality {
  if (!state.isConnected || state.isInternetReachable === false) {
    return 'offline';
  }

  if (state.type === 'wifi') {
    return 'excellent';
  }

  if (state.type === 'cellular') {
    const details = state.details as any;
    const generation = details?.cellularGeneration;

    if (generation === '5g' || generation === '4g') {
      return 'good';
    }
    return 'poor';
  }

  // Ethernet or other
  return 'good';
}

function mapToNetworkState(state: NetInfoState): NetworkState {
  const details = state.details as any;

  return {
    isConnected: state.isConnected ?? false,
    isInternetReachable: state.isInternetReachable,
    type: state.type,
    quality: determineQuality(state),
    cellularGeneration: details?.cellularGeneration ?? null,
  };
}

export class NetworkMonitor {
  private listeners: Set<(state: NetworkState) => void> = new Set();
  private currentState: NetworkState | null = null;
  private unsubscribe: (() => void) | null = null;

  start(): void {
    this.unsubscribe = NetInfo.addEventListener((state) => {
      this.currentState = mapToNetworkState(state);
      this.listeners.forEach((listener) => listener(this.currentState!));
    });

    // Get initial state
    NetInfo.fetch().then((state) => {
      this.currentState = mapToNetworkState(state);
      this.listeners.forEach((listener) => listener(this.currentState!));
    });
  }

  stop(): void {
    this.unsubscribe?.();
    this.unsubscribe = null;
  }

  subscribe(listener: (state: NetworkState) => void): () => void {
    this.listeners.add(listener);

    // Send current state immediately if available
    if (this.currentState) {
      listener(this.currentState);
    }

    return () => {
      this.listeners.delete(listener);
    };
  }

  getState(): NetworkState | null {
    return this.currentState;
  }
}

// Singleton instance
let networkMonitor: NetworkMonitor | null = null;

export function getNetworkMonitor(): NetworkMonitor {
  if (!networkMonitor) {
    networkMonitor = new NetworkMonitor();
  }
  return networkMonitor;
}

// React hook for network state
export function useNetworkState(): NetworkState | null {
  const [state, setState] = useState<NetworkState | null>(null);

  useEffect(() => {
    const monitor = getNetworkMonitor();
    monitor.start();

    const unsubscribe = monitor.subscribe(setState);

    return () => {
      unsubscribe();
    };
  }, []);

  return state;
}
```

**adaptive-controller.ts** - Sync frequency controller:
```typescript
import { NetworkMonitor, NetworkState, NetworkQuality, getNetworkMonitor } from './network-monitor';
import { AppState, AppStateStatus } from 'react-native';

export type SyncFrequency = 'realtime' | 'frequent' | 'conservative' | 'paused';

export interface AdaptiveSyncConfig {
  // Intervals in milliseconds
  frequentInterval: number;      // Good network: 30s
  conservativeInterval: number;  // Poor network: 5 min
}

const DEFAULT_CONFIG: AdaptiveSyncConfig = {
  frequentInterval: 30_000,       // 30 seconds
  conservativeInterval: 300_000,  // 5 minutes
};

export class AdaptiveSyncController {
  private config: AdaptiveSyncConfig;
  private onSync: () => Promise<void>;
  private currentFrequency: SyncFrequency = 'paused';
  private syncTimer: NodeJS.Timeout | null = null;
  private networkUnsubscribe: (() => void) | null = null;
  private appStateSubscription: { remove: () => void } | null = null;
  private isAppActive = true;

  constructor(onSync: () => Promise<void>, config: Partial<AdaptiveSyncConfig> = {}) {
    this.onSync = onSync;
    this.config = { ...DEFAULT_CONFIG, ...config };
  }

  start(): void {
    const monitor = getNetworkMonitor();
    monitor.start();

    // Subscribe to network changes
    this.networkUnsubscribe = monitor.subscribe(this.handleNetworkChange);

    // Subscribe to app state (foreground/background)
    this.appStateSubscription = AppState.addEventListener('change', this.handleAppStateChange);

    console.log('[AdaptiveSync] Controller started');
  }

  stop(): void {
    this.networkUnsubscribe?.();
    this.appStateSubscription?.remove();
    this.clearSyncTimer();
    this.currentFrequency = 'paused';

    console.log('[AdaptiveSync] Controller stopped');
  }

  getFrequency(): SyncFrequency {
    return this.currentFrequency;
  }

  // Force a sync regardless of frequency
  async forceSync(): Promise<void> {
    console.log('[AdaptiveSync] Forcing sync');
    await this.onSync();
  }

  private handleAppStateChange = (nextAppState: AppStateStatus): void => {
    this.isAppActive = nextAppState === 'active';

    if (this.isAppActive) {
      // App came to foreground - resume sync
      console.log('[AdaptiveSync] App foregrounded, resuming sync');
      this.adjustSyncBehavior();
    } else {
      // App went to background - pause to save battery
      console.log('[AdaptiveSync] App backgrounded, pausing sync');
      this.clearSyncTimer();
    }
  };

  private handleNetworkChange = (state: NetworkState): void => {
    const newFrequency = this.determineFrequency(state.quality);

    if (newFrequency !== this.currentFrequency) {
      console.log(`[AdaptiveSync] Frequency change: ${this.currentFrequency} -> ${newFrequency}`);
      this.currentFrequency = newFrequency;

      if (this.isAppActive) {
        this.adjustSyncBehavior();
      }
    }
  };

  private determineFrequency(quality: NetworkQuality): SyncFrequency {
    switch (quality) {
      case 'excellent':
        return 'realtime';
      case 'good':
        return 'frequent';
      case 'poor':
        return 'conservative';
      case 'offline':
        return 'paused';
    }
  }

  private adjustSyncBehavior(): void {
    this.clearSyncTimer();

    switch (this.currentFrequency) {
      case 'realtime':
        // For realtime, trigger immediate sync and let PowerSync stream
        console.log('[AdaptiveSync] Realtime mode - triggering sync');
        this.onSync().catch(console.error);
        break;

      case 'frequent':
        console.log(`[AdaptiveSync] Frequent mode - ${this.config.frequentInterval}ms intervals`);
        this.startPolling(this.config.frequentInterval);
        break;

      case 'conservative':
        console.log(`[AdaptiveSync] Conservative mode - ${this.config.conservativeInterval}ms intervals`);
        this.startPolling(this.config.conservativeInterval);
        break;

      case 'paused':
        console.log('[AdaptiveSync] Paused - waiting for connection');
        // Don't sync, just wait for reconnection
        break;
    }
  }

  private startPolling(interval: number): void {
    // Trigger immediate sync
    this.onSync().catch(console.error);

    // Then start interval
    this.syncTimer = setInterval(() => {
      this.onSync().catch(console.error);
    }, interval);
  }

  private clearSyncTimer(): void {
    if (this.syncTimer) {
      clearInterval(this.syncTimer);
      this.syncTimer = null;
    }
  }
}
```

**index.ts** - Barrel export:
```typescript
export {
  NetworkMonitor,
  getNetworkMonitor,
  useNetworkState,
  type NetworkState,
  type NetworkQuality,
} from './network-monitor';

export {
  AdaptiveSyncController,
  type SyncFrequency,
  type AdaptiveSyncConfig,
} from './adaptive-controller';
```
  </action>
  <verify>Run `cd apps/omnii-mobile && npx tsc --noEmit` - no TypeScript errors</verify>
  <done>Adaptive sync controller and network monitor created</done>
</task>

<task type="auto">
  <name>Task 3: Integrate adaptive sync into SyncProvider</name>
  <files>apps/omnii-mobile/src/context/SyncProvider.tsx</files>
  <action>
Update SyncProvider to use AdaptiveSyncController instead of manual sync calls.

1. Import the adaptive sync controller:
```typescript
import { AdaptiveSyncController, useNetworkState } from '~/services/sync';
```

2. Add controller ref inside SyncProvider:
```typescript
const adaptiveSyncRef = useRef<AdaptiveSyncController | null>(null);
```

3. Initialize controller when PowerSync is ready (in the existing initialization effect):
```typescript
// After PowerSync initialization succeeds
if (!adaptiveSyncRef.current) {
  adaptiveSyncRef.current = new AdaptiveSyncController(async () => {
    // Trigger PowerSync sync
    const db = getPowerSync();
    if (db) {
      await db.connect(connector);
    }
  });
  adaptiveSyncRef.current.start();
}
```

4. Clean up controller on logout/unmount:
```typescript
// In cleanup function
adaptiveSyncRef.current?.stop();
adaptiveSyncRef.current = null;
```

5. Expose network state in context value by adding useNetworkState hook:
```typescript
const networkState = useNetworkState();

// Add to context value
value={{
  // ... existing values
  networkState,
  syncFrequency: adaptiveSyncRef.current?.getFrequency() ?? 'paused',
}}
```

6. Update SyncState type to include:
```typescript
networkState: NetworkState | null;
syncFrequency: SyncFrequency;
```

Do NOT remove any existing functionality. Add adaptive sync on top of existing PowerSync integration.
  </action>
  <verify>Run `cd apps/omnii-mobile && npx tsc --noEmit` - no TypeScript errors</verify>
  <done>SyncProvider uses AdaptiveSyncController for network-aware sync frequency</done>
</task>

</tasks>

<verification>
Run these checks after completing all tasks:

1. TypeScript compiles: `cd apps/omnii-mobile && npx tsc --noEmit`
2. Dependencies installed: Check package.json has netinfo
3. Network monitor starts: Console logs show "[AdaptiveSync] Controller started"

Note: Full testing requires:
- Physical device or emulator with network simulation
- Toggle WiFi/cellular to verify frequency changes
- Check console logs for frequency change messages
</verification>

<success_criteria>
- NetInfo package installed
- NetworkMonitor detects WiFi vs cellular vs offline
- AdaptiveSyncController adjusts frequency based on network quality
- Sync pauses when app goes to background
- Sync resumes when app returns to foreground
- SyncProvider integrates AdaptiveSyncController
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/07-production-hardening/07-03-SUMMARY.md`
</output>
