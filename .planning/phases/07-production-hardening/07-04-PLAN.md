---
phase: 07-production-hardening
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/omnii_mcp/src/graph/versioning/temporal-schema.ts
  - apps/omnii_mcp/src/graph/versioning/version-operations.ts
  - apps/omnii_mcp/src/graph/versioning/index.ts
  - apps/omnii_mcp/src/routes/version-history.ts
  - apps/omnii_mcp/src/routes/index.ts
autonomous: true

must_haves:
  truths:
    - "Changes to graph nodes create version history"
    - "User can view version history for any entity"
    - "User can rollback to a previous version"
    - "Version history tracks who made changes (user vs AI)"
    - "Versions have timestamps and change descriptions"
  artifacts:
    - path: "apps/omnii_mcp/src/graph/versioning/temporal-schema.ts"
      provides: "State node schema for version history"
      exports: ["StateNode", "VersionedEntity"]
    - path: "apps/omnii_mcp/src/graph/versioning/version-operations.ts"
      provides: "CRUD for version history"
      exports: ["VersionedGraphOperations"]
    - path: "apps/omnii_mcp/src/routes/version-history.ts"
      provides: "REST endpoints for version management"
      exports: ["versionHistoryRoutes"]
  key_links:
    - from: "apps/omnii_mcp/src/routes/version-history.ts"
      to: "graph/versioning"
      via: "VersionedGraphOperations usage"
      pattern: "VersionedGraphOperations"
---

<objective>
Implement Neo4j temporal versioning using entity-state separation pattern to track changes and enable rollback for AI-generated changes.

Purpose: Success criteria 6 requires version history and rollback capability for AI-generated changes.
Output: Version history schema, operations, and REST endpoints for viewing history and rolling back changes.
</objective>

<execution_context>
@/Users/santino/.claude/get-shit-done/workflows/execute-plan.md
@/Users/santino/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-production-hardening/07-RESEARCH.md

Research provides:
- Entity-State separation pattern for Neo4j versioning
- [:HAS_STATE] and [:PREVIOUS] relationship chain
- State nodes store mutable data, Entity nodes store identity
- Version retention policy recommended (50-100 versions max)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create versioning schema types</name>
  <files>apps/omnii_mcp/src/graph/versioning/temporal-schema.ts</files>
  <action>
Create the version history schema directory and types:

```typescript
// apps/omnii_mcp/src/graph/versioning/temporal-schema.ts

export type ChangeAuthor = 'user' | 'ai_assistant' | 'system' | 'ingestion';

export interface StateNode {
  id: string;
  version: number;
  data: Record<string, unknown>;
  createdAt: string; // ISO timestamp
  createdBy: ChangeAuthor;
  changeDescription?: string;
}

export interface VersionedEntity {
  entityId: string;
  entityType: string; // 'Concept', 'Entity', 'Event', 'Contact'
  currentState: StateNode;
  versionCount: number;
}

export interface VersionHistoryEntry {
  version: number;
  createdAt: string;
  createdBy: ChangeAuthor;
  changeDescription?: string;
  isCurrent: boolean;
}

export interface VersionDiff {
  version: number;
  changes: {
    field: string;
    oldValue: unknown;
    newValue: unknown;
  }[];
}

// Schema constraints for Neo4j
export const VERSION_SCHEMA_CYPHER = `
// Create index on State.version for efficient history queries
CREATE INDEX state_version IF NOT EXISTS FOR (s:State) ON (s.version);

// Create index on State.createdAt for temporal queries
CREATE INDEX state_created_at IF NOT EXISTS FOR (s:State) ON (s.createdAt);

// Create constraint for State.id uniqueness
CREATE CONSTRAINT state_id IF NOT EXISTS FOR (s:State) REQUIRE s.id IS UNIQUE;
`;

// Maximum versions to keep per entity (retention policy)
export const MAX_VERSIONS_PER_ENTITY = 50;
```
  </action>
  <verify>TypeScript compiles without errors</verify>
  <done>Version history schema types created</done>
</task>

<task type="auto">
  <name>Task 2: Create versioned graph operations</name>
  <files>apps/omnii_mcp/src/graph/versioning/version-operations.ts</files>
  <action>
Create the versioned graph operations service:

```typescript
// apps/omnii_mcp/src/graph/versioning/version-operations.ts

import { createHttpNeo4jClient, type Neo4jHttpClient } from '../../services/neo4j/http-client';
import {
  StateNode,
  VersionedEntity,
  VersionHistoryEntry,
  ChangeAuthor,
  MAX_VERSIONS_PER_ENTITY,
} from './temporal-schema';

export class VersionedGraphOperations {
  private client: Neo4jHttpClient;

  constructor(client: Neo4jHttpClient) {
    this.client = client;
  }

  /**
   * Create a new version of an entity.
   * If entity has no State nodes yet, creates first version.
   * Maintains [:HAS_STATE] with current=true for latest, [:PREVIOUS] chain for history.
   */
  async createVersion(
    entityId: string,
    entityType: string,
    data: Record<string, unknown>,
    createdBy: ChangeAuthor,
    changeDescription?: string
  ): Promise<StateNode> {
    const stateId = crypto.randomUUID();
    const now = new Date().toISOString();

    // Get current version number
    const currentVersion = await this.getCurrentVersionNumber(entityId);
    const newVersion = currentVersion + 1;

    // Create new State node and link to entity
    const query = `
      MATCH (e:${entityType} {id: $entityId})

      // Find current state if exists
      OPTIONAL MATCH (e)-[r:HAS_STATE {current: true}]->(currentState:State)

      // Create new state node
      CREATE (newState:State {
        id: $stateId,
        version: $newVersion,
        data: $dataJson,
        createdAt: $now,
        createdBy: $createdBy,
        changeDescription: $changeDescription
      })

      // Link new state to entity as current
      CREATE (e)-[:HAS_STATE {current: true}]->(newState)

      // If there was a current state, mark it as not current and link as previous
      FOREACH (_ IN CASE WHEN currentState IS NOT NULL THEN [1] ELSE [] END |
        SET r.current = false
        CREATE (newState)-[:PREVIOUS]->(currentState)
      )

      RETURN newState
    `;

    const result = await this.client.query(query, {
      entityId,
      stateId,
      newVersion,
      dataJson: JSON.stringify(data),
      now,
      createdBy,
      changeDescription: changeDescription || null,
    });

    // Cleanup old versions if exceeding limit
    await this.pruneOldVersions(entityId, entityType);

    return {
      id: stateId,
      version: newVersion,
      data,
      createdAt: now,
      createdBy,
      changeDescription,
    };
  }

  /**
   * Get current version number for an entity.
   */
  async getCurrentVersionNumber(entityId: string): Promise<number> {
    const query = `
      MATCH (e {id: $entityId})-[:HAS_STATE {current: true}]->(s:State)
      RETURN s.version as version
    `;

    const result = await this.client.query(query, { entityId });

    if (result.length === 0) {
      return 0;
    }

    return result[0].version as number;
  }

  /**
   * Get version history for an entity.
   */
  async getVersionHistory(
    entityId: string,
    limit: number = 20
  ): Promise<VersionHistoryEntry[]> {
    const query = `
      MATCH (e {id: $entityId})-[r:HAS_STATE]->(s:State)
      RETURN s.version as version,
             s.createdAt as createdAt,
             s.createdBy as createdBy,
             s.changeDescription as changeDescription,
             r.current as isCurrent
      ORDER BY s.version DESC
      LIMIT $limit
    `;

    const result = await this.client.query(query, { entityId, limit });

    return result.map((row) => ({
      version: row.version as number,
      createdAt: row.createdAt as string,
      createdBy: row.createdBy as ChangeAuthor,
      changeDescription: row.changeDescription as string | undefined,
      isCurrent: row.isCurrent as boolean,
    }));
  }

  /**
   * Get a specific version's data.
   */
  async getVersion(
    entityId: string,
    version: number
  ): Promise<StateNode | null> {
    const query = `
      MATCH (e {id: $entityId})-[:HAS_STATE]->(s:State {version: $version})
      RETURN s.id as id,
             s.version as version,
             s.data as data,
             s.createdAt as createdAt,
             s.createdBy as createdBy,
             s.changeDescription as changeDescription
    `;

    const result = await this.client.query(query, { entityId, version });

    if (result.length === 0) {
      return null;
    }

    const row = result[0];
    return {
      id: row.id as string,
      version: row.version as number,
      data: typeof row.data === 'string' ? JSON.parse(row.data) : row.data,
      createdAt: row.createdAt as string,
      createdBy: row.createdBy as ChangeAuthor,
      changeDescription: row.changeDescription as string | undefined,
    };
  }

  /**
   * Rollback to a specific version.
   * Creates a NEW version with the old data (preserves history).
   */
  async rollbackToVersion(
    entityId: string,
    entityType: string,
    targetVersion: number
  ): Promise<StateNode> {
    const targetState = await this.getVersion(entityId, targetVersion);

    if (!targetState) {
      throw new Error(`Version ${targetVersion} not found for entity ${entityId}`);
    }

    // Create new version with old data
    return this.createVersion(
      entityId,
      entityType,
      targetState.data,
      'user',
      `Rollback to version ${targetVersion}`
    );
  }

  /**
   * Get current state data for an entity.
   */
  async getCurrentState(entityId: string): Promise<StateNode | null> {
    const query = `
      MATCH (e {id: $entityId})-[:HAS_STATE {current: true}]->(s:State)
      RETURN s.id as id,
             s.version as version,
             s.data as data,
             s.createdAt as createdAt,
             s.createdBy as createdBy,
             s.changeDescription as changeDescription
    `;

    const result = await this.client.query(query, { entityId });

    if (result.length === 0) {
      return null;
    }

    const row = result[0];
    return {
      id: row.id as string,
      version: row.version as number,
      data: typeof row.data === 'string' ? JSON.parse(row.data) : row.data,
      createdAt: row.createdAt as string,
      createdBy: row.createdBy as ChangeAuthor,
      changeDescription: row.changeDescription as string | undefined,
    };
  }

  /**
   * Prune old versions to enforce retention policy.
   */
  private async pruneOldVersions(
    entityId: string,
    entityType: string
  ): Promise<number> {
    const query = `
      MATCH (e:${entityType} {id: $entityId})-[:HAS_STATE]->(s:State)
      WITH s ORDER BY s.version DESC
      SKIP $keepCount
      DETACH DELETE s
      RETURN count(*) as deleted
    `;

    const result = await this.client.query(query, {
      entityId,
      keepCount: MAX_VERSIONS_PER_ENTITY,
    });

    const deleted = result[0]?.deleted as number || 0;
    if (deleted > 0) {
      console.log(`[Versioning] Pruned ${deleted} old versions for ${entityId}`);
    }

    return deleted;
  }
}

// Factory function for creating operations with a client
export function createVersionedOperations(client: Neo4jHttpClient): VersionedGraphOperations {
  return new VersionedGraphOperations(client);
}
```
  </action>
  <verify>TypeScript compiles without errors</verify>
  <done>Versioned graph operations created with create, history, rollback functions</done>
</task>

<task type="auto">
  <name>Task 3: Create version history REST endpoints</name>
  <files>
    apps/omnii_mcp/src/graph/versioning/index.ts
    apps/omnii_mcp/src/routes/version-history.ts
    apps/omnii_mcp/src/routes/index.ts
  </files>
  <action>
Create barrel export and REST routes:

**index.ts** - Barrel export:
```typescript
export {
  StateNode,
  VersionedEntity,
  VersionHistoryEntry,
  VersionDiff,
  ChangeAuthor,
  VERSION_SCHEMA_CYPHER,
  MAX_VERSIONS_PER_ENTITY,
} from './temporal-schema';

export {
  VersionedGraphOperations,
  createVersionedOperations,
} from './version-operations';
```

**version-history.ts** - REST routes:
```typescript
import { Elysia, t } from 'elysia';
import { createVersionedOperations, type ChangeAuthor } from '../graph/versioning';
import { createHttpNeo4jClient } from '../services/neo4j/http-client';

export const versionHistoryRoutes = new Elysia({ prefix: '/api/versions' })
  // Get version history for an entity
  .get(
    '/:entityId',
    async ({ params, query }) => {
      const client = createHttpNeo4jClient();
      const ops = createVersionedOperations(client);

      const history = await ops.getVersionHistory(
        params.entityId,
        query.limit || 20
      );

      return {
        entityId: params.entityId,
        versions: history,
        count: history.length,
      };
    },
    {
      params: t.Object({
        entityId: t.String(),
      }),
      query: t.Object({
        limit: t.Optional(t.Number({ minimum: 1, maximum: 100 })),
      }),
    }
  )

  // Get specific version
  .get(
    '/:entityId/:version',
    async ({ params }) => {
      const client = createHttpNeo4jClient();
      const ops = createVersionedOperations(client);

      const version = await ops.getVersion(params.entityId, params.version);

      if (!version) {
        return {
          error: 'Version not found',
          entityId: params.entityId,
          version: params.version,
        };
      }

      return version;
    },
    {
      params: t.Object({
        entityId: t.String(),
        version: t.Number(),
      }),
    }
  )

  // Create new version
  .post(
    '/:entityId',
    async ({ params, body }) => {
      const client = createHttpNeo4jClient();
      const ops = createVersionedOperations(client);

      const newVersion = await ops.createVersion(
        params.entityId,
        body.entityType,
        body.data,
        body.createdBy as ChangeAuthor,
        body.changeDescription
      );

      return {
        success: true,
        version: newVersion,
      };
    },
    {
      params: t.Object({
        entityId: t.String(),
      }),
      body: t.Object({
        entityType: t.String(),
        data: t.Record(t.String(), t.Unknown()),
        createdBy: t.Union([
          t.Literal('user'),
          t.Literal('ai_assistant'),
          t.Literal('system'),
          t.Literal('ingestion'),
        ]),
        changeDescription: t.Optional(t.String()),
      }),
    }
  )

  // Rollback to specific version
  .post(
    '/:entityId/rollback/:version',
    async ({ params, body }) => {
      const client = createHttpNeo4jClient();
      const ops = createVersionedOperations(client);

      try {
        const newVersion = await ops.rollbackToVersion(
          params.entityId,
          body.entityType,
          params.version
        );

        return {
          success: true,
          message: `Rolled back to version ${params.version}`,
          newVersion,
        };
      } catch (error) {
        return {
          success: false,
          error: error instanceof Error ? error.message : 'Rollback failed',
        };
      }
    },
    {
      params: t.Object({
        entityId: t.String(),
        version: t.Number(),
      }),
      body: t.Object({
        entityType: t.String(),
      }),
    }
  );
```

Update routes/index.ts to include version history routes:
```typescript
import { versionHistoryRoutes } from './version-history';

// Add to the routes export
.use(versionHistoryRoutes)
```
  </action>
  <verify>Run `bun run check` from apps/omnii_mcp - no TypeScript errors</verify>
  <done>Version history REST endpoints created and registered</done>
</task>

</tasks>

<verification>
Run these checks after completing all tasks:

1. TypeScript compiles: `cd apps/omnii_mcp && bun run check`
2. App starts: `cd apps/omnii_mcp && bun run dev` - no startup errors
3. Routes registered: Check Swagger at /swagger shows version endpoints

Test sequence (requires running Neo4j):
```bash
# Create version
curl -X POST http://localhost:3000/api/versions/test-entity-123 \
  -H "Content-Type: application/json" \
  -d '{"entityType": "Entity", "data": {"name": "Test"}, "createdBy": "user"}'

# Get history
curl http://localhost:3000/api/versions/test-entity-123

# Rollback
curl -X POST http://localhost:3000/api/versions/test-entity-123/rollback/1 \
  -H "Content-Type: application/json" \
  -d '{"entityType": "Entity"}'
```
</verification>

<success_criteria>
- State node schema types defined
- VersionedGraphOperations class handles create/read/rollback
- Version retention policy enforced (max 50 versions)
- REST endpoints for version CRUD operations
- Routes registered in main app
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/07-production-hardening/07-04-SUMMARY.md`
</output>
