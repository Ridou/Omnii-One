---
phase: 06-orchestration-automation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/omnii_mcp/src/services/workflows/execution-tracker.ts
  - apps/omnii_mcp/src/services/workflows/index.ts
autonomous: true

must_haves:
  truths:
    - "Workflow executions are tracked with unique idempotency keys"
    - "Duplicate execution requests return cached results instead of re-executing"
    - "Failed executions are tracked for debugging and retry decisions"
  artifacts:
    - path: "apps/omnii_mcp/src/services/workflows/execution-tracker.ts"
      provides: "Idempotent workflow execution tracking with Supabase"
      exports: ["ExecutionTracker", "WorkflowExecution", "ExecutionStatus"]
  key_links:
    - from: "apps/omnii_mcp/src/services/workflows/execution-tracker.ts"
      to: "@supabase/supabase-js"
      via: "database operations"
      pattern: "supabase\\.from\\('workflow_executions'\\)"
---

<objective>
Create workflow execution tracking service for idempotent workflow execution (ORCH-06).

Purpose: Prevent duplicate workflow executions on retry, track execution status for MCP tool responses, and provide debugging visibility for failed workflows.

Output: ExecutionTracker service with Supabase persistence and exactly-once semantics.
</objective>

<execution_context>
@/Users/santino/.claude/get-shit-done/workflows/execute-plan.md
@/Users/santino/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-orchestration-automation/06-RESEARCH.md

# Existing Supabase patterns
@apps/omnii_mcp/src/services/sync-state.service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create workflow_executions Supabase migration</name>
  <files>
    apps/omnii_mcp/supabase/migrations/20260125_workflow_executions.sql
  </files>
  <action>
Create SQL migration file `apps/omnii_mcp/supabase/migrations/20260125_workflow_executions.sql`:

```sql
-- Workflow Execution Tracking Table
-- Provides idempotent execution and status tracking for n8n workflows

CREATE TABLE IF NOT EXISTS workflow_executions (
  -- Primary key is the idempotency key (user-provided or generated)
  id TEXT PRIMARY KEY,

  -- Workflow identification
  workflow_id TEXT NOT NULL,
  workflow_name TEXT,

  -- User who triggered the execution
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,

  -- Execution status
  status TEXT NOT NULL CHECK (status IN ('pending', 'running', 'completed', 'failed')),

  -- Result data (JSON for flexibility)
  result JSONB,
  error_message TEXT,

  -- Execution context
  parameters JSONB,
  actor TEXT CHECK (actor IN ('user', 'ai_assistant', 'system', 'webhook')),

  -- Timing
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  started_at TIMESTAMPTZ,
  completed_at TIMESTAMPTZ
);

-- Index for user queries
CREATE INDEX idx_workflow_executions_user_id ON workflow_executions(user_id);

-- Index for status queries (find running/failed workflows)
CREATE INDEX idx_workflow_executions_status ON workflow_executions(status);

-- Index for workflow queries
CREATE INDEX idx_workflow_executions_workflow_id ON workflow_executions(workflow_id);

-- Index for recent executions
CREATE INDEX idx_workflow_executions_created_at ON workflow_executions(created_at DESC);

-- RLS policies
ALTER TABLE workflow_executions ENABLE ROW LEVEL SECURITY;

-- Users can only see their own executions
CREATE POLICY "Users can view own executions"
  ON workflow_executions FOR SELECT
  USING (auth.uid() = user_id);

-- Service role can do everything (for backend operations)
CREATE POLICY "Service role full access"
  ON workflow_executions FOR ALL
  USING (auth.role() = 'service_role');

-- Trigger for updated_at
CREATE OR REPLACE FUNCTION update_workflow_execution_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER workflow_executions_updated_at
  BEFORE UPDATE ON workflow_executions
  FOR EACH ROW
  EXECUTE FUNCTION update_workflow_execution_updated_at();

COMMENT ON TABLE workflow_executions IS 'Tracks n8n workflow executions for idempotency and debugging';
COMMENT ON COLUMN workflow_executions.id IS 'Idempotency key - same key returns cached result';
COMMENT ON COLUMN workflow_executions.status IS 'pending=not started, running=in progress, completed=success, failed=error';
```

Note: This migration will be applied manually via Supabase dashboard or CLI since we don't have automated migration runner.
  </action>
  <verify>
The SQL file should be valid SQL. Run a basic syntax check:
```bash
cd apps/omnii_mcp && cat supabase/migrations/20260125_workflow_executions.sql | head -20
```
Migration file exists with correct structure. Note: SQL validity is fully verified at deploy time when applied to Supabase - file existence check is sufficient here since Supabase will reject invalid SQL during manual application.
  </verify>
  <done>
Migration file created. Ready to be applied to Supabase.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create ExecutionTracker service</name>
  <files>
    apps/omnii_mcp/src/services/workflows/execution-tracker.ts
    apps/omnii_mcp/src/services/workflows/index.ts
  </files>
  <action>
1. Create `apps/omnii_mcp/src/services/workflows/execution-tracker.ts`:

   a. Import Supabase client factory (use service role for backend ops)

   b. Define types:
      ```typescript
      export type ExecutionStatus = 'pending' | 'running' | 'completed' | 'failed';
      export type ExecutionActor = 'user' | 'ai_assistant' | 'system' | 'webhook';

      export interface WorkflowExecution {
        id: string; // Idempotency key
        workflow_id: string;
        workflow_name?: string;
        user_id: string;
        status: ExecutionStatus;
        result?: unknown;
        error_message?: string;
        parameters?: Record<string, unknown>;
        actor?: ExecutionActor;
        created_at: string;
        updated_at: string;
        started_at?: string;
        completed_at?: string;
      }

      export interface ExecuteOptions {
        idempotencyKey: string;
        workflowId: string;
        workflowName?: string;
        userId: string;
        actor?: ExecutionActor;
        parameters?: Record<string, unknown>;
      }
      ```

   c. Create ExecutionTracker class with methods:

      - `async getExecution(id: string): Promise<WorkflowExecution | null>`
        Query by idempotency key, return null if not found

      - `async createExecution(options: ExecuteOptions): Promise<WorkflowExecution>`
        Insert new execution with status='pending', return created record

      - `async markRunning(id: string): Promise<void>`
        Update status='running', set started_at=NOW()

      - `async markCompleted(id: string, result: unknown): Promise<void>`
        Update status='completed', set result, completed_at=NOW()

      - `async markFailed(id: string, errorMessage: string): Promise<void>`
        Update status='failed', set error_message, completed_at=NOW()

      - `async executeIdempotent<T>(options: ExecuteOptions, executor: () => Promise<T>): Promise<T>`
        Main method implementing exactly-once semantics:
        1. Check for existing execution by idempotencyKey
        2. If completed, return cached result
        3. If running, throw 'Execution already in progress'
        4. If failed, allow retry (create new or update existing)
        5. If not found, create new execution
        6. Mark running, execute, mark completed/failed
        7. Return result or throw error

      - `async getRecentExecutions(userId: string, limit?: number): Promise<WorkflowExecution[]>`
        Get recent executions for a user (for status queries)

      - `async getExecutionsByWorkflow(workflowId: string, userId: string): Promise<WorkflowExecution[]>`
        Get executions for a specific workflow

   d. Create singleton getter: `getExecutionTracker()`

2. Create `apps/omnii_mcp/src/services/workflows/index.ts`:
   - Re-export everything from execution-tracker.ts
  </action>
  <verify>
Run `bun run build` in apps/omnii_mcp - should compile without errors.
Check the service can be imported:
```bash
cd apps/omnii_mcp && bun -e "
const { ExecutionTracker } = require('./src/services/workflows');
console.log('ExecutionTracker exported:', typeof ExecutionTracker);
"
```
  </verify>
  <done>
ExecutionTracker service created with idempotent execution pattern. Supabase persistence configured. Types exported.
  </done>
</task>

</tasks>

<verification>
1. Migration SQL file exists and has valid syntax
2. `bun run build` compiles without errors
3. ExecutionTracker can be imported and instantiated
4. Types (WorkflowExecution, ExecutionStatus, ExecutionActor) are exported
5. executeIdempotent method implements exactly-once semantics
</verification>

<success_criteria>
- workflow_executions migration file ready for Supabase
- ExecutionTracker service with CRUD operations
- executeIdempotent method prevents duplicate executions
- Recent execution queries support MCP tool status checks
- Barrel export aggregates workflow module
</success_criteria>

<output>
After completion, create `.planning/phases/06-orchestration-automation/06-02-SUMMARY.md`
</output>
