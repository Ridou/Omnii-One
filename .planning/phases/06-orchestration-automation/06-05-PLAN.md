---
phase: 06-orchestration-automation
plan: 05
type: execute
wave: 3
depends_on: ["06-01", "06-02", "06-03", "06-04"]
files_modified:
  - apps/omnii_mcp/src/mcp/tools/list-workflows.ts
  - apps/omnii_mcp/src/mcp/tools/execute-workflow.ts
  - apps/omnii_mcp/src/mcp/tools/workflow-status.ts
  - apps/omnii_mcp/src/mcp/tools/index.ts
autonomous: true

must_haves:
  truths:
    - "AI assistants can list available n8n workflows via MCP tool"
    - "AI assistants can trigger workflow execution via MCP tool"
    - "AI assistants can check workflow execution status via MCP tool"
  artifacts:
    - path: "apps/omnii_mcp/src/mcp/tools/list-workflows.ts"
      provides: "MCP tool for listing n8n workflows"
      exports: ["listWorkflowsToolDefinition", "handleListWorkflows"]
    - path: "apps/omnii_mcp/src/mcp/tools/execute-workflow.ts"
      provides: "MCP tool for triggering n8n workflow execution"
      exports: ["executeWorkflowToolDefinition", "handleExecuteWorkflow"]
    - path: "apps/omnii_mcp/src/mcp/tools/workflow-status.ts"
      provides: "MCP tool for checking workflow execution status"
      exports: ["workflowStatusToolDefinition", "handleWorkflowStatus"]
  key_links:
    - from: "apps/omnii_mcp/src/mcp/tools/index.ts"
      to: "TOOL_DEFINITIONS"
      via: "array aggregation"
      pattern: "TOOL_DEFINITIONS.*listWorkflowsToolDefinition"
    - from: "apps/omnii_mcp/src/mcp/tools/execute-workflow.ts"
      to: "n8n-workflow-client"
      via: "workflow trigger"
      pattern: "n8nWorkflowClient\\.triggerWorkflow"
    - from: "apps/omnii_mcp/src/mcp/tools/execute-workflow.ts"
      to: "execution-tracker"
      via: "idempotent execution"
      pattern: "executeIdempotent"
---

<objective>
Create MCP tools for n8n workflow operations (ORCH-03, ORCH-05).

Purpose: Enable AI assistants to list available workflows, trigger workflow execution, and check execution status via standardized MCP tool interface. This fulfills the AI-triggered automation requirement.

Output: Three MCP tools (list_workflows, execute_workflow, workflow_status) registered with the MCP server.
</objective>

<execution_context>
@/Users/santino/.claude/get-shit-done/workflows/execute-plan.md
@/Users/santino/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-orchestration-automation/06-RESEARCH.md

# Existing MCP tools for pattern reference
@apps/omnii_mcp/src/mcp/tools/index.ts
@apps/omnii_mcp/src/mcp/tools/calendar-query.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create list_workflows MCP tool</name>
  <files>
    apps/omnii_mcp/src/mcp/tools/list-workflows.ts
  </files>
  <action>
1. Create `apps/omnii_mcp/src/mcp/tools/list-workflows.ts`:

   a. Import dependencies following existing tool patterns:
      ```typescript
      import { z } from 'zod';
      import { n8nWorkflowClient } from '../../services/integrations';
      import { logAuditEvent } from '../../services/audit';
      import type { Neo4jHTTPClient } from '../../services/neo4j/http-client';
      import type { MCPToolResponse } from './search-nodes';
      ```

   b. Define input schema:
      ```typescript
      export const ListWorkflowsInputSchema = z.object({
        active_only: z.boolean()
          .optional()
          .default(true)
          .describe('Filter to only show active workflows (default: true)')
      });

      export type ListWorkflowsInput = z.infer<typeof ListWorkflowsInputSchema>;
      ```

   c. Define tool definition (MCP format):
      ```typescript
      export const listWorkflowsToolDefinition = {
        name: 'omnii_list_workflows',
        title: 'List n8n Workflows',
        description: 'Get a list of available n8n automation workflows that can be triggered. Returns workflow ID, name, status, and description.',
        inputSchema: {
          type: 'object',
          properties: {
            active_only: {
              type: 'boolean',
              description: 'Filter to only show active workflows (default: true)'
            }
          },
          additionalProperties: false
        }
      };
      ```

   d. Implement handler:
      ```typescript
      export async function handleListWorkflows(
        client: Neo4jHTTPClient, // Required by ToolHandler signature, not used here
        input: unknown,
        userId?: string
      ): Promise<MCPToolResponse> {
        // Validate input
        const parsed = ListWorkflowsInputSchema.safeParse(input);
        if (!parsed.success) {
          return {
            content: [{ type: 'text', text: `Invalid input: ${parsed.error.message}` }],
            isError: true
          };
        }

        const { active_only } = parsed.data;

        // Log audit event
        await logAuditEvent({
          event: 'workflow_list_requested',
          userId: userId || 'unknown',
          actor: 'ai_assistant',
          action: 'list',
          resource: { type: 'workflow_list' }
        });

        try {
          const workflows = await n8nWorkflowClient.listWorkflows();

          // Filter by active status
          const filtered = active_only
            ? workflows.filter(w => w.active)
            : workflows;

          // Format for AI consumption
          const summary = filtered.map(w => ({
            id: w.id,
            name: w.name,
            active: w.active,
            description: w.settings?.description || 'No description'
          }));

          return {
            content: [{
              type: 'text',
              text: `Found ${filtered.length} workflow(s):\n\n${JSON.stringify(summary, null, 2)}`
            }]
          };

        } catch (error) {
          await logAuditEvent({
            event: 'workflow_list_requested',
            userId: userId || 'unknown',
            actor: 'ai_assistant',
            severity: 'error',
            metadata: { error: (error as Error).message }
          });

          return {
            content: [{ type: 'text', text: `Failed to list workflows: ${(error as Error).message}` }],
            isError: true
          };
        }
      }
      ```
  </action>
  <verify>
Run `bun run build` - should compile without errors.
  </verify>
  <done>
list_workflows MCP tool created with active filter and audit logging.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create execute_workflow MCP tool</name>
  <files>
    apps/omnii_mcp/src/mcp/tools/execute-workflow.ts
  </files>
  <action>
1. Create `apps/omnii_mcp/src/mcp/tools/execute-workflow.ts`:

   a. Import dependencies:
      ```typescript
      import { z } from 'zod';
      import { v4 as uuidv4 } from 'uuid';
      import { n8nWorkflowClient } from '../../services/integrations';
      import { getExecutionTracker } from '../../services/workflows';
      import { logAuditEvent } from '../../services/audit';
      import type { Neo4jHTTPClient } from '../../services/neo4j/http-client';
      import type { MCPToolResponse } from './search-nodes';
      ```

   b. Define input schema:
      ```typescript
      export const ExecuteWorkflowInputSchema = z.object({
        workflow_id: z.string()
          .describe('The n8n workflow ID to execute'),
        workflow_name: z.string()
          .optional()
          .describe('Human-readable workflow name for tracking'),
        parameters: z.record(z.unknown())
          .optional()
          .default({})
          .describe('Input parameters to pass to the workflow'),
        idempotency_key: z.string()
          .optional()
          .describe('Unique key to prevent duplicate executions. If not provided, one will be generated.')
      });

      export type ExecuteWorkflowInput = z.infer<typeof ExecuteWorkflowInputSchema>;
      ```

   c. Define tool definition:
      ```typescript
      export const executeWorkflowToolDefinition = {
        name: 'omnii_execute_workflow',
        title: 'Execute n8n Workflow',
        description: 'Trigger an n8n workflow with optional parameters. Returns execution ID for status tracking. Use workflow_status tool to check progress.',
        inputSchema: {
          type: 'object',
          properties: {
            workflow_id: {
              type: 'string',
              description: 'The n8n workflow ID to execute'
            },
            workflow_name: {
              type: 'string',
              description: 'Human-readable workflow name for tracking'
            },
            parameters: {
              type: 'object',
              description: 'Input parameters to pass to the workflow'
            },
            idempotency_key: {
              type: 'string',
              description: 'Unique key to prevent duplicate executions'
            }
          },
          required: ['workflow_id'],
          additionalProperties: false
        }
      };
      ```

   d. Implement handler with idempotent execution:
      ```typescript
      export async function handleExecuteWorkflow(
        client: Neo4jHTTPClient,
        input: unknown,
        userId?: string
      ): Promise<MCPToolResponse> {
        // Validate input
        const parsed = ExecuteWorkflowInputSchema.safeParse(input);
        if (!parsed.success) {
          return {
            content: [{ type: 'text', text: `Invalid input: ${parsed.error.message}` }],
            isError: true
          };
        }

        const { workflow_id, workflow_name, parameters, idempotency_key } = parsed.data;
        const executionId = idempotency_key || `exec-${uuidv4()}`;
        const userIdSafe = userId || 'unknown';

        // Log audit event for AI-triggered execution
        await logAuditEvent({
          event: 'workflow_execution_triggered',
          userId: userIdSafe,
          actor: 'ai_assistant',
          resource: { type: 'workflow', id: workflow_id, name: workflow_name },
          action: 'execute',
          metadata: { parameters, idempotency_key: executionId }
        });

        try {
          const tracker = getExecutionTracker();

          // Use idempotent execution
          const result = await tracker.executeIdempotent(
            {
              idempotencyKey: executionId,
              workflowId: workflow_id,
              workflowName: workflow_name,
              userId: userIdSafe,
              actor: 'ai_assistant',
              parameters
            },
            async () => {
              // Actual workflow trigger
              return n8nWorkflowClient.triggerWorkflow(workflow_id, {
                ...parameters,
                _omnii: {
                  userId: userIdSafe,
                  executionId,
                  triggeredBy: 'mcp_tool'
                }
              });
            }
          );

          // Log successful completion
          await logAuditEvent({
            event: 'workflow_execution_completed',
            userId: userIdSafe,
            actor: 'ai_assistant',
            resource: { type: 'workflow', id: workflow_id },
            metadata: { executionId, success: result.success }
          });

          return {
            content: [{
              type: 'text',
              text: `Workflow triggered successfully.\n\nExecution ID: ${executionId}\nWorkflow: ${workflow_name || workflow_id}\nStatus: ${result.success ? 'Started' : 'Failed'}\n\nUse omnii_workflow_status tool to check progress.`
            }]
          };

        } catch (error) {
          const errorMsg = (error as Error).message;

          await logAuditEvent({
            event: 'workflow_execution_failed',
            userId: userIdSafe,
            actor: 'ai_assistant',
            severity: 'error',
            resource: { type: 'workflow', id: workflow_id },
            metadata: { executionId, error: errorMsg }
          });

          // Special handling for already-running executions
          if (errorMsg.includes('already in progress')) {
            return {
              content: [{
                type: 'text',
                text: `Workflow is already running with this idempotency key.\n\nExecution ID: ${executionId}\nUse omnii_workflow_status to check progress.`
              }]
            };
          }

          return {
            content: [{ type: 'text', text: `Failed to execute workflow: ${errorMsg}` }],
            isError: true
          };
        }
      }
      ```
  </action>
  <verify>
Run `bun run build` - should compile without errors.
  </verify>
  <done>
execute_workflow MCP tool created with idempotent execution and audit logging.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create workflow_status MCP tool and update index</name>
  <files>
    apps/omnii_mcp/src/mcp/tools/workflow-status.ts
    apps/omnii_mcp/src/mcp/tools/index.ts
  </files>
  <action>
1. Create `apps/omnii_mcp/src/mcp/tools/workflow-status.ts`:

   a. Import dependencies:
      ```typescript
      import { z } from 'zod';
      import { getExecutionTracker } from '../../services/workflows';
      import { logAuditEvent } from '../../services/audit';
      import type { Neo4jHTTPClient } from '../../services/neo4j/http-client';
      import type { MCPToolResponse } from './search-nodes';
      ```

   b. Define input schema:
      ```typescript
      export const WorkflowStatusInputSchema = z.object({
        execution_id: z.string()
          .optional()
          .describe('Specific execution ID to check status'),
        workflow_id: z.string()
          .optional()
          .describe('Get recent executions for a specific workflow'),
        limit: z.number()
          .optional()
          .default(10)
          .describe('Maximum number of recent executions to return')
      }).refine(
        data => data.execution_id || data.workflow_id,
        { message: 'Either execution_id or workflow_id must be provided' }
      );

      export type WorkflowStatusInput = z.infer<typeof WorkflowStatusInputSchema>;
      ```

   c. Define tool definition:
      ```typescript
      export const workflowStatusToolDefinition = {
        name: 'omnii_workflow_status',
        title: 'Check Workflow Status',
        description: 'Check the status of a workflow execution or get recent executions. Provide either execution_id for a specific execution or workflow_id for recent history.',
        inputSchema: {
          type: 'object',
          properties: {
            execution_id: {
              type: 'string',
              description: 'Specific execution ID to check status'
            },
            workflow_id: {
              type: 'string',
              description: 'Get recent executions for a specific workflow'
            },
            limit: {
              type: 'number',
              description: 'Maximum number of recent executions to return (default: 10)'
            }
          },
          additionalProperties: false
        }
      };
      ```

   d. Implement handler:
      ```typescript
      export async function handleWorkflowStatus(
        client: Neo4jHTTPClient,
        input: unknown,
        userId?: string
      ): Promise<MCPToolResponse> {
        const parsed = WorkflowStatusInputSchema.safeParse(input);
        if (!parsed.success) {
          return {
            content: [{ type: 'text', text: `Invalid input: ${parsed.error.message}` }],
            isError: true
          };
        }

        const { execution_id, workflow_id, limit } = parsed.data;
        const userIdSafe = userId || 'unknown';

        // Log audit event
        await logAuditEvent({
          event: 'workflow_status_requested',
          userId: userIdSafe,
          actor: 'ai_assistant',
          action: 'read',
          resource: {
            type: execution_id ? 'execution' : 'workflow',
            id: execution_id || workflow_id
          }
        });

        try {
          const tracker = getExecutionTracker();

          if (execution_id) {
            // Get specific execution
            const execution = await tracker.getExecution(execution_id);

            if (!execution) {
              return {
                content: [{ type: 'text', text: `No execution found with ID: ${execution_id}` }]
              };
            }

            // Format duration if completed
            let duration = 'N/A';
            if (execution.started_at && execution.completed_at) {
              const ms = new Date(execution.completed_at).getTime() - new Date(execution.started_at).getTime();
              duration = `${(ms / 1000).toFixed(1)}s`;
            }

            return {
              content: [{
                type: 'text',
                text: `Execution Status: ${execution.status.toUpperCase()}\n\n` +
                  `ID: ${execution.id}\n` +
                  `Workflow: ${execution.workflow_name || execution.workflow_id}\n` +
                  `Status: ${execution.status}\n` +
                  `Started: ${execution.started_at || 'Not started'}\n` +
                  `Completed: ${execution.completed_at || 'In progress'}\n` +
                  `Duration: ${duration}\n` +
                  (execution.error_message ? `Error: ${execution.error_message}\n` : '') +
                  (execution.result ? `Result: ${JSON.stringify(execution.result, null, 2)}` : '')
              }]
            };

          } else if (workflow_id) {
            // Get recent executions for workflow
            const executions = await tracker.getExecutionsByWorkflow(workflow_id, userIdSafe);
            const limited = executions.slice(0, limit);

            if (limited.length === 0) {
              return {
                content: [{ type: 'text', text: `No executions found for workflow: ${workflow_id}` }]
              };
            }

            const summary = limited.map(e => ({
              id: e.id,
              status: e.status,
              started: e.started_at,
              completed: e.completed_at,
              error: e.error_message
            }));

            return {
              content: [{
                type: 'text',
                text: `Recent executions for workflow ${workflow_id}:\n\n${JSON.stringify(summary, null, 2)}`
              }]
            };
          }

          return {
            content: [{ type: 'text', text: 'Please provide either execution_id or workflow_id' }],
            isError: true
          };

        } catch (error) {
          return {
            content: [{ type: 'text', text: `Failed to get status: ${(error as Error).message}` }],
            isError: true
          };
        }
      }
      ```

2. Update `apps/omnii_mcp/src/mcp/tools/index.ts`:

   a. Add imports for new tools:
      ```typescript
      import {
        listWorkflowsToolDefinition,
        handleListWorkflows,
        ListWorkflowsInputSchema,
      } from './list-workflows';
      import {
        executeWorkflowToolDefinition,
        handleExecuteWorkflow,
        ExecuteWorkflowInputSchema,
      } from './execute-workflow';
      import {
        workflowStatusToolDefinition,
        handleWorkflowStatus,
        WorkflowStatusInputSchema,
      } from './workflow-status';
      ```

   b. Add new tools to TOOL_DEFINITIONS array:
      ```typescript
      export const TOOL_DEFINITIONS = [
        // ... existing tools ...
        listWorkflowsToolDefinition,
        executeWorkflowToolDefinition,
        workflowStatusToolDefinition,
      ] as const;
      ```

   c. Add handlers to TOOL_HANDLERS map:
      ```typescript
      export const TOOL_HANDLERS: Record<string, ToolHandler> = {
        // ... existing handlers ...
        [listWorkflowsToolDefinition.name]: handleListWorkflows,
        [executeWorkflowToolDefinition.name]: handleExecuteWorkflow,
        [workflowStatusToolDefinition.name]: handleWorkflowStatus,
      };
      ```

   d. Add re-exports:
      ```typescript
      export {
        listWorkflowsToolDefinition,
        handleListWorkflows,
        ListWorkflowsInputSchema,
        executeWorkflowToolDefinition,
        handleExecuteWorkflow,
        ExecuteWorkflowInputSchema,
        workflowStatusToolDefinition,
        handleWorkflowStatus,
        WorkflowStatusInputSchema,
      };
      ```
  </action>
  <verify>
Run `bun run build` - should compile without errors.

Check tools are registered:
```bash
cd apps/omnii_mcp && bun -e "
const { TOOL_DEFINITIONS, getToolNames } = require('./src/mcp/tools');
const names = getToolNames();
console.log('Total tools:', names.length);
console.log('Workflow tools:', names.filter(n => n.includes('workflow')));
"
```
Should show 10 total tools including 3 workflow tools.
  </verify>
  <done>
All 3 MCP workflow tools created and registered. Tool definitions, handlers, and input schemas exported.
  </done>
</task>

</tasks>

<verification>
1. `bun run build` compiles without errors
2. TOOL_DEFINITIONS includes 3 new workflow tools
3. TOOL_HANDLERS has entries for all 3 tools
4. Each tool has proper input validation via Zod
5. Audit events logged for all tool invocations
6. execute_workflow uses idempotent execution tracking
</verification>

<success_criteria>
- omnii_list_workflows tool lists available n8n workflows
- omnii_execute_workflow triggers workflows with parameters
- omnii_workflow_status checks execution status
- All tools follow existing MCP tool patterns
- Audit logging for AI assistant actions
- Idempotent execution prevents duplicates
</success_criteria>

<output>
After completion, create `.planning/phases/06-orchestration-automation/06-05-SUMMARY.md`
</output>
