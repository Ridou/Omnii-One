---
phase: 01-foundation-infrastructure
plan: 05
type: execute
wave: 4
depends_on: ["01-03", "01-04"]
files_modified:
  - apps/omnii_mcp/src/routes/index.ts
  - apps/omnii_mcp/src/routes/graph.ts
  - apps/omnii_mcp/src/app.ts
autonomous: false

must_haves:
  truths:
    - "Protected routes require valid JWT"
    - "User's Neo4j queries hit their own database"
    - "Unauthenticated requests return 401"
    - "End-to-end auth flow works (login -> JWT -> query)"
  artifacts:
    - path: "apps/omnii_mcp/src/routes/graph.ts"
      provides: "Protected graph query routes"
      exports: ["graphRoutes"]
  key_links:
    - from: "apps/omnii_mcp/src/routes/graph.ts"
      to: "packages/auth/src/middleware.ts"
      via: "use(authMiddleware)"
      pattern: "use\\(authMiddleware\\)"
    - from: "apps/omnii_mcp/src/routes/graph.ts"
      to: "apps/omnii_mcp/src/services/neo4j/http-client.ts"
      via: "createClientForUser(tenantId)"
      pattern: "createClientForUser"
---

<objective>
Wire authentication middleware to protected routes and verify the complete auth flow works end-to-end.

Purpose: All prior plans created components in isolation. This plan integrates them: auth middleware protects routes, tenantId flows to Neo4j client factory, and queries execute against user's database.

Output: Working protected routes that demonstrate the full auth -> isolation flow.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-infrastructure/01-RESEARCH.md

# All prior plans should be complete
@.planning/phases/01-foundation-infrastructure/01-01-SUMMARY.md
@.planning/phases/01-foundation-infrastructure/01-02-SUMMARY.md
@.planning/phases/01-foundation-infrastructure/01-03-SUMMARY.md
@.planning/phases/01-foundation-infrastructure/01-04-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create protected graph routes with tenant isolation</name>
  <files>
    apps/omnii_mcp/src/routes/graph.ts
    apps/omnii_mcp/src/routes/index.ts
  </files>
  <action>
1. **Create apps/omnii_mcp/src/routes/graph.ts:**
```typescript
import { Elysia, t } from 'elysia';
import { authMiddleware } from '@omnii/auth';
import { createClientForUser } from '../services/neo4j/http-client';
import { getProvisioningStatus } from '../services/neo4j/provisioning';

export const graphRoutes = new Elysia({ prefix: '/graph' })
  // All routes require authentication
  .use(authMiddleware)

  // Check database status for current user
  .get('/status', async ({ tenantId }) => {
    const status = await getProvisioningStatus(tenantId);
    return {
      tenantId,
      database: status,
    };
  })

  // List nodes of a specific type
  .get('/nodes/:type', async ({ params, tenantId, set }) => {
    try {
      const client = await createClientForUser(tenantId);
      const result = await client.query(
        `MATCH (n:${params.type}) RETURN n LIMIT 50`
      );

      return {
        tenantId,
        nodeType: params.type,
        count: result.data.values.length,
        nodes: result.data.values.map(row => row[0]),
      };

    } catch (error) {
      if (error instanceof Error && error.message.includes('not ready')) {
        set.status = 503;
        return {
          error: 'Database still provisioning',
          message: 'Your personal database is being set up. Please try again in a few minutes.',
        };
      }
      throw error;
    }
  }, {
    params: t.Object({
      type: t.String(),
    }),
  })

  // Search concepts
  .get('/search', async ({ query, tenantId, set }) => {
    try {
      const client = await createClientForUser(tenantId);
      const result = await client.query(
        `MATCH (c:Concept)
         WHERE c.name CONTAINS $text OR c.content CONTAINS $text
         RETURN c LIMIT 10`,
        { text: query.q || '' }
      );

      return {
        tenantId,
        query: query.q,
        results: result.data.values.map(row => row[0]),
      };

    } catch (error) {
      if (error instanceof Error && error.message.includes('not ready')) {
        set.status = 503;
        return {
          error: 'Database still provisioning',
          message: 'Your personal database is being set up. Please try again in a few minutes.',
        };
      }
      throw error;
    }
  }, {
    query: t.Object({
      q: t.Optional(t.String()),
    }),
  })

  // Execute arbitrary Cypher (for debugging/testing)
  .post('/query', async ({ body, tenantId, set }) => {
    try {
      const client = await createClientForUser(tenantId);
      const result = await client.query(body.cypher, body.params || {});

      return {
        tenantId,
        result: result.data,
        counters: result.counters,
      };

    } catch (error) {
      if (error instanceof Error && error.message.includes('not ready')) {
        set.status = 503;
        return {
          error: 'Database still provisioning',
          message: 'Your personal database is being set up. Please try again in a few minutes.',
        };
      }
      throw error;
    }
  }, {
    body: t.Object({
      cypher: t.String(),
      params: t.Optional(t.Record(t.String(), t.Any())),
    }),
  });
```

2. **Update apps/omnii_mcp/src/routes/index.ts:**
   - Import graphRoutes
   - Add to main router: `.use(graphRoutes)`
   - Ensure authRoutes and authWebhooks are also wired

```typescript
import { Elysia } from 'elysia';
import { authRoutes } from './auth';
import { authWebhooks } from './webhooks/auth';
import { graphRoutes } from './graph';
// ... other existing imports

export const routes = new Elysia()
  // Health check (public)
  .get('/health', () => ({ status: 'ok', version: '1.0.0' }))

  // Auth routes
  .use(authRoutes)

  // Webhooks
  .use(authWebhooks)

  // Protected graph routes
  .use(graphRoutes)

  // ... other existing routes
  ;
```
  </action>
  <verify>
1. Graph routes exist:
```bash
grep -l "/graph/nodes" apps/omnii_mcp/src/routes/graph.ts
```

2. Routes wired:
```bash
grep -l "graphRoutes" apps/omnii_mcp/src/routes/index.ts
```

3. TypeScript compiles:
```bash
cd apps/omnii_mcp && pnpm exec tsc --noEmit
```
  </verify>
  <done>
Protected graph routes created with tenant isolation, wired into main router
  </done>
</task>

<task type="auto">
  <name>Task 2: Update app.ts with proper error handling and startup</name>
  <files>
    apps/omnii_mcp/src/app.ts
  </files>
  <action>
Update the main app entry point to:

1. **Import and validate environment on startup:**
```typescript
// At top of file
import { env } from './config/env';

// This will fail-fast if env is invalid
console.log(`Starting MCP backend in ${env.NODE_ENV} mode`);
```

2. **Add global error handling:**
```typescript
const app = new Elysia()
  .onError(({ error, set }) => {
    console.error('Unhandled error:', error);

    if (error.message.includes('authorization')) {
      set.status = 401;
      return { error: 'Unauthorized', message: error.message };
    }

    if (error.message.includes('not found')) {
      set.status = 404;
      return { error: 'Not Found', message: error.message };
    }

    set.status = 500;
    return { error: 'Internal Server Error', message: env.NODE_ENV === 'development' ? error.message : 'Something went wrong' };
  })
  .use(routes)
  .listen(env.MCP_PORT);

console.log(`MCP backend running at ${env.MCP_BASE_URL}`);
```

3. **Add graceful shutdown:**
```typescript
process.on('SIGINT', () => {
  console.log('Shutting down...');
  process.exit(0);
});

process.on('SIGTERM', () => {
  console.log('Shutting down...');
  process.exit(0);
});
```
  </action>
  <verify>
1. Env imported:
```bash
grep -l "from.*config/env" apps/omnii_mcp/src/app.ts
```

2. Error handler present:
```bash
grep -l "onError" apps/omnii_mcp/src/app.ts
```

3. App starts:
```bash
cd apps/omnii_mcp && timeout 5 bun run src/app.ts 2>&1 | head -30
```
  </verify>
  <done>
App uses env config, has error handling, starts cleanly
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete Phase 1 auth and database infrastructure:
- Neo4j HTTP client (replaces broken driver)
- Environment configuration with OMNII_* namespace
- Supabase auth replacing better-auth
- Database-per-user provisioning via Aura API
- Protected routes with tenant isolation
  </what-built>
  <how-to-verify>
**Prerequisites:**
1. Supabase project configured with Google OAuth
2. Neo4j Aura API credentials obtained
3. Environment variables set in apps/omnii_mcp/.env.local

**Test steps:**

1. **Start the backend:**
```bash
cd apps/omnii_mcp && bun run src/app.ts
```
Expect: Server starts on configured port

2. **Check public endpoints:**
```bash
curl http://localhost:8081/health
curl http://localhost:8081/auth/health
```
Expect: `{"status":"ok",...}`

3. **Test auth rejection (no token):**
```bash
curl http://localhost:8081/graph/status
```
Expect: 401 Unauthorized

4. **Test with valid Supabase JWT:**
Get a JWT from Supabase (via Dashboard or client) and:
```bash
curl -H "Authorization: Bearer YOUR_JWT" http://localhost:8081/auth/me
```
Expect: User info with tenantId

5. **Test graph endpoint (if DB provisioned):**
```bash
curl -H "Authorization: Bearer YOUR_JWT" http://localhost:8081/graph/status
```
Expect: Database status (pending/ready/not_found)
  </how-to-verify>
  <resume-signal>
Type "approved" if auth flow works end-to-end, or describe any issues found.
  </resume-signal>
</task>

</tasks>

<verification>
After all tasks complete:

1. **All routes wired:**
   ```bash
   grep -E "(authRoutes|authWebhooks|graphRoutes)" apps/omnii_mcp/src/routes/index.ts
   ```

2. **Protected routes use middleware:**
   ```bash
   grep -l "use(authMiddleware)" apps/omnii_mcp/src/routes/graph.ts
   ```

3. **TypeScript compiles:**
   ```bash
   cd apps/omnii_mcp && pnpm exec tsc --noEmit
   ```

4. **App starts without errors:**
   ```bash
   cd apps/omnii_mcp && timeout 5 bun run src/app.ts 2>&1 | grep -v "env"
   ```
</verification>

<success_criteria>
- Protected routes require valid JWT (401 without token)
- tenantId flows from auth middleware to Neo4j client factory
- User's queries execute against their provisioned database
- Database provisioning status exposed via /graph/status
- App starts cleanly with proper error handling
- Human verification confirms end-to-end flow works
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-infrastructure/01-05-SUMMARY.md`
</output>
